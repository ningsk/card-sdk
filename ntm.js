/*!
 * MapV3D (MapVGIS for Cesium)三维地球平台  
 * 版本信息：v5.5.0, hash值: 84cbe7777625d5948c99
 * 编译日期：2020-5-23 14:18:18     
 * 版权所有：Copyright by 图洋科技 http://www.aimapvision.com/
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory(require("cesium/Cesium"), require("@turf/turf"));
    else if (typeof define === 'function' && define.amd)
        define(["cesium/Cesium", "@turf/turf"], factory);
    else if (typeof exports === 'object')
        exports["mapv3d"] = factory(require("cesium/Cesium"), require("@turf/turf"));
    else
        root["mapv3d"] = factory(root["Cesium"], root["turf"]);
})(window, function (__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__35__) {
    return /******/ (function (modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
                /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
                /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
            /******/
}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function (exports, name, getter) {
/******/ 		if (!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
                /******/
}
            /******/
};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function (exports) {
/******/ 		if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
                /******/
}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
            /******/
};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function (value, mode) {
/******/ 		if (mode & 1) value = __webpack_require__(value);
/******/ 		if (mode & 8) return value;
/******/ 		if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
            /******/
};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function (module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
            /******/
};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function (object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 74);
        /******/
})
/************************************************************************/
/******/([
/* 0 */
/***/ (function (module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

            /***/
}),
/* 1 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.isArray = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            exports.printVersion = printVersion;
            exports.isNumber = isNumber;
            exports.isString = isString;
            exports.isObject = isObject;
            exports.alert = alert;
            exports.msg = msg;
            exports.getRequest = getRequest;
            exports.getRequestByName = getRequestByName;
            exports.clone = clone;
            exports.isPCBroswer = isPCBroswer;
            exports.getExplorerInfo = getExplorerInfo;
            exports.webglreport = webglreport;
            exports.downloadBase64Image = downloadBase64Image;
            exports.downloadFile = downloadFile;
            exports.formatDegree = formatDegree;
            exports.formatLength = formatLength;
            exports.formatArea = formatArea;
            exports.getLength = getLength;
            exports.getArea = getArea;
            exports.getAreaOfTriangle = getAreaOfTriangle;
            exports.getAngle = getAngle;
            exports.buffer = buffer;
            exports.getGranularity = getGranularity;
            exports.currentTime = currentTime;
            exports.getProxyUrl = getProxyUrl;
            exports.template = template;
            exports.getAttrVal = getAttrVal;
            exports.getPopupForConfig = getPopupForConfig;
            exports.getTooltipForConfig = getTooltipForConfig;
            exports.getPopup = getPopup;
            exports.loopArrayForFun = loopArrayForFun;
            exports.highlightEntity = highlightEntity;
            exports.unHighlightEntity = unHighlightEntity;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _pointconvert = __webpack_require__(3);

            var _version = __webpack_require__(43);

            var ver = _interopRequireWildcard(_version);

            var _turf = __webpack_require__(35);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //打印信息
            function printVersion() {
                var msg = "%c\uD83C\uDF12%c MapV3D %c \u4E09\u7EF4\u5730\u7403\u5E73\u53F0\u8F6F\u4EF6 %c\n\n\u7248 \u672C \u53F7\uFF1A" + ver.version + "    \u3010Cesium\u7248\u672C\uFF1A" + Cesium.VERSION + "\u3011\n\u7F16\u8BD1\u65E5\u671F\uFF1A" + ver.update + " \n\u7248\u6743\u58F0\u660E\uFF1A\n1. MapV3D\u7248\u6743\u5B8C\u5168\u5C5E\u4E8E \"\u676D\u5DDE\u56FE\u6D0B\u4FE1\u606F\u79D1\u6280\u6709\u9650\u516C\u53F8\".\n2. MapV3D\u4E2Dmapv3d.js\u7A0B\u5E8F\u5305\uFF0C\u4EFB\u4F55\u4E2A\u4EBA\u548C\u673A\u6784\u5728\u9075\u5B88\u4E0B\u5217\u6761\u4EF6\u7684\u524D\u63D0\u4E0B\u6388\u6743\u6C38\u4E45\u4F7F\u7528\uFF1A\n    1\uFF09\u4E0D\u8FDB\u884C\u4EFB\u4F55\u5F62\u5F0F\u7684\u7834\u89E3\u548C\u88C1\u526A\uFF0C\u7A0B\u5E8F\u5305\u5B8C\u6574\u5F15\u7528\n    2\uFF09\u4FDD\u7559\u6B64\u7248\u6743\u4FE1\u606F\u5728\u63A7\u5236\u53F0\u8F93\u51FA\n\u6211\u4EEC\u4FDD\u7559\u5BF9\u6B64\u7248\u6743\u4FE1\u606F\u7684\u6700\u7EC8\u89E3\u91CA\u6743.\n\n\uD83C\uDFE0\u5B98\u7F51:  http://www.aimapvision.com/\n";

                var c1 = '\n\tfont-size: 19px;\n\tpadding-left: 10px;\n\tcolor: rgb(240, 133, 25);\n',
                    c2 = "\n\tfont-size: 17px;\n\tline-height: 1.5;\n\tfont-weight: 1000;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(240, 133, 25);\n",
                    c3 = "\n\tfont-size: 15px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tfont-style: italic;\n\tcolor: rgb(240, 133, 25);\n\tpadding-bottom: 5px;\n",
                    c4 = "\n\tfont-size: 12px;\n\tline-height: 1.5;\n\tfont-family: \"\u5FAE\u8F6F\u96C5\u9ED1\";\n\tcolor: rgb(0, 138, 255);\n\t";
                console.log(msg, c1, c2, c3, c4);
            }

            function isNumber(obj) {
                return typeof obj == 'number' && obj.constructor == Number;
            }

            function isString(str) {
                return typeof str == 'string' && str.constructor == String;
            }

            function isObject(obj) {
                return (typeof obj === "undefined" ? "undefined" : _typeof(obj)) == 'object' && obj.constructor == Object;
            }

            var isArray = exports.isArray = Array.isArray || function (obj) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            };

            function alert(msg, title) {
                if (window.haoutil && window.haoutil.alert) //此方法需要引用haoutil 
                    window.haoutil.alert(msg, title); else if (window.layer) //此方法需要引用layer.js
                    layer.alert(msg, {
                        title: title || '提示',
                        skin: 'layui-layer-lan layer-mapv-dialog',
                        closeBtn: 0,
                        anim: 0
                    }); else window.alert(msg);
            };

            function msg(msg) {
                if (window.haoutil && window.haoutil.msg) //此方法需要引用haoutil 
                    window.haoutil.msg(msg); else if (window.toastr) //此方法需要引用toastr 
                    toastr.info(msg); else if (window.layer) layer.msg(msg); //此方法需要引用layer.js
                else window.alert(msg);
            };

            //url参数获取
            function getRequest() {
                var url = location.search; //获取url中"?"符后的字串   
                var theRequest = new Object();
                if (url.indexOf("?") != -1) {
                    var str = url.substr(1);
                    var strs = str.split("&");
                    for (var i = 0; i < strs.length; i++) {
                        theRequest[strs[i].split("=")[0]] = decodeURI(strs[i].split("=")[1]);
                    }
                }
                return theRequest;
            }

            function getRequestByName(name) {
                var reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)", "i");
                var r = window.location.search.substr(1).match(reg);
                if (r != null) return decodeURI(r[2]);
                return null;
            }

            Array.prototype.indexOf = Array.prototype.indexOf || function (val) {
                for (var i = 0; i < this.length; i++) {
                    if (this[i] == val) return i;
                }
                return -1;
            };

            function clone(obj, removeKeys, level) {
                if (level == null) level = 5; //避免死循环，拷贝的层级最大深度
                if (removeKeys == null) removeKeys = ["_layer"];

                if (null == obj || "object" != (typeof obj === "undefined" ? "undefined" : _typeof(obj))) return obj;

                // Handle Date
                if (obj instanceof Date) {
                    var copy = new Date();
                    copy.setTime(obj.getTime());
                    return copy;
                }

                // Handle Array
                if (isArray(obj) && level >= 0) {
                    var copy = [];
                    for (var i = 0, len = obj.length; i < len; ++i) {
                        copy[i] = clone(obj[i], removeKeys, level - 1);
                    }
                    return copy;
                }

                // Handle Object
                if ((typeof obj === "undefined" ? "undefined" : _typeof(obj)) === 'object' && level >= 0) {
                    try {
                        var copy = {};
                        for (var attr in obj) {
                            if (typeof attr === 'function') continue;
                            if (removeKeys.indexOf(attr) != -1) continue;

                            if (obj.hasOwnProperty(attr)) copy[attr] = clone(obj[attr], removeKeys, level - 1);
                        }
                        return copy;
                    } catch (e) {
                        console.log(e);
                    }
                }
                return obj;
            }

            function isPCBroswer() {
                var sUserAgent = navigator.userAgent.toLowerCase();

                var bIsIpad = sUserAgent.match(/ipad/i) == "ipad";
                var bIsIphoneOs = sUserAgent.match(/iphone/i) == "iphone";
                var bIsMidp = sUserAgent.match(/midp/i) == "midp";
                var bIsUc7 = sUserAgent.match(/rv:1.2.3.4/i) == "rv:1.2.3.4";
                var bIsUc = sUserAgent.match(/ucweb/i) == "ucweb";
                var bIsAndroid = sUserAgent.match(/android/i) == "android";
                var bIsCE = sUserAgent.match(/windows ce/i) == "windows ce";
                var bIsWM = sUserAgent.match(/windows mobile/i) == "windows mobile";
                if (bIsIpad || bIsIphoneOs || bIsMidp || bIsUc7 || bIsUc || bIsAndroid || bIsCE || bIsWM) {
                    return false;
                } else {
                    return true;
                }
            }

            //获取浏览器类型及版本
            function getExplorerInfo() {
                var explorer = window.navigator.userAgent.toLowerCase();
                //ie 
                if (explorer.indexOf("msie") >= 0) {
                    var ver = Number(explorer.match(/msie ([\d]+)/)[1]);
                    return { type: "IE", version: ver };
                }
                //firefox 
                else if (explorer.indexOf("firefox") >= 0) {
                    var ver = Number(explorer.match(/firefox\/([\d]+)/)[1]);
                    return { type: "Firefox", version: ver };
                }
                //Chrome
                else if (explorer.indexOf("chrome") >= 0) {
                    var ver = Number(explorer.match(/chrome\/([\d]+)/)[1]);
                    return { type: "Chrome", version: ver };
                }
                //Opera
                else if (explorer.indexOf("opera") >= 0) {
                    var ver = Number(explorer.match(/opera.([\d]+)/)[1]);
                    return { type: "Opera", version: ver };
                }
                //Safari
                else if (explorer.indexOf("Safari") >= 0) {
                    var ver = Number(explorer.match(/version\/([\d]+)/)[1]);
                    return { type: "Safari", version: ver };
                }
                return { type: explorer, version: -1 };
            }

            //检测浏览器webgl支持
            function webglreport() {
                var exinfo = getExplorerInfo();
                if (exinfo.type == "IE" && exinfo.version < 11) {
                    return false;
                }

                try {
                    var glContext;
                    var canvas = document.createElement('canvas');
                    var requestWebgl2 = typeof WebGL2RenderingContext !== 'undefined';
                    if (requestWebgl2) {
                        glContext = canvas.getContext('webgl2') || canvas.getContext('experimental-webgl2') || undefined;
                    }
                    if (glContext == null) {
                        glContext = canvas.getContext('webgl') || canvas.getContext('experimental-webgl') || undefined;
                    }
                    if (glContext == null) {
                        return false;
                    }
                } catch (e) {
                    return false;
                }
                return true;
            }

            function download(fileName, blob) {
                var aLink = document.createElement('a');
                aLink.download = fileName;
                aLink.href = URL.createObjectURL(blob);
                document.body.appendChild(aLink);
                aLink.click();
                document.body.removeChild(aLink);
            }

            function base64Img2Blob(code) {
                var parts = code.split(';base64,');
                var contentType = parts[0].split(':')[1];
                var raw = window.atob(parts[1]);
                var rawLength = raw.length;

                var uInt8Array = new Uint8Array(rawLength);
                for (var i = 0; i < rawLength; ++i) {
                    uInt8Array[i] = raw.charCodeAt(i);
                }
                return new Blob([uInt8Array], { type: contentType });
            }

            //下载导出图片
            function downloadBase64Image(name, base64) {
                var blob = base64Img2Blob(base64);
                download(name + '.png', blob);
            }

            //下载保存文件
            function downloadFile(fileName, string) {
                var blob = new Blob([string]);
                download(fileName, blob);
            }

            //格式化经度/纬度，返回度分秒字符串
            function formatDegree(value) {
                value = Math.abs(value);
                var v1 = Math.floor(value); //度  
                var v2 = Math.floor((value - v1) * 60); //分  
                var v3 = Math.round((value - v1) * 3600 % 60); //秒  
                return v1 + '° ' + v2 + '\'  ' + v3 + '"';
            };

            //  计算长度后，格式化显示长度值, 可指定单位
            //  unit支持:m、km、mile、zhang   默认自动判断 m 或 km
            function formatLength(val, unit) {
                if (val == null) return "";

                if (unit == null || unit == "auto") {
                    if (val < 1000) unit = "m"; else unit = "km";
                }

                var valstr = "";
                switch (unit) {
                    default:
                    case "m":
                        valstr = val.toFixed(2) + '米';
                        break;
                    case "km":
                        valstr = (val * 0.001).toFixed(2) + '公里';
                        break;
                    case "mile":
                        valstr = (val * 0.00054).toFixed(2) + '海里';
                        break;
                    case "zhang":
                        valstr = (val * 0.3).toFixed(2) + '丈';
                        break;
                }
                return valstr;
            }

            //  计算面积后，格式化显示面积值, 可指定单位
            //  unit支持:m、km、mu、ha   默认自动判断 m 或 km
            function formatArea(val, unit) {
                if (val == null) return "";

                if (unit == null || unit == "auto") {
                    if (val < 1000000) unit = "m"; else unit = "km";
                }

                var valstr = "";
                switch (unit) {
                    default:
                    case "m":
                        valstr = val.toFixed(2) + '平方米';
                        break;
                    case "km":
                        valstr = (val / 1000000).toFixed(2) + '平方公里';
                        break;
                    case "mu":
                        valstr = (val * 0.0015).toFixed(2) + '亩';
                        break;
                    case "ha":
                        valstr = (val * 0.0001).toFixed(2) + '公顷';
                        break;
                }

                return valstr;
            }

            //计算长度，单位：米
            function getLength(positions) {
                if (!Cesium.defined(positions) || positions.length < 2) return 0;

                var distance = 0;
                for (var i = 1, len = positions.length; i < len; i++) {
                    distance += Cesium.Cartesian3.distance(positions[i - 1], positions[i]);
                }
                return distance;
            }

            //计算地表投影面积，单位：平方米
            function getArea(positions, noAdd) {
                var coordinates = (0, _pointconvert.cartesians2lonlats)(positions);

                if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

                //API: http://turfjs.org/docs/#area
                var area = (0, _turf.area)({
                    type: "Feature",
                    geometry: {
                        type: "Polygon",
                        coordinates: [coordinates]
                    }
                });
                return area;
            }

            //计算三角形空间面积
            function getAreaOfTriangle(pos1, pos2, pos3) {
                var a = Cesium.Cartesian3.distance(pos1, pos2);
                var b = Cesium.Cartesian3.distance(pos2, pos3);
                var c = Cesium.Cartesian3.distance(pos3, pos1);
                var S = (a + b + c) / 2;
                return Math.sqrt(S * (S - a) * (S - b) * (S - c));
            }

            //求地表方位角，返回：0-360度
            function getAngle(firstPoint, endPoints) {
                var carto1 = Cesium.Cartographic.fromCartesian(firstPoint);
                var carto2 = Cesium.Cartographic.fromCartesian(endPoints);

                var pt1 = {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [Cesium.Math.toDegrees(carto1.longitude), Cesium.Math.toDegrees(carto1.latitude), carto1.height]
                    }
                };
                var pt2 = {
                    type: "Feature",
                    geometry: {
                        type: "Point",
                        coordinates: [Cesium.Math.toDegrees(carto2.longitude), Cesium.Math.toDegrees(carto2.latitude), carto2.height]
                    }
                    //API: http://turfjs.org/docs/#rhumbBearing
                }; var bearing = Math.round((0, _turf.rhumbBearing)(pt1, pt2));
                return bearing;
            }

            //缓冲分析（比如是建筑物单体化时,缓冲扩大点范围）,单位：米
            function buffer(geojson, width) {
                try {
                    width = Cesium.defaultValue(width, 1);
                    //API: http://turfjs.org/docs/#buffer
                    geojson = (0, _turf.buffer)(geojson, width, { units: 'meters', steps: 64 });
                } catch (e) {
                    console.log("缓冲分析失败");
                    console.log(e);
                }
                return geojson;
            }

            //求Rectangle范围内 按count等比插值的granularity值 
            function getGranularity(positions, count) {
                var recta = Cesium.Rectangle.fromCartesianArray(positions);
                var granularity = Math.max(recta.height, recta.width);
                granularity /= Cesium.defaultValue(count, 10); //默认分割10次
                return granularity;
            }

            //取当前时间，用于getValue传参
            function currentTime() {
                if (window.viewer) return window.viewer.clock.currentTime; else return Cesium.JulianDate.fromDate(new Date());
            }

            //判断url加上配置的代理
            function getProxyUrl(config) {
                if (!config.proxy || !config.url) return config;
                if (config.url instanceof Cesium.Resource) return config;

                var opts = {};
                for (var key in config) {
                    opts[key] = config[key];
                }
                opts.url = new Cesium.Resource({
                    url: opts.url,
                    proxy: new Cesium.DefaultProxy(opts.proxy)
                });

                return opts;
            }

            //popup的字符串模板
            function template(str, data) {
                if (str == null) return str;

                for (var col in data) {
                    var showval = data[col];
                    if (showval == null || showval == 'Null' || showval == 'Unknown') showval = "";

                    if (col.substr(0, 1) == "_") {
                        col = col.substring(1); //cesium 内部属性
                    }

                    if (showval.getValue && typeof showval.getValue == 'function') {
                        showval = showval.getValue(currentTime());
                    }

                    str = str.replace(new RegExp('{' + col + '}', "gm"), showval);
                }
                return str;
            }

            //简化Cesium内的属性，去掉getValue等，取最简的键值对。方便popup、tooltip等使用
            function getAttrVal(attr) {
                if (!attr) return attr;

                try {
                    if (attr.getValue) attr = attr.getValue(currentTime());

                    var newattr = {};
                    if (attr._propertyNames && attr._propertyNames.length > 0) {
                        var _iteratorNormalCompletion = true;
                        var _didIteratorError = false;
                        var _iteratorError = undefined;

                        try {
                            for (var _iterator = attr._propertyNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                                var _key = _step.value;

                                var showval = attr[_key];
                                if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown') continue;

                                if (showval.getValue && typeof showval.getValue == 'function') {
                                    newattr[_key] = showval.getValue(currentTime());
                                } else {
                                    if (typeof showval === 'function') continue;
                                    newattr[_key] = showval;
                                }
                            }
                        } catch (err) {
                            _didIteratorError = true;
                            _iteratorError = err;
                        } finally {
                            try {
                                if (!_iteratorNormalCompletion && _iterator.return) {
                                    _iterator.return();
                                }
                            } finally {
                                if (_didIteratorError) {
                                    throw _iteratorError;
                                }
                            }
                        }
                    } else {
                        for (var key in attr) {
                            var showval = attr[key];
                            if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown') continue;

                            if (showval.getValue && typeof showval.getValue == 'function') {
                                newattr[key] = showval.getValue(currentTime());
                            } else {
                                if (typeof showval === 'function') continue;
                                newattr[key] = showval;
                            }
                        }
                    }
                    return newattr;
                } catch (e) {
                    console.log("getAttrVal 出错");
                    console.log(e);
                }
                return attr;
            }

            //根据config配置规则获取popup使用的html字符串
            function getPopupForConfig(cfg, attr) {
                var _title = cfg.popupNameField ? attr[cfg.popupNameField] : cfg.name;
                if (cfg.popupNoTitle) _title = null;

                if (cfg.popup) {
                    return getPopup(cfg.popup, attr, _title);
                } else if (cfg.columns) {
                    return getPopup(cfg.columns, attr, _title);
                }
                return false;
            }

            //根据config配置规则获取tooltip使用的html字符串
            function getTooltipForConfig(cfg, attr) {
                var _title = cfg.tooltipNameField ? attr[cfg.tooltipNameField] : cfg.name;

                if (cfg.tooltip) {
                    return getPopup(cfg.tooltip, attr, _title);
                }
                return false;
            }

            //获取Popup或Tooltip格式化字符串
            function getPopup(cfg, attr, title) {
                if (!attr) return false;

                attr = getAttrVal(attr); //取值

                if (isArray(cfg)) {
                    //数组  
                    var countsok = 0;
                    var inhtml = title ? '<div class="mapv-popup-titile">' + title + '</div>' : '<div style="height: 10px;"></div>';
                    inhtml += '<div class="mapv-popup-content" >';
                    for (var i = 0; i < cfg.length; i++) {
                        var thisfield = cfg[i];

                        var col = thisfield.field;

                        if (thisfield.type == 'details') {
                            //详情按钮 
                            var showval = String.prototype.trim.call(attr[col || "OBJECTID"]);
                            if (showval == null) continue;

                            inhtml += '<div style="text-align: center;padding: 10px 0;"><button type="button" onclick="' + thisfield.calback + '(\'' + showval + '\');" " class="btn btn-info  btn-sm">' + (thisfield.name || '查看详情') + '</button></div>';
                            continue;
                        } else if (thisfield.type == 'html') {
                            inhtml += '<div>' + thisfield.html + '</div>';
                            continue;
                        }

                        if (col == null || attr[col] == null) continue;
                        if (typeof attr[col] === 'function') continue;

                        var showval = String.prototype.trim.call(attr[col]);
                        if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown' || showval == '0' || showval.length == 0) continue;

                        if (thisfield.format) {
                            //使用外部 格式化js方法
                            try {
                                showval = eval(thisfield.format + "(" + showval + ")");
                            } catch (e) {
                                console.log("getPopupByConfig error:" + thisfield.format);
                            }
                        }
                        if (thisfield.unit) {
                            showval += thisfield.unit;
                        }

                        inhtml += '<div><label>' + thisfield.name + '</label>' + showval + '</div>';
                        countsok++;
                    }
                    inhtml += "</div>";

                    if (countsok == 0) return false;
                    return inhtml;
                } else if ((typeof cfg === "undefined" ? "undefined" : _typeof(cfg)) === 'object') {
                    //对象,type区分逻辑
                    switch (cfg.type) {
                        case "iframe":
                            var _url = template(cfg.url, attr);

                            var inhtml = '<iframe id="ifarm" src="' + _url + '"  style="width:' + (cfg.width || '300') + 'px;height:' + (cfg.height || '300') + 'px;overflow:hidden;margin:0;" scrolling="no" frameborder="0" ></iframe>';
                            return inhtml;
                            break;
                        case "javascript":
                            //回调方法 
                            return eval(cfg.calback + "(" + JSON.stringify(attr) + ")");
                            break;
                    }
                } else if (typeof cfg === 'function') {
                    return cfg(attr);
                } else if (cfg == "all") {
                    //全部显示
                    var countsok = 0;
                    var inhtml = title ? '<div class="mapv-popup-titile">' + title + '</div>' : '';
                    inhtml += '<div class="mapv-popup-content" >';
                    for (var col in attr) {
                        try {
                            if (col == null || attr[col] == null) continue;

                            if (col == "Shape" || col == "FID" || col == "OBJECTID" || col == "_definitionChanged" || col == "_propertyNames") continue; //不显示的字段

                            if (col.substr(0, 1) == "_") {
                                col = col.substring(1); //cesium 内部属性
                            }

                            if (_typeof(attr[col]) === 'object' && attr[col].hasOwnProperty && attr[col].hasOwnProperty('getValue')) attr[col] = attr[col].getValue(currentTime());
                            if (typeof attr[col] === 'function') continue;

                            var showval = String.prototype.trim.call(attr[col]);
                            if (showval == null || showval == '' || showval == 'Null' || showval == 'Unknown' || showval == '0' || showval.length == 0) continue; //不显示空值，更美观友好

                            inhtml += '<div><label>' + col + '</label>' + showval + '</div>';
                            countsok++;
                        } catch (e) {
                            console.log(e);
                        }
                    }
                    inhtml += "</div>";

                    if (countsok == 0) return false;
                    return inhtml;
                } else {
                    //格式化字符串 
                    return template(cfg, attr);
                }

                return false;
            }

            //循环执行数组或对象 
            // 调用示例 loopArrayForFun(ArrOrObj, function (entity) {
            //    drawControl.deleteEntity(entity);
            // }); 
            function loopArrayForFun(ArrOrObj, calback) {
                if (ArrOrObj == null) return;
                if (haoutil.isutil.isArray(ArrOrObj)) {
                    var arr = [];
                    for (var i = 0, len = ArrOrObj.length; i < len; i++) {
                        arr.push(calback(ArrOrObj[i]));
                    }
                    return arr;
                } else {
                    return calback(ArrOrObj);
                }
            }

            //定时闪烁高亮Entity（点、线、面）
            var timingFlashingEntity = {
                color: Cesium.Color.YELLOW.withAlpha(0),
                _startTime: function _startTime() {
                    var _this = this;

                    var time = 30;
                    var setp = this.maxAlpha / time;

                    var alpha = 0;
                    this.interVal = setInterval(function () {
                        alpha += setp;
                        if (alpha > _this.maxAlpha) alpha = 0;
                        _this.color = _this.color.withAlpha(alpha);
                    }, time);

                    this.timeEndVal = setTimeout(function () {
                        _this.unHighlight();
                    }, this.time * 1000);
                },
                _stopTime: function _stopTime() {
                    clearInterval(this.interVal);
                    clearTimeout(this.timeEndVal);
                },
                highlight: function highlight(entitys, opts) {
                    var that = this;
                    this.unHighlight();

                    opts = opts || {};

                    this.entitys = entitys;
                    this.maxAlpha = Cesium.defaultValue(opts.maxAlpha, 0.3);
                    this.time = Cesium.defaultValue(opts.time, 10); //播放时长 
                    this.color = Cesium.defaultValue(opts.color, Cesium.Color.YELLOW);
                    this.color = this.color.withAlpha(this.maxAlpha);
                    this.onEnd = opts.onEnd;

                    this._startTime();

                    return loopArrayForFun(entitys, function (entity) {

                        if (entity.polygon) {
                            entity.polygon.material_bak = entity.polygon.material;
                            entity.polygon.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                                return that.color;
                            }, false));
                        } else if (entity.polyline) {
                            entity.polyline.material_bak = entity.polyline.material;
                            entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                                return that.color;
                            }, false));
                        } else if (entity.ellipse) {
                            entity.ellipse.material_bak = entity.ellipse.material;
                            entity.ellipse.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                                return that.color;
                            }, false));
                        } else if (entity.point) {
                            entity.point.color_bak = entity.point.color;
                            entity.point.color = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                                return that.color;
                            }, false));
                        }
                    });
                },
                unHighlight: function unHighlight() {
                    this._stopTime();

                    if (this.entitys) {
                        loopArrayForFun(this.entitys, function (entity) {
                            if (entity.polygon) {
                                if (entity.polygon.material_bak) entity.polygon.material = entity.polygon.material_bak;
                            } else if (entity.polyline) {
                                if (entity.polyline.material_bak) entity.polyline.material = entity.polyline.material_bak;
                            } else if (entity.ellipse) {
                                if (entity.ellipse.material_bak) entity.ellipse.material = entity.ellipse.material_bak;
                            } else if (entity.point) {
                                if (entity.point.color_bak) entity.point.color = entity.point.color_bak;
                            }
                        });
                        if (this.onEnd) this.onEnd(this.entitys);
                        delete this.entitys;
                    }
                }
            };

            //定时闪烁高亮Entity（点、线、面）
            function highlightEntity(entitys, opts) {
                return timingFlashingEntity.highlight(entitys, opts);
            }

            //取消定时闪烁高亮Entity（点、线、面）
            function unHighlightEntity() {
                return timingFlashingEntity.unHighlight();
            }

            /***/
}),
/* 2 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.aroundPoint = exports.windingPoint = undefined;
            exports.formatNum = formatNum;
            exports.formatPosition = formatPosition;
            exports.getPositionValue = getPositionValue;
            exports.formatRectangle = formatRectangle;
            exports.getRectangle = getRectangle;
            exports.getMaxHeight = getMaxHeight;
            exports.addPositionsHeight = addPositionsHeight;
            exports.setPositionsHeight = setPositionsHeight;
            exports.getSurfaceHeight = getSurfaceHeight;
            exports.getSurface3DTilesHeight = getSurface3DTilesHeight;
            exports.getSurfaceTerrainHeight = getSurfaceTerrainHeight;
            exports.setPositionSurfaceHeight = setPositionSurfaceHeight;
            exports.getCurrentMousePosition = getCurrentMousePosition;
            exports.getCenter = getCenter;
            exports.pickCenterPoint = pickCenterPoint;
            exports.getExtent = getExtent;
            exports.getCameraView = getCameraView;
            exports.centerOfMass = centerOfMass;
            exports.isInPoly = isInPoly;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _index = __webpack_require__(26);

            var drawAttr = _interopRequireWildcard(_index);

            var _Attr = __webpack_require__(19);

            var polygonAttr = _interopRequireWildcard(_Attr);

            var _tileset = __webpack_require__(27);

            var _pointconvert = __webpack_require__(3);

            var _util = __webpack_require__(1);

            var _layer = __webpack_require__(20);

            var _turf = __webpack_require__(35);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //格式化 数字 小数位数
            function formatNum(num, digits) {
                return Number(num.toFixed(digits || 0));
            }

            //格式化坐标点为可显示的可理解格式（如：经度x:123.345345、纬度y:31.324324、高度z:123.1）。
            function formatPosition(position) {
                if (!position) return null;
                var carto = Cesium.Cartographic.fromCartesian(position);
                var result = {};
                result.y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
                result.x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
                result.z = formatNum(carto.height, 2);
                return result;
            }

            //获取position的最终value值，因为cesium经常属性或绑定一层，通过该方法可以内部去判断是否有getValue或_value进行取最终value值。
            function getPositionValue(position) {
                if (!position) return position;

                var _position;
                if (position instanceof Cesium.Cartesian3) {
                    _position = position;
                } else if (typeof position.getValue == 'function') {
                    _position = position.getValue((0, _util.currentTime)());
                } else if (position._value && position._value instanceof Cesium.Cartesian3) {
                    _position = position._value;
                }

                return _position;
            }

            //格式化Rectangle
            function formatRectangle(rectangle) {
                var west = formatNum(Cesium.Math.toDegrees(rectangle.west), 6);
                var east = formatNum(Cesium.Math.toDegrees(rectangle.east), 6);
                var north = formatNum(Cesium.Math.toDegrees(rectangle.north), 6);
                var south = formatNum(Cesium.Math.toDegrees(rectangle.south), 6);

                return { xmin: west, xmax: east, ymin: south, ymax: north };
            }

            //获取坐标的边界
            function getRectangle(positions, isFormat) {
                var rectangle = Cesium.Rectangle.fromCartesianArray(positions);
                if (isFormat) return formatRectangle(rectangle); else return rectangle;
            }

            /**
             * 获取坐标数组中最高高程值
             * @param {Array} positions Array<Cartesian3> 笛卡尔坐标数组
             * @param {Number} defaultVal 默认高程值
             */
            function getMaxHeight(positions, defaultVal) {
                if (defaultVal == null) defaultVal = 0;

                var maxHeight = defaultVal;
                if (positions == null || positions.length == 0) return maxHeight;

                for (var i = 0; i < positions.length; i++) {
                    var tempCarto = Cesium.Cartographic.fromCartesian(positions[i]);
                    if (tempCarto.height > maxHeight) {
                        maxHeight = tempCarto.height;
                    }
                }
                return formatNum(maxHeight, 2);
            }

            /**
            * 在坐标基础海拔上增加指定的海拔高度值
            * @param {Array} positions Cartesian3类型的数组
            * @param {Number} height 高度值
            * @return {Array} Cartesian3类型的数组
            */
            function addPositionsHeight(positions, addHeight) {
                addHeight = Number(addHeight) || 0;

                if (isNaN(addHeight) || addHeight == 0) return positions;

                if (positions instanceof Array) {
                    var arr = [];
                    for (var i = 0, len = positions.length; i < len; i++) {
                        var car = Cesium.Cartographic.fromCartesian(positions[i]);
                        var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
                        arr.push(point);
                    }
                    return arr;
                } else {
                    var car = Cesium.Cartographic.fromCartesian(positions);
                    return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height + addHeight);
                }
            }

            /**
            * 设置坐标中海拔高度为指定的高度值
            * @param {Array} positions Cartesian3类型的数组
            * @param {Number} height 高度值
            * @return {Array} Cartesian3类型的数组
            */
            function setPositionsHeight(positions, height) {
                height = Number(height) || 0;

                if (positions instanceof Array) {
                    var arr = [];
                    for (var i = 0, len = positions.length; i < len; i++) {
                        var car = Cesium.Cartographic.fromCartesian(positions[i]);
                        var point = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
                        arr.push(point);
                    }
                    return arr;
                } else {
                    var car = Cesium.Cartographic.fromCartesian(positions);
                    return Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
                }
            }

            /**
            * 获取坐标的贴地(或贴模型)高度
            * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法calback
            */
            function getSurfaceHeight(scene, position, opts) {
                if (scene instanceof Cesium.Viewer) //兼容传入viewer
                    scene = scene.scene;
                opts = opts || {};

                //是否在3ditiles上面
                var _has3dtiles = Cesium.defaultValue(opts.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(scene, position)));
                if (_has3dtiles) {
                    //求贴模型的高度
                    return getSurface3DTilesHeight(scene, position, opts);
                } else {
                    //求贴地形高度
                    return getSurfaceTerrainHeight(scene, position, opts);
                }
            }

            /**
            * 获取坐标的 贴模型高度
            * opts支持:   是否异步 asyn:true  异步回调方法calback返回“新高度”和“原始的Cartographic坐标”
            */
            function getSurface3DTilesHeight(scene, position, opts) {
                opts = opts || {};

                //原始的Cartographic坐标
                opts.cartesian = opts.cartesian || Cesium.Cartographic.fromCartesian(position);
                var carto = opts.cartesian;

                //是否异步求精确高度 
                if (opts.asyn) {
                    scene.clampToHeightMostDetailed([position]).then(function (clampedPositions) {
                        var clampedPt = clampedPositions[0];
                        if (Cesium.defined(clampedPt)) {
                            var cartiles = Cesium.Cartographic.fromCartesian(clampedPt);
                            var heightTiles = cartiles.height;
                            if (Cesium.defined(heightTiles) && heightTiles > -1000) {
                                if (opts.calback) opts.calback(heightTiles, cartiles);
                                return;
                            }
                        }
                        //说明没在模型上，继续求地形上的高度
                        getSurfaceTerrainHeight(scene, position, opts);
                    });
                } else {
                    //取贴模型高度
                    var heightTiles = scene.sampleHeight(carto);
                    if (Cesium.defined(heightTiles) && heightTiles > -1000) {
                        if (opts.calback) opts.calback(heightTiles, carto);
                        return heightTiles;
                    }
                }

                return 0; //表示取值失败
            }

            /**
            * 获取坐标的 贴地高度
            * opts支持:   是否异步 asyn:true  异步回调方法calback
            */
            function getSurfaceTerrainHeight(scene, position, opts) {
                opts = opts || {};

                //原始的Cartographic坐标
                var carto = opts.cartesian || Cesium.Cartographic.fromCartesian(position);

                var _hasTerrain = (0, _layer.hasTerrain)(scene); //是否有地形
                if (!_hasTerrain) {
                    //不存在地形，直接返回
                    if (opts.calback) opts.calback(carto.height, carto);
                    return carto.height;
                }

                //是否异步求精确高度 
                if (opts.asyn) {
                    Cesium.when(Cesium.sampleTerrainMostDetailed(scene.terrainProvider, [carto]), function (samples) {
                        var clampedCart = samples[0];
                        var heightTerrain;
                        if (Cesium.defined(clampedCart) && Cesium.defined(clampedCart.height)) {
                            heightTerrain = clampedCart.height;
                        } else {
                            heightTerrain = scene.globe.getHeight(carto);
                        }
                        if (opts.calback) opts.calback(heightTerrain, carto);
                    });
                } else {
                    var heightTerrain = scene.globe.getHeight(carto);
                    if (Cesium.defined(heightTerrain) && heightTerrain > -1000) {
                        if (opts.calback) opts.calback(heightTerrain, carto);
                        return heightTerrain;
                    }
                }
                return 0; //表示取值失败
            }

            /**
            * 设置坐标中海拔高度为贴地或贴模型的高度 
            * opts支持:  是否在has3dtiles:true , 是否异步 asyn:true  异步回调方法calback
            */
            function setPositionSurfaceHeight(scene, position, opts) {
                opts = opts || {};
                var carto = Cesium.Cartographic.fromCartesian(position);

                var height = getSurfaceHeight(scene, position, opts);
                if (height != 0) {
                    if (opts.relativeHeight) height += carto.height; //Cesium.HeightReference.RELATIVE_TO_GROUND时
                    var positionNew = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
                    return positionNew;
                }
                return position;
            }

            function hasPickedModel(pickedObject, noPickEntity) {
                if (Cesium.defined(pickedObject.id)) {
                    //entity 
                    var entity = pickedObject.id;
                    if (entity._noMousePosition) return false; //排除标识不拾取的对象
                    if (noPickEntity && entity == noPickEntity) return false;
                }

                if (Cesium.defined(pickedObject.primitive)) {
                    //primitive
                    var primitive = pickedObject.primitive;
                    if (primitive._noMousePosition) return false; //排除标识不拾取的对象
                    if (noPickEntity && primitive == noPickEntity) return false;
                }

                return true;
            }

            /**
             * 获取鼠标当前的屏幕坐标位置的三维Cesium坐标
             * @param {Cesium.Scene} scene 
             * @param {Cesium.Cartesian2} position 二维屏幕坐标位置
             * @param {Cesium.Entity} noPickEntity 排除的对象（主要用于绘制中，排除对自己本身的拾取）
             */
            function getCurrentMousePosition(scene, position, noPickEntity) {
                var cartesian;

                //在模型上提取坐标   
                var pickedObject;
                try {
                    pickedObject = scene.pick(position, 5, 5);
                } catch (e) { }

                if (scene.pickPositionSupported && Cesium.defined(pickedObject) && hasPickedModel(pickedObject, noPickEntity)) {
                    //pickPositionSupported :判断是否支持深度拾取,不支持时无法进行鼠标交互绘制

                    var cartesian = scene.pickPosition(position);
                    if (Cesium.defined(cartesian)) {
                        var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                        if (cartographic.height >= 0) return cartesian;

                        //不是entity时，支持3dtiles地下
                        if (!Cesium.defined(pickedObject.id) && cartographic.height >= -500) return cartesian;
                    }
                }

                //超图s3m数据拾取
                if (Cesium.defined(Cesium.S3MTilesLayer)) {
                    var cartesian = scene.pickPosition(position);
                    if (Cesium.defined(cartesian)) {
                        return cartesian;
                    }
                }

                //测试scene.pickPosition和globe.pick的适用场景 https://zhuanlan.zhihu.com/p/44767866
                //1. globe.pick的结果相对稳定准确，不论地形深度检测开启与否，不论加载的是默认地形还是别的地形数据；
                //2. scene.pickPosition只有在开启地形深度检测，且不使用默认地形时是准确的。
                //注意点： 1. globe.pick只能求交地形； 2. scene.pickPosition不仅可以求交地形，还可以求交除地形以外其他所有写深度的物体。

                //提取鼠标点的地理坐标 
                if (scene.mode === Cesium.SceneMode.SCENE3D) {
                    //三维模式下
                    var pickRay = scene.camera.getPickRay(position);
                    cartesian = scene.globe.pick(pickRay, scene);
                } else {
                    //二维模式下
                    cartesian = scene.camera.pickEllipsoid(position, scene.globe.ellipsoid);
                }

                if (Cesium.defined(cartesian) && scene.camera.positionCartographic.height < 10000) {
                    var cartographic = Cesium.Cartographic.fromCartesian(cartesian);
                    // console.log(cartographic.height);
                    if (cartographic.height < -5000) return null; //屏蔽无效值
                }

                return cartesian;
            }

            //提取屏幕中心点坐标
            function getCenter(viewer, isToWgs) {
                var bestTarget = pickCenterPoint(viewer.scene);
                if (!Cesium.defined(bestTarget)) {
                    bestTarget = setPositionSurfaceHeight(viewer, viewer.scene.camera.positionWC);
                }

                var result = formatPosition(bestTarget);
                if (isToWgs) result = viewer.mapv.point2wgs(result); //坐标转换为wgs

                // 获取地球中心点世界位置  与  摄像机的世界位置  之间的距离
                // var distance = Cesium.Cartesian3.distance(bestTarget, viewer.scene.camera.positionWC);
                // result.cameraZ = distance;

                return result;
            }

            //取屏幕中心点坐标
            function pickCenterPoint(scene) {
                var canvas = scene.canvas;
                var center = new Cesium.Cartesian2(canvas.clientWidth / 2, canvas.clientHeight / 2);

                var ray = scene.camera.getPickRay(center);
                var target = scene.globe.pick(ray, scene);
                if (!target) target = scene.camera.pickEllipsoid(center);
                return target;
            }

            //export function getLevel(viewer) {
            //    var _layers = viewer.imageryLayers._layers;
            //    if (_layers.length == 0) return -1;

            //    var _imageryCache = _layers[0]._imageryCache;
            //    var maxLevel = 0;
            //    for (var i in _imageryCache) {
            //        var imagery = _imageryCache[i];
            //        if (imagery.level > maxLevel)
            //            maxLevel = imagery.level;
            //    } 
            //    return maxLevel;
            //}


            //提取地球视域边界
            function getExtent(target, opts) {
                opts = opts || {};

                // 范围对象
                var extent = { xmin: 0, xmax: 0, ymin: 0, ymax: 0 };

                if (target instanceof Cesium.Viewer) {
                    // var rectangle = viewer.camera.computeViewRectangle(); //不支持二维模式
                    // if (rectangle == null) return null; 
                    // var extent = formatRectangle(rectangle);  // 范围对象

                    //默认值：中国区域
                    extent = { xmin: 70, xmax: 140, ymin: 0, ymax: 55 };

                    // 得到当前三维场景
                    var viewer = target;
                    var scene = viewer.scene;

                    // 得到当前三维场景的椭球体
                    var ellipsoid = scene.globe.ellipsoid;
                    var canvas = scene.canvas;

                    // canvas左上角
                    var car3_lt = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), ellipsoid);
                    if (car3_lt) {
                        // 在椭球体上
                        var carto_lt = ellipsoid.cartesianToCartographic(car3_lt);
                        extent.xmin = Cesium.Math.toDegrees(carto_lt.longitude);
                        extent.ymax = Cesium.Math.toDegrees(carto_lt.latitude);
                    } else {
                        // 不在椭球体上 
                        var xMax = canvas.width / 2;
                        var yMax = canvas.height / 2;

                        var car3_lt2;
                        // 这里每次10像素递加，一是10像素相差不大，二是为了提高程序运行效率
                        for (var yIdx = 0; yIdx <= yMax; yIdx += 10) {
                            var xIdx = yIdx <= xMax ? yIdx : xMax;
                            car3_lt2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(xIdx, yIdx), ellipsoid);
                            if (car3_lt2) break;
                        }
                        if (car3_lt2) {
                            var carto_lt = ellipsoid.cartesianToCartographic(car3_lt2);
                            extent.xmin = Cesium.Math.toDegrees(carto_lt.longitude);
                            extent.ymax = Cesium.Math.toDegrees(carto_lt.latitude);
                        }
                    }

                    // canvas右下角
                    var car3_rb = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), ellipsoid);
                    if (car3_rb) {
                        // 在椭球体上
                        var carto_rb = ellipsoid.cartesianToCartographic(car3_rb);
                        extent.xmax = Cesium.Math.toDegrees(carto_rb.longitude);
                        extent.ymin = Cesium.Math.toDegrees(carto_rb.latitude);
                    } else {
                        // 不在椭球体上
                        var xMax = canvas.width / 2;
                        var yMax = canvas.height / 2;

                        var car3_rb2;
                        // 这里每次10像素递减，一是10像素相差不大，二是为了提高程序运行效率
                        for (var yIdx = canvas.height; yIdx >= yMax; yIdx -= 10) {
                            var xIdx = yIdx >= xMax ? yIdx : xMax;
                            car3_rb2 = viewer.camera.pickEllipsoid(new Cesium.Cartesian2(xIdx, yIdx), ellipsoid);
                            if (car3_rb2) break;
                        }
                        if (car3_rb2) {
                            var carto_rb = ellipsoid.cartesianToCartographic(car3_rb2);
                            extent.xmax = Cesium.Math.toDegrees(carto_rb.longitude);
                            extent.ymin = Cesium.Math.toDegrees(carto_rb.latitude);
                        }
                    }

                    if (opts.isToWgs) {
                        //坐标转换为wgs
                        var pt1 = viewer.mapv.point2wgs({ x: extent.xmin, y: extent.ymin });
                        extent.xmin = pt1.x;
                        extent.ymin = pt1.y;

                        var pt2 = viewer.mapv.point2wgs({ x: extent.xmax, y: extent.ymax });
                        extent.xmax = pt2.x;
                        extent.ymax = pt2.y;
                    }
                } else if (target instanceof Cesium.Entity) {
                    //传入Entity对象 
                    var positions = drawAttr.getPositions(target);
                    extent = getRectangle(positions, true);
                } else if ((0, _util.isArray)(target)) {
                    //传入Entity对象数组
                    var positions = [];
                    for (var i = 0, len = target.length; i < len; i++) {
                        var pts = drawAttr.getPositions(target[i]);
                        positions = positions.concat(pts);
                    }
                    extent = getRectangle(positions, true);
                }

                //交换
                if (extent.xmax < extent.xmin) {
                    var temp = extent.xmax;
                    extent.xmax = extent.xmin;
                    extent.xmin = temp;
                }
                if (extent.ymax < extent.ymin) {
                    var temp = extent.ymax;
                    extent.ymax = extent.ymin;
                    extent.ymin = temp;
                }

                //缩放
                if (opts.scale) {
                    var old_xmin = extent.xmin;
                    var old_xmax = extent.xmax;
                    var old_ymin = extent.ymin;
                    var old_ymax = extent.ymax;

                    //限定最大倍数
                    if (opts.scale > 3) opts.scale = 3;
                    if (opts.scale < -3) opts.scale = -3;

                    var stepx = (extent.xmax - extent.xmin) * opts.scale;
                    extent.xmin -= stepx;
                    extent.xmax += stepx;
                    var stepy = (extent.ymax - extent.ymin) * opts.scale;
                    extent.ymin -= stepy;
                    extent.ymax += stepy;

                    //如果超出地球范围，还原放大的值
                    if (extent.xmin < -180 || extent.xmax > 180 || extent.ymin < -90 || extent.ymax > 90) {
                        extent.xmin = old_xmin;
                        extent.xmax = old_xmax;
                        extent.ymin = old_ymin;
                        extent.ymax = old_ymax;
                    }
                }

                return extent;
            }

            //提取相机视角范围参数 
            function getCameraView(viewer, isToWgs) {
                var camera = viewer.camera;
                var position = camera.positionCartographic;

                var bookmark = {};
                bookmark.y = formatNum(Cesium.Math.toDegrees(position.latitude), 6);
                bookmark.x = formatNum(Cesium.Math.toDegrees(position.longitude), 6);
                bookmark.z = formatNum(position.height, 2);
                bookmark.heading = formatNum(Cesium.Math.toDegrees(camera.heading || -90), 1);
                bookmark.pitch = formatNum(Cesium.Math.toDegrees(camera.pitch || 0), 1);
                bookmark.roll = formatNum(Cesium.Math.toDegrees(camera.roll || 0), 1);

                if (isToWgs) bookmark = viewer.mapv.point2wgs(bookmark); //坐标转换为wgs

                return bookmark;
            }

            //Turf求面的中心点 
            function centerOfMass(positions, height) {
                try {
                    if (positions.length == 1) {
                        return positions[0];
                    } else if (positions.length == 2) {
                        return Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                    }

                    if (height == null) {
                        height = getMaxHeight(positions);
                    }

                    var coordinates = (0, _pointconvert.cartesians2lonlats)(positions);
                    coordinates.push(coordinates[0]);

                    var center = (0, _turf.centerOfMass)({
                        type: "Feature",
                        geometry: {
                            type: "Polygon",
                            coordinates: [coordinates]
                        }
                    });
                    var centerX = center.geometry.coordinates[0];
                    var centerY = center.geometry.coordinates[1];

                    //所求的中心点在边界外时，求矩形中心点
                    var extent = getRectangle(positions, true);
                    if (centerX < extent.xmin || centerX > extent.xmax || centerY < extent.ymin || centerY > extent.ymax) {
                        centerX = (extent.xmin + extent.xmax) / 2;
                        centerY = (extent.ymin + extent.ymax) / 2;
                    }

                    var ptcenter = Cesium.Cartesian3.fromDegrees(centerX, centerY, height);
                    return ptcenter;
                } catch (e) {
                    return positions[Math.floor(positions.length / 2)];
                }
            }

            //点 是否在 entity（面、圆、多边形）内
            function isInPoly(position, entity) {
                if (!entity || !position) return false;

                if (entity.rectangle) {
                    var rectangle = entity.rectangle.coordinates.getValue((0, _util.currentTime)());

                    var isInRectangle = Cesium.Rectangle.contains(rectangle, Cesium.Cartographic.fromCartesian(position));
                    return isInRectangle;
                } else if (entity.ellipse) {
                    var center = entity.position.getValue((0, _util.currentTime)());
                    center = setPositionsHeight(center, 0);
                    var radiu = entity.ellipse.semiMajorAxis.getValue((0, _util.currentTime)());

                    var len = Cesium.Cartesian3.distance(center, position);
                    return len <= radiu; //小于半径的说明在圆内
                } else if (entity.polygon) {
                    var point = formatPosition(position);
                    var pt = {
                        type: "Feature",
                        geometry: { type: "Point", coordinates: [point.x, point.y, point.z] }
                    };

                    var poly = polygonAttr.toGeoJSON(entity);
                    var isInArea = (0, _turf.booleanPointInPolygon)(pt, poly); //turf插件计算的 
                    return isInArea;
                }
                return false;
            }

            //绕点 环绕飞行
            var windingPoint = exports.windingPoint = {
                isStart: false,
                viewer: null,
                start: function start(viewer, point) {
                    this.viewer = viewer;
                    if (point && point instanceof Cesium.Cartesian3) {
                        this.position = point;
                    } else {
                        if (!point) point = getCenter(viewer);
                        this.position = Cesium.Cartesian3.fromDegrees(point.x, point.y, point.z);
                    }

                    this.distance = point.distance || Cesium.Cartesian3.distance(this.position, viewer.camera.positionWC); // 给定相机距离点多少距离飞行 
                    this.angle = 360 / (point.time || 60); //time：给定飞行一周所需时间(单位 秒)

                    this.time = viewer.clock.currentTime.clone();
                    this.heading = viewer.camera.heading; // 相机的当前heading
                    this.pitch = viewer.camera.pitch;

                    this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
                    this.isStart = true;
                },
                clock_onTickHandler: function clock_onTickHandler(e) {
                    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
                    var heading = Cesium.Math.toRadians(delTime * this.angle) + this.heading;

                    this.viewer.scene.camera.setView({
                        destination: this.position, // 点的坐标
                        orientation: {
                            heading: heading,
                            pitch: this.pitch
                        }
                    });
                    this.viewer.scene.camera.moveBackward(this.distance);
                },
                stop: function stop() {
                    if (!this.isStart) return;

                    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
                    this.isStart = false;
                }
            };

            //固定点 向四周旋转
            var aroundPoint = exports.aroundPoint = {
                isStart: false,
                viewer: null,
                start: function start(viewer, point) {
                    this.viewer = viewer;
                    if (point && point instanceof Cesium.Cartesian3) {
                        this.position = point;
                    } else {
                        if (!point) point = getCenter(viewer);
                        this.position = Cesium.Cartesian3.fromDegrees(point.x, point.y, point.z);
                    }

                    this.angle = 360 / (point.time || 60); //time：给定飞行一周所需时间(单位 秒)

                    this.time = viewer.clock.currentTime.clone();
                    this.heading = viewer.camera.heading; // 相机的当前heading
                    this.pitch = viewer.camera.pitch;

                    this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
                    this.isStart = true;
                },
                clock_onTickHandler: function clock_onTickHandler(e) {
                    // 当前已经过去的时间，单位s
                    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time);
                    var heading = Cesium.Math.toRadians(delTime * this.angle) + this.heading;
                    this.viewer.scene.camera.setView({
                        orientation: {
                            heading: heading,
                            pitch: this.pitch
                        }
                    });
                },
                stop: function stop() {
                    if (!this.isStart) return;

                    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
                    this.isStart = false;
                }
            };

            /***/
}),
/* 3 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.cartesian2lonlat = cartesian2lonlat;
            exports.cartesians2lonlats = cartesians2lonlats;
            exports.cartesian2mercator = cartesian2mercator;
            exports.cartesians2mercators = cartesians2mercators;
            exports.lonlat2cartesian = lonlat2cartesian;
            exports.lonlats2cartesians = lonlats2cartesians;
            exports.lonlat2mercator = lonlat2mercator;
            exports.lonlats2mercators = lonlats2mercators;
            exports.mercator2cartesian = mercator2cartesian;
            exports.mercators2cartesians = mercators2cartesians;
            exports.mercator2lonlat = mercator2lonlat;
            exports.mercators2lonlats = mercators2lonlats;
            exports.bd2gcj = bd2gcj;
            exports.gcj2bd = gcj2bd;
            exports.wgs2gcj = wgs2gcj;
            exports.gcj2wgs = gcj2wgs;
            exports.bd2wgs = bd2wgs;
            exports.wgs2bd = wgs2bd;
            exports.jwd2mct = jwd2mct;
            exports.mct2jwd = mct2jwd;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var isArray = Array.isArray || function (obj) {
                return Object.prototype.toString.call(obj) === '[object Array]';
            };

            //格式化 数字 小数位数
            function formatNum(num, digits) {
                return Number(num.toFixed(digits || 0));
            }

            //===============提供了cesium内部不同对象之间的坐标转换==============

            //cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
            function cartesian2lonlat(cartesian) {
                var carto = Cesium.Cartographic.fromCartesian(cartesian);
                if (carto == null) return null;

                var x = formatNum(Cesium.Math.toDegrees(carto.longitude), 6);
                var y = formatNum(Cesium.Math.toDegrees(carto.latitude), 6);
                var z = formatNum(carto.height, 2);

                return [x, y, z];
            }

            //数组，cesium笛卡尔空间坐标 转 经纬度坐标【用于转geojson】
            function cartesians2lonlats(positions) {
                var coordinates = [];
                for (var i = 0, len = positions.length; i < len; i++) {
                    var point = cartesian2lonlat(positions[i]);
                    if (point) coordinates.push(point);
                }
                return coordinates;
            }

            var webMercatorProjection = new Cesium.WebMercatorProjection();

            //cesium笛卡尔空间坐标 转 web mercator投影坐标
            function cartesian2mercator(position) {
                if (!position) return null;
                var point = webMercatorProjection.project(Cesium.Cartographic.fromCartesian(position));
                return [point.x, point.y, point.z];
            }

            //数组，cesium笛卡尔空间坐标 转 web mercator投影坐标
            function cartesians2mercators(arr) {
                var arrNew = [];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var point = cartesian2mercator(arr[i]);
                    if (point) arrNew.push(point);
                }
                return arrNew;
            }

            //经纬度坐标 转 cesium笛卡尔空间坐标
            function lonlat2cartesian(coord, defHeight) {
                if (!coord || coord.length < 2) return null;
                return Cesium.Cartesian3.fromDegrees(coord[0], coord[1], coord[2] || defHeight || 0);
            }

            //数组，经纬度坐标 转 cesium笛卡尔空间坐标
            function lonlats2cartesians(coords, defHeight) {
                var arr = [];
                for (var i = 0, len = coords.length; i < len; i++) {
                    var item = coords[i];
                    if (isArray(item[0])) {
                        var arr2 = lonlats2cartesians(item, defHeight);
                        if (arr2 && arr2.length > 0) arr.push(arr2);
                    } else {
                        var cartesian = lonlat2cartesian(item, defHeight);
                        if (cartesian) arr.push(cartesian);
                    }
                }
                return arr;
            }

            //地理坐标 转 投影坐标
            function lonlat2mercator(lnglat) {
                var cartesian = lonlat2cartesian(lnglat);
                return cartesian2mercator(cartesian);
            }
            //数组，地理坐标 转 投影坐标
            function lonlats2mercators(arr) {
                var arrNew = [];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var point = lonlat2mercator(arr[i]);
                    arrNew.push(point);
                }
                return arrNew;
            }

            //投影坐标 转 cesium笛卡尔空间坐标
            function mercator2cartesian(point) {
                if (isNaN(point[0]) || isNaN(point[1])) return null;

                // var x = point[0] / 20037508.34 * 180;
                // var y = point[1] / 20037508.34 * 180;
                // y = 180 / Math.PI * (2 * Math.atan(Math.exp(y * Math.PI / 180)) - Math.PI / 2); 
                // return Cesium.Cartesian3.fromDegrees(x,y);

                var carto = webMercatorProjection.unproject(new Cesium.Cartesian3(point[0], point[1], point[2] || 0));
                return Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height);
            }
            //数组，投影坐标 转 cesium笛卡尔空间坐标
            function mercators2cartesians(arr) {
                var arrNew = [];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var point = mercator2cartesian(arr[i]);
                    if (point) arrNew.push(point);
                }
                return arrNew;
            }

            //投影坐标 转 地理坐标
            function mercator2lonlat(point) {
                var cartesian = mercator2cartesian(point);
                return cartesian2lonlat(cartesian);
            }
            //数组，投影坐标 转 地理坐标
            function mercators2lonlats(arr) {
                var arrNew = [];
                for (var i = 0, len = arr.length; i < len; i++) {
                    var point = mercator2lonlat(arr[i]);
                    arrNew.push(point);
                }
                return arrNew;
            }

            //========提供了百度（BD09）、国测局（GCJ02）、WGS84、Web墨卡托 4类坐标之间的转换=======
            //传入参数 和 返回结果 均是数组：[经度,纬度] 

            //定义一些常量
            var x_PI = 3.14159265358979324 * 3000.0 / 180.0;
            var PI = 3.1415926535897932384626;
            var a = 6378245.0;
            var ee = 0.00669342162296594323;

            function transformlat(lng, lat) {
                var ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
                ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
                ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
                return ret;
            }

            function transformlng(lng, lat) {
                var ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
                ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
                ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
                ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
                return ret;
            }

            /**
             * 判断是否在国内，不在国内则不做偏移
             * @param lng
             * @param lat
             * @returns {boolean}
             */
            function out_of_china(lng, lat) {
                return lng < 72.004 || lng > 137.8347 || lat < 0.8293 || lat > 55.8271 || false;
            }

            /**
             * 百度坐标系 (BD-09) 与 国测局坐标系 (GCJ-02)的转换
             * 即 百度 转 谷歌、高德
             * @param bd_lon
             * @param bd_lat
             * @returns {*[]}
             */
            function bd2gcj(arrdata) {
                var bd_lon = Number(arrdata[0]);
                var bd_lat = Number(arrdata[1]);

                var x_pi = 3.14159265358979324 * 3000.0 / 180.0;
                var x = bd_lon - 0.0065;
                var y = bd_lat - 0.006;
                var z = Math.sqrt(x * x + y * y) - 0.00002 * Math.sin(y * x_pi);
                var theta = Math.atan2(y, x) - 0.000003 * Math.cos(x * x_pi);
                var gg_lng = z * Math.cos(theta);
                var gg_lat = z * Math.sin(theta);

                gg_lng = Number(gg_lng.toFixed(6));
                gg_lat = Number(gg_lat.toFixed(6));
                return [gg_lng, gg_lat];
            };

            /**
             * 国测局坐标系 (GCJ-02) 与百度坐标系 (BD-09) 的转换
             * 即谷歌、高德 转 百度
             * @param lng
             * @param lat
             * @returns {*[]}
             */
            function gcj2bd(arrdata) {
                var lng = Number(arrdata[0]);
                var lat = Number(arrdata[1]);

                var z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_PI);
                var theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_PI);
                var bd_lng = z * Math.cos(theta) + 0.0065;
                var bd_lat = z * Math.sin(theta) + 0.006;

                bd_lng = Number(bd_lng.toFixed(6));
                bd_lat = Number(bd_lat.toFixed(6));
                return [bd_lng, bd_lat];
            };

            /**
             * WGS84转GCj02
             * @param lng
             * @param lat
             * @returns {*[]}
             */
            function wgs2gcj(arrdata) {
                var lng = Number(arrdata[0]);
                var lat = Number(arrdata[1]);

                if (out_of_china(lng, lat)) {
                    return [lng, lat];
                } else {
                    var dlat = transformlat(lng - 105.0, lat - 35.0);
                    var dlng = transformlng(lng - 105.0, lat - 35.0);
                    var radlat = lat / 180.0 * PI;
                    var magic = Math.sin(radlat);
                    magic = 1 - ee * magic * magic;
                    var sqrtmagic = Math.sqrt(magic);
                    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
                    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);
                    var mglat = lat + dlat;
                    var mglng = lng + dlng;

                    mglng = Number(mglng.toFixed(6));
                    mglat = Number(mglat.toFixed(6));
                    return [mglng, mglat];
                }
            };

            /**
             * GCJ02 转换为 WGS84
             * @param lng
             * @param lat
             * @returns {*[]}
             */
            function gcj2wgs(arrdata) {
                var lng = Number(arrdata[0]);
                var lat = Number(arrdata[1]);

                if (out_of_china(lng, lat)) {
                    return [lng, lat];
                } else {
                    var dlat = transformlat(lng - 105.0, lat - 35.0);
                    var dlng = transformlng(lng - 105.0, lat - 35.0);
                    var radlat = lat / 180.0 * PI;
                    var magic = Math.sin(radlat);
                    magic = 1 - ee * magic * magic;
                    var sqrtmagic = Math.sqrt(magic);
                    dlat = dlat * 180.0 / (a * (1 - ee) / (magic * sqrtmagic) * PI);
                    dlng = dlng * 180.0 / (a / sqrtmagic * Math.cos(radlat) * PI);

                    var mglat = lat + dlat;
                    var mglng = lng + dlng;

                    var jd = lng * 2 - mglng;
                    var wd = lat * 2 - mglat;

                    jd = Number(jd.toFixed(6));
                    wd = Number(wd.toFixed(6));
                    return [jd, wd];
                }
            };

            //百度经纬度坐标 转 标准WGS84坐标   
            function bd2wgs(arrdata) {
                return gcj2wgs(bd2gcj(arrdata));
            };

            //标准WGS84坐标  转 百度经纬度坐标   
            function wgs2bd(arrdata) {
                return gcj2bd(wgs2gcj(arrdata));
            };

            //经纬度转Web墨卡托  
            function jwd2mct(arrdata) {
                var lng = Number(arrdata[0]);
                var lat = Number(arrdata[1]);

                var x = lng * 20037508.34 / 180;
                var y = Math.log(Math.tan((90 + lat) * PI / 360)) / (PI / 180);
                y = y * 20037508.34 / 180;

                x = Number(x.toFixed(2));
                y = Number(y.toFixed(2));
                return [x, y];
            };

            //Web墨卡托转经纬度  
            function mct2jwd(arrdata) {
                var lng = Number(arrdata[0]);
                var lat = Number(arrdata[1]);

                var x = lng / 20037508.34 * 180;
                var y = lat / 20037508.34 * 180;
                y = 180 / PI * (2 * Math.atan(Math.exp(y * PI / 180)) - PI / 2);

                x = Number(x.toFixed(6));
                y = Number(y.toFixed(6));
                return [x, y];
            };

            /***/
}),
/* 4 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Draw = undefined;
            exports.register = register;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Events = __webpack_require__(79);

            var _Tooltip = __webpack_require__(5);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            var _Util = __webpack_require__(7);

            var DrawUtil = _interopRequireWildcard(_Util);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            var _index = __webpack_require__(26);

            var _Draw = __webpack_require__(32);

            var _Draw2 = __webpack_require__(24);

            var _Draw3 = __webpack_require__(41);

            var _Draw4 = __webpack_require__(96);

            var _Draw5 = __webpack_require__(97);

            var _Draw6 = __webpack_require__(14);

            var _Draw7 = __webpack_require__(98);

            var _Draw8 = __webpack_require__(99);

            var _Draw9 = __webpack_require__(100);

            var _Draw10 = __webpack_require__(61);

            var _Draw11 = __webpack_require__(101);

            var _Draw12 = __webpack_require__(102);

            var _Draw13 = __webpack_require__(103);

            var _Draw14 = __webpack_require__(105);

            var _Draw15 = __webpack_require__(106);

            var _Draw16 = __webpack_require__(107);

            var _Draw17 = __webpack_require__(108);

            var _DrawP = __webpack_require__(109);

            var _Draw18 = __webpack_require__(9);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //类库外部扩展的类
            var exDraw = {};
            function register(type, layerClass) {
                exDraw[type] = layerClass;
            }

            var Draw = exports.Draw = _Events.Evented.extend({
                dataSource: null,
                primitives: null,
                drawCtrl: null,
                //初始化
                initialize: function initialize(viewer, options) {
                    this.viewer = viewer;
                    this.options = options || {};

                    this.dataSource = new Cesium.CustomDataSource(); //用于entity
                    this.viewer.dataSources.add(this.dataSource);

                    this.primitives = new Cesium.PrimitiveCollection(); //用于primitive
                    this.viewer.scene.primitives.add(this.primitives);

                    if (Cesium.defaultValue(this.options.removeScreenSpaceEvent, true)) {
                        this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                        this.viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);
                    }

                    this.tooltip = new _Tooltip.Tooltip(this.viewer.container); //鼠标提示信息

                    this.hasEdit(Cesium.defaultValue(this.options.hasEdit, true)); //是否可编辑

                    //编辑工具初始化
                    var _opts = {
                        viewer: this.viewer,
                        dataSource: this.dataSource,
                        primitives: this.primitives,
                        tooltip: this.tooltip
                    };

                    //entity
                    this.drawCtrl = {};
                    this.drawCtrl['point'] = new _Draw2.DrawPoint(_opts);
                    this.drawCtrl['billboard'] = new _Draw3.DrawBillboard(_opts);
                    this.drawCtrl['label'] = new _Draw4.DrawLabel(_opts);
                    this.drawCtrl['model'] = new _Draw5.DrawModel(_opts);

                    this.drawCtrl['polyline'] = new _Draw6.DrawPolyline(_opts);
                    this.drawCtrl['curve'] = new _Draw7.DrawCurve(_opts);
                    this.drawCtrl['polylineVolume'] = new _Draw8.DrawPolylineVolume(_opts);
                    this.drawCtrl['corridor'] = new _Draw9.DrawCorridor(_opts);

                    this.drawCtrl['polygon'] = new _Draw10.DrawPolygon(_opts);
                    this.drawCtrl['rectangle'] = new _Draw11.DrawRectangle(_opts);
                    this.drawCtrl['ellipse'] = new _Draw12.DrawCircle(_opts);
                    this.drawCtrl['circle'] = this.drawCtrl['ellipse']; //圆
                    this.drawCtrl['cylinder'] = new _Draw13.DrawCylinder(_opts);
                    this.drawCtrl['ellipsoid'] = new _Draw14.DrawEllipsoid(_opts);
                    this.drawCtrl['wall'] = new _Draw15.DrawWall(_opts);
                    this.drawCtrl['box'] = new _Draw17.DrawBox(_opts);
                    this.drawCtrl['plane'] = new _Draw16.DrawPlane(_opts);

                    //primitive
                    this.drawCtrl['model-p'] = new _DrawP.DrawPModel(_opts);

                    //外部图层
                    for (var key in exDraw) {
                        this.drawCtrl[key] = new exDraw[key](_opts);
                    }

                    //绑定事件抛出方法
                    var that = this;
                    for (var type in this.drawCtrl) {
                        this.drawCtrl[type]._fire = function (type, data, propagate) {
                            that.fire(type, data, propagate);
                        };
                    }

                    //创建完成后激活编辑 
                    this.on(EventType.DrawCreated, function (e) {
                        this.startEditing(e.entity);
                    }, this);
                },

                //==========绘制相关==========
                startDraw: function startDraw(attribute) {
                    //参数是字符串id或uri时
                    if (typeof attribute === 'string') {
                        attribute = { type: attribute };
                    } else {
                        if (attribute == null || attribute.type == null) {
                            console.error('需要传入指定绘制的type类型！');
                            return;
                        }
                    }

                    var type = attribute.type;
                    if (this.drawCtrl[type] == null) {
                        console.error('不能进行type为【' + type + '】的绘制，无该类型！');
                        return;
                    }

                    var drawOkCalback;
                    if (attribute.success) {
                        drawOkCalback = attribute.success;
                        delete attribute.success;
                    }

                    //赋默认值  
                    attribute = DrawUtil.addGeoJsonDefVal(attribute);

                    this.stopDraw();
                    var entity = this.drawCtrl[type].activate(attribute, drawOkCalback);
                    this.bindDeleteContextmenu(entity);
                    return entity;
                },
                //外部控制，完成绘制，比如手机端无法双击结束
                endDraw: function endDraw() {
                    for (var type in this.drawCtrl) {
                        if (this.drawCtrl[type].endDraw) this.drawCtrl[type].endDraw();
                    }
                    return this;
                },
                stopDraw: function stopDraw() {
                    this.stopEditing();
                    for (var type in this.drawCtrl) {
                        this.drawCtrl[type].disable(true);
                    }
                    return this;
                },
                clearDraw: function clearDraw() {
                    //删除所有
                    this.stopDraw();
                    this.dataSource.entities.removeAll();
                    this.primitives.removeAll();

                    return this;
                },
                //==========编辑相关==========
                currEditFeature: null, //当前编辑的要素  
                getCurrentEntity: function getCurrentEntity() {
                    return this.currEditFeature;
                },
                _hasEdit: null,
                hasEdit: function hasEdit(val) {
                    if (this._hasEdit !== null && this._hasEdit === val) return;

                    this._hasEdit = val;
                    if (val) {
                        this.bindSelectEvent();
                    } else {
                        this.stopEditing();
                        this.destroySelectEvent();
                    }
                },
                //绑定鼠标选中事件
                bindSelectEvent: function bindSelectEvent() {
                    var _this = this;

                    //选取对象
                    var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
                    handler.setInputAction(function (event) {
                        var pickedObject = _this.viewer.scene.pick(event.position, 5, 5);
                        if (Cesium.defined(pickedObject)) {
                            var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                            if (entity && _this.isMyEntity(entity)) {
                                if (_this.currEditFeature && _this.currEditFeature === entity) return; //重复单击了跳出

                                if (!Cesium.defaultValue(entity.inProgress, false)) {
                                    _this.startEditing(entity);
                                    return;
                                }
                            }
                        }
                        _this.stopEditing();
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                    //编辑提示事件
                    handler.setInputAction(function (event) {
                        if (!_this._hasEdit) return;

                        _this.tooltip.setVisible(false);

                        var pickedObject = _this.viewer.scene.pick(event.endPosition, 5, 5);
                        if (Cesium.defined(pickedObject)) {
                            var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                            if (entity && entity.editing && !Cesium.defaultValue(entity.inProgress, false) && _this.isMyEntity(entity)) {
                                var tooltip = _this.tooltip;
                                clearTimeout(_this.tiptimeTik);
                                _this.tiptimeTik = setTimeout(function () {
                                    //edit中的MOUSE_MOVE会关闭提示，延迟执行。
                                    tooltip.showAt(event.endPosition, _Tooltip.message.edit.start);
                                }, 100);
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    this.selectHandler = handler;
                },
                destroySelectEvent: function destroySelectEvent() {
                    this.selectHandler && this.selectHandler.destroy();
                    this.selectHandler = undefined;
                },
                startEditing: function startEditing(entity) {
                    this.stopEditing();
                    if (entity == null || !this._hasEdit) return;

                    if (entity.editing && entity.editing.activate) {
                        entity.editing.activate();
                    }
                    this.currEditFeature = entity;
                },
                stopEditing: function stopEditing() {
                    this.tooltip.setVisible(false);
                    if (this.currEditFeature && this.currEditFeature.editing && this.currEditFeature.editing.disable) {
                        this.currEditFeature.editing.disable();
                    }
                    this.currEditFeature = null;
                },
                //修改了属性
                updateAttribute: function updateAttribute(attribute, entity) {
                    if (entity == null) entity = this.currEditFeature;
                    if (entity == null || attribute == null) return;

                    attribute.style = attribute.style || {};
                    attribute.attr = attribute.attr || {};

                    //更新属性
                    var type = entity.attribute.type;
                    this.drawCtrl[type].style2Entity(attribute.style, entity);
                    entity.attribute = attribute;

                    //如果在编辑状态，更新绑定的拖拽点
                    if (entity.editing) {
                        if (entity.editing.updateAttrForEditing) entity.editing.updateAttrForEditing();

                        if (entity.editing.updateDraggers) entity.editing.updateDraggers();
                    }

                    //名称 绑定到tooltip 
                    if (this.options.nameTooltip) {
                        var that = this;
                        if (entity.attribute.attr && entity.attribute.attr.name) {
                            entity.tooltip = {
                                html: entity.attribute.attr.name,
                                check: function check() {
                                    return !that._hasEdit;
                                }
                            };
                        } else {
                            entity.tooltip = null;
                        }
                    }
                    return entity;
                },
                //修改坐标、高程
                setPositions: function setPositions(positions, entity) {
                    if (entity == null) entity = this.currEditFeature;
                    if (entity == null || positions == null) return;

                    //如果在编辑状态，更新绑定的拖拽点
                    if (entity.editing) {
                        entity.editing.setPositions(positions);
                        entity.editing.updateDraggers();
                    }
                    return entity;
                },
                //==========删除相关========== 
                //右键菜单
                bindDeleteContextmenu: function bindDeleteContextmenu(entity) {
                    var that = this;
                    entity.contextmenuItems = entity.contextmenuItems || [];
                    entity.contextmenuItems.push({
                        text: '删除对象',
                        iconCls: 'fa fa-trash-o',
                        visible: function visible(e) {
                            that.tooltip.setVisible(false);
                            clearTimeout(that.tiptimeTik);

                            if (Cesium.defined(that.options.hasDel)) return that._hasEdit && that.options.hasDel(e); else return that._hasEdit;
                        },
                        calback: function calback(e) {
                            var entity = e.target;

                            if (entity.editing && entity.editing.disable) {
                                entity.editing.disable();
                            }
                            that.deleteEntity(entity);
                        }
                    });
                },
                //删除单个
                deleteEntity: function deleteEntity(entity) {
                    if (entity == null) entity = this.currEditFeature;
                    if (entity == null) return;

                    if (entity.editing) {
                        entity.editing.disable();
                    }

                    if (this.dataSource.entities.contains(entity)) this.dataSource.entities.remove(entity);

                    if (this.primitives.contains(entity)) this.primitives.remove(entity);

                    this.fire(EventType.Delete, { entity: entity });
                },
                remove: function remove(entity) {
                    //兼容不同习惯命名
                    return this.deleteEntity(entity);
                },
                //是否为当前编辑器编辑的标号
                isMyEntity: function isMyEntity(entity) {
                    if (this.dataSource.entities.contains(entity)) return true;
                    if (this.primitives.contains(entity)) return true;
                    return false;
                },
                //删除所有
                deleteAll: function deleteAll() {
                    //兼容不同习惯命名
                    this.clearDraw();
                },
                removeAll: function removeAll() {
                    //兼容不同习惯命名
                    this.clearDraw();
                },
                //==========转换GeoJSON==========
                //转换当前所有为geojson
                toGeoJSON: function toGeoJSON(entity) {
                    this.stopDraw();

                    if (entity == null) {
                        //全部数据 
                        var arrEntity = this.getEntitys();
                        if (arrEntity.length == 0) return null;

                        var features = [];
                        for (var i = 0, len = arrEntity.length; i < len; i++) {
                            var entity = arrEntity[i];
                            if (entity.attribute == null || entity.attribute.type == null) continue;

                            var type = entity.attribute.type;
                            var geojson = this.drawCtrl[type].toGeoJSON(entity);
                            if (geojson == null) continue;
                            geojson = DrawUtil.removeGeoJsonDefVal(geojson);

                            features.push(geojson);
                        }
                        if (features.length > 0) return { type: "FeatureCollection", features: features }; else return null;
                    } else {
                        var type = entity.attribute.type;
                        var geojson = this.drawCtrl[type].toGeoJSON(entity);
                        geojson = DrawUtil.removeGeoJsonDefVal(geojson);
                        return geojson;
                    }
                },
                //加载goejson数据
                jsonToEntity: function jsonToEntity(json, isClear, isFly) {
                    //兼容旧版本方法名
                    return this.loadJson(json, {
                        clear: isClear,
                        flyTo: isFly
                    });
                },
                loadJson: function loadJson(json, opts) {
                    opts = opts || {};

                    var jsonObjs = json;
                    try {
                        if (util.isString(json)) jsonObjs = JSON.parse(json);
                    } catch (e) {
                        util.alert(e.name + ": " + e.message + " \n请确认json文件格式正确!!!");
                        return;
                    }

                    if (opts.clear) {
                        this.clearDraw();
                    }

                    var arrthis = [];
                    var jsonFeatures = jsonObjs.features ? jsonObjs.features : [jsonObjs];

                    for (var i = 0, len = jsonFeatures.length; i < len; i++) {
                        var feature = jsonFeatures[i];

                        if (!feature.properties || !feature.properties.type) {
                            //非本身保存的外部其他geojson数据
                            feature.properties = feature.properties || {};
                            switch (feature.geometry.type) {
                                case "MultiPolygon":
                                case "Polygon":
                                    feature.properties.type = "polygon";
                                    break;
                                case "MultiLineString":
                                case "LineString":
                                    feature.properties.type = "polyline";
                                    break;
                                case "MultiPoint":
                                case "Point":
                                    feature.properties.type = "point";
                                    break;
                            }
                        }
                        feature.properties.style = opts.style || feature.properties.style || {};

                        if (opts.onEachFeature) //添加到地图前 回调方法
                            opts.onEachFeature(feature, feature.properties.type, i);

                        var type = feature.properties.type;
                        if (this.drawCtrl[type] == null) {
                            console.log('数据无法识别或者数据的[' + type + ']类型参数有误');
                            continue;
                        }

                        var entity = this.addFeature(type, feature);

                        if (opts.onEachEntity) //添加到地图后回调方法
                            opts.onEachEntity(feature, entity, i);

                        arrthis.push(entity);
                    }

                    if (opts.flyTo) {
                        this.viewer.mapv.flyTo(arrthis);
                    }

                    return arrthis;
                },
                //外部添加数据（内部使用的）
                addFeature: function addFeature(type, feature) {
                    feature.properties.style = feature.properties.style || {};

                    //赋默认值  
                    feature.properties = DrawUtil.addGeoJsonDefVal(feature.properties);

                    var entity = this.drawCtrl[type].jsonToEntity(feature);
                    this.bindDeleteContextmenu(entity);

                    //名称 绑定到tooltip
                    if (this.options.nameTooltip) {
                        if (entity.attribute.attr && entity.attribute.attr.name) {
                            var that = this;
                            entity.tooltip = {
                                html: entity.attribute.attr.name,
                                check: function check() {
                                    return !that._hasEdit;
                                }
                            };
                        } else {
                            entity.tooltip = null;
                        }
                    }

                    return entity;
                },
                //外部添加billboard点数据
                addPoint: function addPoint(point, style) {
                    var type = 'billboard';

                    var feature = {
                        type: "Feature",
                        properties: { style: style },
                        geometry: { type: "Point", coordinates: point }
                    };

                    var entity = this.addFeature(type, feature);
                    return entity;
                },
                //外部添加线数据
                addPolyline: function addPolyline(coordinates, style) {
                    var type = 'polyline';

                    var feature = {
                        type: "Feature",
                        properties: { style: style },
                        geometry: {
                            type: "LineString",
                            coordinates: coordinates
                        }
                    };

                    var entity = this.addFeature(type, feature);
                    return entity;
                },
                //外部添加面数据
                addPolygon: function addPolygon(coordinates, style) {
                    var type = 'polygon';

                    var feature = {
                        type: "Feature",
                        properties: { style: style },
                        geometry: {
                            type: "Polygon",
                            coordinates: [coordinates]
                        }
                    };

                    var entity = this.addFeature(type, feature);
                    return entity;
                },

                //属性转entity
                attributeToEntity: function attributeToEntity(attribute, positions) {
                    return this.drawCtrl[attribute.type].attributeToEntity(attribute, positions);
                },
                //绑定外部非Draw产生的entity到标绘
                bindExtraEntity: function bindExtraEntity(entity, attribute) {
                    attribute = attribute || {};
                    attribute.type = attribute.type || (0, _index.getTypeName)(entity);
                    attribute.style = attribute.style || {};
                    // attribute = DrawUtil.addGeoJsonDefVal(attribute);

                    var entity = this.drawCtrl[attribute.type].bindExtraEntity(entity, attribute);
                    this.bindDeleteContextmenu(entity);

                    entity.entityCollection.remove(entity); //从原有的集合中删除 
                    this.dataSource.entities.add(entity); //加入到draw集合图层中
                },
                //==========对外接口==========
                _visible: true,
                setVisible: function setVisible(visible) {
                    this._visible = visible;
                    if (!visible) {
                        this.stopDraw();
                    }

                    this.dataSource.show = visible;
                    this.primitives.show = visible;
                },
                //是否存在绘制
                hasDraw: function hasDraw() {
                    return this.getEntitys().length > 0;
                },
                //获取所有绘制的实体对象列表
                getEntitys: function getEntitys() {
                    this.stopDraw();

                    var arr = this.dataSource.entities.values;
                    arr = arr.concat(this.primitives._primitives);
                    return arr;
                },
                getDataSource: function getDataSource() {
                    return this.dataSource;
                },
                getEntityById: function getEntityById(id) {
                    var arrEntity = this.getEntitys();
                    for (var i = 0, len = arrEntity.length; i < len; i++) {
                        var entity = arrEntity[i];
                        if (id == entity.attribute.attr.id) {
                            return entity;
                        }
                    }
                    return null;
                },
                //获取实体的经纬度值 坐标数组
                getCoordinates: function getCoordinates(entity) {
                    var type = entity.attribute.type;
                    var coor = this.drawCtrl[type].getCoordinates(entity);
                    return coor;
                },
                //获取实体的坐标数组
                getPositions: function getPositions(entity) {
                    var type = entity.attribute.type;
                    var positions = this.drawCtrl[type].getPositions(entity);
                    return positions;
                },

                flyTo: function flyTo(entity, opts) {
                    this.viewer.mapv.flyTo(entity, opts);
                },

                destroy: function destroy() {
                    this.stopDraw();
                    this.hasEdit(false);
                    this.clearDraw();
                    if (this.viewer.dataSources.contains(this.dataSource)) this.viewer.dataSources.remove(this.dataSource, true);

                    if (this.viewer.scene.primitives.contains(this.dataSource)) this.viewer.scene.primitives.remove(this.primitives);
                }
            });

            //绑定到draw，方便外部使用
            Draw.Base = _Draw.DrawBase;
            Draw.Billboard = _Draw3.DrawBillboard;
            Draw.Circle = _Draw12.DrawCircle;
            Draw.Cylinder = _Draw13.DrawCylinder;
            Draw.Corridor = _Draw9.DrawCorridor;
            Draw.Curve = _Draw7.DrawCurve;
            Draw.Ellipsoid = _Draw14.DrawEllipsoid;
            Draw.Label = _Draw4.DrawLabel;
            Draw.Model = _Draw5.DrawModel;
            Draw.Point = _Draw2.DrawPoint;
            Draw.Polygon = _Draw10.DrawPolygon;
            Draw.Polyline = _Draw6.DrawPolyline;
            Draw.PolylineVolume = _Draw8.DrawPolylineVolume;
            Draw.Rectangle = _Draw11.DrawRectangle;
            Draw.Wall = _Draw15.DrawWall;

            Draw.PModel = _DrawP.DrawPModel;

            Draw.PolygonEx = _Draw18.DrawPolygonEx;

            /***/
}),
/* 5 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.message = undefined;
            exports.Tooltip = Tooltip;

            var _zepto = __webpack_require__(6);

            //样式文件在map.css
            var message = exports.message = {
                draw: {
                    point: {
                        start: '单击 完成绘制'
                    },
                    polyline: { //线面
                        start: '单击 开始绘制',
                        cont: '单击增加点，右击删除点',
                        end: '单击增加点，右击删除点<br/>双击完成绘制',
                        end2: '单击完成绘制'
                    }
                },
                edit: {
                    start: '单击后 激活编辑<br/>右击 单击菜单删除',
                    end: '释放后 完成修改'
                },
                dragger: {
                    def: '拖动该点后<br/>修改位置 ', //默认  
                    moveAll: '拖动该点后<br/>整体平移',
                    addMidPoint: '拖动该点后<br/>增加点',
                    moveHeight: '拖动该点后<br/>修改高度',
                    editRadius: '拖动该点后<br/>修改半径',
                    editHeading: '拖动该点后<br/>修改方向',
                    editScale: '拖动该点后<br/>修改缩放比例'
                },
                del: {
                    def: '<br/>右击 删除该点',
                    min: '无法删除，点数量不能少于'
                }
            };

            function Tooltip(frameDiv) {
                var div = document.createElement('DIV');
                div.className = "mapv3d-draw-tooltip right";

                var arrow = document.createElement('DIV');
                arrow.className = "mapv3d-draw-tooltip-arrow";
                div.appendChild(arrow);

                var title = document.createElement('DIV');
                title.className = "mapv3d-draw-tooltip-inner";
                div.appendChild(title);

                this._div = div;
                this._title = title;

                // add to frame div and display coordinates
                frameDiv.appendChild(div);

                //鼠标的移入
                (0, _zepto.zepto)(".mapv3d-draw-tooltip").mouseover(function () {
                    (0, _zepto.zepto)(this).hide();
                });
            }

            Tooltip.prototype.setVisible = function (visible) {
                this._div.style.display = visible ? 'block' : 'none';
            };

            Tooltip.prototype.showAt = function (position, message) {
                if (position && message) {
                    this.setVisible(true);

                    this._title.innerHTML = message;
                    this._div.style.top = position.y - this._div.clientHeight / 2 + "px";

                    //left css时
                    //this._div.style.left = (position.x - this._div.clientWidth - 30) + "px"; 

                    //right css时
                    this._div.style.left = position.x + 30 + "px";
                } else {
                    this.setVisible(false);
                }
            };

            /***/
}),
/* 6 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            /* zepto v1.2.0 - 替代jquery的库 */

            //目前主要用到：DOM的操作和事件、ajax请求。
            var zepto = exports.zepto = function () {
                var undefined,
                    key,
                    $,
                    classList,
                    emptyArray = [],
                    _concat = emptyArray.concat,
                    _filter = emptyArray.filter,
                    _slice = emptyArray.slice,
                    document = window.document,
                    elementDisplay = {},
                    classCache = {},
                    cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1, 'opacity': 1, 'z-index': 1, 'zoom': 1 },
                    fragmentRE = /^\s*<(\w+|!)[^>]*>/,
                    singleTagRE = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
                    tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
                    rootNodeRE = /^(?:body|html)$/i,
                    capitalRE = /([A-Z])/g,


                    // special attributes that should be get/set via method calls
                    methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],
                    adjacencyOperators = ['after', 'prepend', 'before', 'append'],
                    table = document.createElement('table'),
                    tableRow = document.createElement('tr'),
                    containers = {
                        'tr': document.createElement('tbody'),
                        'tbody': table, 'thead': table, 'tfoot': table,
                        'td': tableRow, 'th': tableRow,
                        '*': document.createElement('div')
                    },
                    readyRE = /complete|loaded|interactive/,
                    simpleSelectorRE = /^[\w-]*$/,
                    class2type = {},
                    toString = class2type.toString,
                    zepto = {},
                    camelize,
                    uniq,
                    tempParent = document.createElement('div'),
                    propMap = {
                        'tabindex': 'tabIndex',
                        'readonly': 'readOnly',
                        'for': 'htmlFor',
                        'class': 'className',
                        'maxlength': 'maxLength',
                        'cellspacing': 'cellSpacing',
                        'cellpadding': 'cellPadding',
                        'rowspan': 'rowSpan',
                        'colspan': 'colSpan',
                        'usemap': 'useMap',
                        'frameborder': 'frameBorder',
                        'contenteditable': 'contentEditable'
                    },
                    isArray = Array.isArray || function (object) {
                        return object instanceof Array;
                    };

                zepto.matches = function (element, selector) {
                    if (!selector || !element || element.nodeType !== 1) return false;
                    var matchesSelector = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;
                    if (matchesSelector) return matchesSelector.call(element, selector);
                    // fall back to performing a selector:
                    var match,
                        parent = element.parentNode,
                        temp = !parent;
                    if (temp) (parent = tempParent).appendChild(element);
                    match = ~zepto.qsa(parent, selector).indexOf(element);
                    temp && tempParent.removeChild(element);
                    return match;
                };

                function type(obj) {
                    return obj == null ? String(obj) : class2type[toString.call(obj)] || "object";
                }

                function isFunction(value) {
                    return type(value) == "function";
                }
                function isWindow(obj) {
                    return obj != null && obj == obj.window;
                }
                function isDocument(obj) {
                    return obj != null && obj.nodeType == obj.DOCUMENT_NODE;
                }
                function isObject(obj) {
                    return type(obj) == "object";
                }
                function isPlainObject(obj) {
                    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;
                }

                function likeArray(obj) {
                    var length = !!obj && 'length' in obj && obj.length,
                        type = $.type(obj);

                    return 'function' != type && !isWindow(obj) && ('array' == type || length === 0 || typeof length == 'number' && length > 0 && length - 1 in obj);
                }

                function compact(array) {
                    return _filter.call(array, function (item) {
                        return item != null;
                    });
                }
                function flatten(array) {
                    return array.length > 0 ? $.fn.concat.apply([], array) : array;
                }
                camelize = function camelize(str) {
                    return str.replace(/-+(.)?/g, function (match, chr) {
                        return chr ? chr.toUpperCase() : '';
                    });
                };
                function dasherize(str) {
                    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();
                }
                uniq = function uniq(array) {
                    return _filter.call(array, function (item, idx) {
                        return array.indexOf(item) == idx;
                    });
                };

                function classRE(name) {
                    return name in classCache ? classCache[name] : classCache[name] = new RegExp('(^|\\s)' + name + '(\\s|$)');
                }

                function maybeAddPx(name, value) {
                    return typeof value == "number" && !cssNumber[dasherize(name)] ? value + "px" : value;
                }

                function defaultDisplay(nodeName) {
                    var element, display;
                    if (!elementDisplay[nodeName]) {
                        element = document.createElement(nodeName);
                        document.body.appendChild(element);
                        display = getComputedStyle(element, '').getPropertyValue("display");
                        element.parentNode.removeChild(element);
                        display == "none" && (display = "block");
                        elementDisplay[nodeName] = display;
                    }
                    return elementDisplay[nodeName];
                }

                function _children(element) {
                    return 'children' in element ? _slice.call(element.children) : $.map(element.childNodes, function (node) {
                        if (node.nodeType == 1) return node;
                    });
                }

                function Z(dom, selector) {
                    var i,
                        len = dom ? dom.length : 0;
                    for (i = 0; i < len; i++) {
                        this[i] = dom[i];
                    } this.length = len;
                    this.selector = selector || '';
                }

                // `$.zepto.fragment` takes a html string and an optional tag name
                // to generate DOM nodes from the given html string.
                // The generated DOM nodes are returned as an array.
                // This function can be overridden in plugins for example to make
                // it compatible with browsers that don't support the DOM fully.
                zepto.fragment = function (html, name, properties) {
                    var dom, nodes, container;

                    // A special case optimization for a single tag
                    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));

                    if (!dom) {
                        if (html.replace) html = html.replace(tagExpanderRE, "<$1></$2>");
                        if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;
                        if (!(name in containers)) name = '*';

                        container = containers[name];
                        container.innerHTML = '' + html;
                        dom = $.each(_slice.call(container.childNodes), function () {
                            container.removeChild(this);
                        });
                    }

                    if (isPlainObject(properties)) {
                        nodes = $(dom);
                        $.each(properties, function (key, value) {
                            if (methodAttributes.indexOf(key) > -1) nodes[key](value); else nodes.attr(key, value);
                        });
                    }

                    return dom;
                };

                // `$.zepto.Z` swaps out the prototype of the given `dom` array
                // of nodes with `$.fn` and thus supplying all the zepto functions
                // to the array. This method can be overridden in plugins.
                zepto.Z = function (dom, selector) {
                    return new Z(dom, selector);
                };

                // `$.zepto.isZ` should return `true` if the given object is a zepto
                // collection. This method can be overridden in plugins.
                zepto.isZ = function (object) {
                    return object instanceof zepto.Z;
                };

                // `$.zepto.init` is zepto's counterpart to jQuery's `$.fn.init` and
                // takes a CSS selector and an optional context (and handles various
                // special cases).
                // This method can be overridden in plugins.
                zepto.init = function (selector, context) {
                    var dom;
                    // If nothing given, return an empty zepto collection
                    if (!selector) return zepto.Z();
                    // Optimize for string selectors
                    else if (typeof selector == 'string') {
                        selector = selector.trim();
                        // If it's a html fragment, create nodes from it
                        // Note: In both Chrome 21 and Firefox 15, DOM error 12
                        // is thrown if the fragment doesn't begin with <
                        if (selector[0] == '<' && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null;
                        // If there's a context, create a collection on that context first, and select
                        // nodes from there
                        else if (context !== undefined) return $(context).find(selector);
                        // If it's a CSS selector, use it to select nodes.
                        else dom = zepto.qsa(document, selector);
                    }
                    // If a function is given, call it when the DOM is ready
                    else if (isFunction(selector)) return $(document).ready(selector);
                    // If a zepto collection is given, just return it
                    else if (zepto.isZ(selector)) return selector; else {
                        // normalize array if an array of nodes is given
                        if (isArray(selector)) dom = compact(selector);
                        // Wrap DOM nodes.
                        else if (isObject(selector)) dom = [selector], selector = null;
                        // If it's a html fragment, create nodes from it
                        else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null;
                        // If there's a context, create a collection on that context first, and select
                        // nodes from there
                        else if (context !== undefined) return $(context).find(selector);
                        // And last but no least, if it's a CSS selector, use it to select nodes.
                        else dom = zepto.qsa(document, selector);
                    }
                    // create a new zepto collection from the nodes found
                    return zepto.Z(dom, selector);
                };

                // `$` will be the base `zepto` object. When calling this
                // function just call `$.zepto.init, which makes the implementation
                // details of selecting nodes and creating zepto collections
                // patchable in plugins.
                $ = function $(selector, context) {
                    return zepto.init(selector, context);
                };

                function extend(target, source, deep) {
                    for (key in source) {
                        if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {
                            if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};
                            if (isArray(source[key]) && !isArray(target[key])) target[key] = [];
                            extend(target[key], source[key], deep);
                        } else if (source[key] !== undefined) target[key] = source[key];
                    }
                }

                // Copy all but undefined properties from one or more
                // objects to the `target` object.
                $.extend = function (target) {
                    var deep,
                        args = _slice.call(arguments, 1);
                    if (typeof target == 'boolean') {
                        deep = target;
                        target = args.shift();
                    }
                    args.forEach(function (arg) {
                        extend(target, arg, deep);
                    });
                    return target;
                };

                // `$.zepto.qsa` is zepto's CSS selector implementation which
                // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.
                // This method can be overridden in plugins.
                zepto.qsa = function (element, selector) {
                    var found,
                        maybeID = selector[0] == '#',
                        maybeClass = !maybeID && selector[0] == '.',
                        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,
                        // Ensure that a 1 char tag name still gets checked
                        isSimple = simpleSelectorRE.test(nameOnly);
                    return element.getElementById && isSimple && maybeID ? // Safari DocumentFragment doesn't have getElementById
                        (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 && element.nodeType !== 9 && element.nodeType !== 11 ? [] : _slice.call(isSimple && !maybeID && element.getElementsByClassName ? // DocumentFragment doesn't have getElementsByClassName/TagName
                            maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class
                                element.getElementsByTagName(selector) : // Or a tag
                            element.querySelectorAll(selector) // Or it's not simple, and we need to query all
                        );
                };

                function filtered(nodes, selector) {
                    return selector == null ? $(nodes) : $(nodes).filter(selector);
                }

                $.contains = document.documentElement.contains ? function (parent, node) {
                    return parent !== node && parent.contains(node);
                } : function (parent, node) {
                    while (node && (node = node.parentNode)) {
                        if (node === parent) return true;
                    } return false;
                };

                function funcArg(context, arg, idx, payload) {
                    return isFunction(arg) ? arg.call(context, idx, payload) : arg;
                }

                function setAttribute(node, name, value) {
                    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);
                }

                // access className property while respecting SVGAnimatedString
                function className(node, value) {
                    var klass = node.className || '',
                        svg = klass && klass.baseVal !== undefined;

                    if (value === undefined) return svg ? klass.baseVal : klass;
                    svg ? klass.baseVal = value : node.className = value;
                }

                // "true"  => true
                // "false" => false
                // "null"  => null
                // "42"    => 42
                // "42.5"  => 42.5
                // "08"    => "08"
                // JSON    => parse if valid
                // String  => self
                function deserializeValue(value) {
                    try {
                        return value ? value == "true" || (value == "false" ? false : value == "null" ? null : +value + "" == value ? +value : /^[\[\{]/.test(value) ? $.parseJSON(value) : value) : value;
                    } catch (e) {
                        return value;
                    }
                }

                $.type = type;
                $.isFunction = isFunction;
                $.isWindow = isWindow;
                $.isArray = isArray;
                $.isPlainObject = isPlainObject;

                $.isEmptyObject = function (obj) {
                    var name;
                    for (name in obj) {
                        return false;
                    } return true;
                };

                $.isNumeric = function (val) {
                    var num = Number(val),
                        type = typeof val === 'undefined' ? 'undefined' : _typeof(val);
                    return val != null && type != 'boolean' && (type != 'string' || val.length) && !isNaN(num) && isFinite(num) || false;
                };

                $.inArray = function (elem, array, i) {
                    return emptyArray.indexOf.call(array, elem, i);
                };

                $.camelCase = camelize;
                $.trim = function (str) {
                    return str == null ? "" : String.prototype.trim.call(str);
                };

                // plugin compatibility
                $.uuid = 0;
                $.support = {};
                $.expr = {};
                $.noop = function () { };

                $.map = function (elements, callback) {
                    var value,
                        values = [],
                        i,
                        key;
                    if (likeArray(elements)) for (i = 0; i < elements.length; i++) {
                        value = callback(elements[i], i);
                        if (value != null) values.push(value);
                    } else for (key in elements) {
                        value = callback(elements[key], key);
                        if (value != null) values.push(value);
                    }
                    return flatten(values);
                };

                $.each = function (elements, callback) {
                    var i, key;
                    if (likeArray(elements)) {
                        for (i = 0; i < elements.length; i++) {
                            if (callback.call(elements[i], i, elements[i]) === false) return elements;
                        }
                    } else {
                        for (key in elements) {
                            if (callback.call(elements[key], key, elements[key]) === false) return elements;
                        }
                    }

                    return elements;
                };

                $.grep = function (elements, callback) {
                    return _filter.call(elements, callback);
                };

                if (window.JSON) $.parseJSON = JSON.parse;

                // Populate the class2type map
                $.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function (i, name) {
                    class2type["[object " + name + "]"] = name.toLowerCase();
                });

                // Define methods that will be available on all
                // zepto collections
                $.fn = {
                    constructor: zepto.Z,
                    length: 0,

                    // Because a collection acts like an array
                    // copy over these useful array functions.
                    forEach: emptyArray.forEach,
                    reduce: emptyArray.reduce,
                    push: emptyArray.push,
                    sort: emptyArray.sort,
                    splice: emptyArray.splice,
                    indexOf: emptyArray.indexOf,
                    concat: function concat() {
                        var i,
                            value,
                            args = [];
                        for (i = 0; i < arguments.length; i++) {
                            value = arguments[i];
                            args[i] = zepto.isZ(value) ? value.toArray() : value;
                        }
                        return _concat.apply(zepto.isZ(this) ? this.toArray() : this, args);
                    },

                    // `map` and `slice` in the jQuery API work differently
                    // from their array counterparts
                    map: function map(fn) {
                        return $($.map(this, function (el, i) {
                            return fn.call(el, i, el);
                        }));
                    },
                    slice: function slice() {
                        return $(_slice.apply(this, arguments));
                    },

                    ready: function ready(callback) {
                        // need to check if document.body exists for IE as that browser reports
                        // document ready when it hasn't yet created the body element
                        if (readyRE.test(document.readyState) && document.body) callback($); else document.addEventListener('DOMContentLoaded', function () {
                            callback($);
                        }, false);
                        return this;
                    },
                    get: function get(idx) {
                        return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];
                    },
                    toArray: function toArray() {
                        return this.get();
                    },
                    size: function size() {
                        return this.length;
                    },
                    remove: function remove() {
                        return this.each(function () {
                            if (this.parentNode != null) this.parentNode.removeChild(this);
                        });
                    },
                    each: function each(callback) {
                        emptyArray.every.call(this, function (el, idx) {
                            return callback.call(el, idx, el) !== false;
                        });
                        return this;
                    },
                    filter: function filter(selector) {
                        if (isFunction(selector)) return this.not(this.not(selector));
                        return $(_filter.call(this, function (element) {
                            return zepto.matches(element, selector);
                        }));
                    },
                    add: function add(selector, context) {
                        return $(uniq(this.concat($(selector, context))));
                    },
                    is: function is(selector) {
                        return this.length > 0 && zepto.matches(this[0], selector);
                    },
                    not: function not(selector) {
                        var nodes = [];
                        if (isFunction(selector) && selector.call !== undefined) this.each(function (idx) {
                            if (!selector.call(this, idx)) nodes.push(this);
                        }); else {
                            var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);
                            this.forEach(function (el) {
                                if (excludes.indexOf(el) < 0) nodes.push(el);
                            });
                        }
                        return $(nodes);
                    },
                    has: function has(selector) {
                        return this.filter(function () {
                            return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();
                        });
                    },
                    eq: function eq(idx) {
                        return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);
                    },
                    first: function first() {
                        var el = this[0];
                        return el && !isObject(el) ? el : $(el);
                    },
                    last: function last() {
                        var el = this[this.length - 1];
                        return el && !isObject(el) ? el : $(el);
                    },
                    find: function find(selector) {
                        var result,
                            $this = this;
                        if (!selector) result = $(); else if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object') result = $(selector).filter(function () {
                            var node = this;
                            return emptyArray.some.call($this, function (parent) {
                                return $.contains(parent, node);
                            });
                        }); else if (this.length == 1) result = $(zepto.qsa(this[0], selector)); else result = this.map(function () {
                            return zepto.qsa(this, selector);
                        });
                        return result;
                    },
                    closest: function closest(selector, context) {
                        var nodes = [],
                            collection = (typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object' && $(selector);
                        this.each(function (_, node) {
                            while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) {
                                node = node !== context && !isDocument(node) && node.parentNode;
                            } if (node && nodes.indexOf(node) < 0) nodes.push(node);
                        });
                        return $(nodes);
                    },
                    parents: function parents(selector) {
                        var ancestors = [],
                            nodes = this;
                        while (nodes.length > 0) {
                            nodes = $.map(nodes, function (node) {
                                if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {
                                    ancestors.push(node);
                                    return node;
                                }
                            });
                        } return filtered(ancestors, selector);
                    },
                    parent: function parent(selector) {
                        return filtered(uniq(this.pluck('parentNode')), selector);
                    },
                    children: function children(selector) {
                        return filtered(this.map(function () {
                            return _children(this);
                        }), selector);
                    },
                    contents: function contents() {
                        return this.map(function () {
                            return this.contentDocument || _slice.call(this.childNodes);
                        });
                    },
                    siblings: function siblings(selector) {
                        return filtered(this.map(function (i, el) {
                            return _filter.call(_children(el.parentNode), function (child) {
                                return child !== el;
                            });
                        }), selector);
                    },
                    empty: function empty() {
                        return this.each(function () {
                            this.innerHTML = '';
                        });
                    },
                    // `pluck` is borrowed from Prototype.js
                    pluck: function pluck(property) {
                        return $.map(this, function (el) {
                            return el[property];
                        });
                    },
                    show: function show() {
                        return this.each(function () {
                            this.style.display == "none" && (this.style.display = '');
                            if (getComputedStyle(this, '').getPropertyValue("display") == "none") this.style.display = defaultDisplay(this.nodeName);
                        });
                    },
                    replaceWith: function replaceWith(newContent) {
                        return this.before(newContent).remove();
                    },
                    wrap: function wrap(structure) {
                        var func = isFunction(structure);
                        if (this[0] && !func) var dom = $(structure).get(0),
                            clone = dom.parentNode || this.length > 1;

                        return this.each(function (index) {
                            $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);
                        });
                    },
                    wrapAll: function wrapAll(structure) {
                        if (this[0]) {
                            $(this[0]).before(structure = $(structure));
                            var children;
                            // drill down to the inmost element
                            while ((children = structure.children()).length) {
                                structure = children.first();
                            } $(structure).append(this);
                        }
                        return this;
                    },
                    wrapInner: function wrapInner(structure) {
                        var func = isFunction(structure);
                        return this.each(function (index) {
                            var self = $(this),
                                contents = self.contents(),
                                dom = func ? structure.call(this, index) : structure;
                            contents.length ? contents.wrapAll(dom) : self.append(dom);
                        });
                    },
                    unwrap: function unwrap() {
                        this.parent().each(function () {
                            $(this).replaceWith($(this).children());
                        });
                        return this;
                    },
                    clone: function clone() {
                        return this.map(function () {
                            return this.cloneNode(true);
                        });
                    },
                    hide: function hide() {
                        return this.css("display", "none");
                    },
                    toggle: function toggle(setting) {
                        return this.each(function () {
                            var el = $(this); (setting === undefined ? el.css("display") == "none" : setting) ? el.show() : el.hide();
                        });
                    },
                    prev: function prev(selector) {
                        return $(this.pluck('previousElementSibling')).filter(selector || '*');
                    },
                    next: function next(selector) {
                        return $(this.pluck('nextElementSibling')).filter(selector || '*');
                    },
                    html: function html(_html) {
                        return 0 in arguments ? this.each(function (idx) {
                            var originHtml = this.innerHTML;
                            $(this).empty().append(funcArg(this, _html, idx, originHtml));
                        }) : 0 in this ? this[0].innerHTML : null;
                    },
                    text: function text(_text) {
                        return 0 in arguments ? this.each(function (idx) {
                            var newText = funcArg(this, _text, idx, this.textContent);
                            this.textContent = newText == null ? '' : '' + newText;
                        }) : 0 in this ? this.pluck('textContent').join("") : null;
                    },
                    attr: function attr(name, value) {
                        var result;
                        return typeof name == 'string' && !(1 in arguments) ? 0 in this && this[0].nodeType == 1 && (result = this[0].getAttribute(name)) != null ? result : undefined : this.each(function (idx) {
                            if (this.nodeType !== 1) return;
                            if (isObject(name)) for (key in name) {
                                setAttribute(this, key, name[key]);
                            } else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));
                        });
                    },
                    removeAttr: function removeAttr(name) {
                        return this.each(function () {
                            this.nodeType === 1 && name.split(' ').forEach(function (attribute) {
                                setAttribute(this, attribute);
                            }, this);
                        });
                    },
                    prop: function prop(name, value) {
                        name = propMap[name] || name;
                        return 1 in arguments ? this.each(function (idx) {
                            this[name] = funcArg(this, value, idx, this[name]);
                        }) : this[0] && this[0][name];
                    },
                    removeProp: function removeProp(name) {
                        name = propMap[name] || name;
                        return this.each(function () {
                            delete this[name];
                        });
                    },
                    data: function data(name, value) {
                        var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase();

                        var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName);

                        return data !== null ? deserializeValue(data) : undefined;
                    },
                    val: function val(value) {
                        if (0 in arguments) {
                            if (value == null) value = "";
                            return this.each(function (idx) {
                                this.value = funcArg(this, value, idx, this.value);
                            });
                        } else {
                            return this[0] && (this[0].multiple ? $(this[0]).find('option').filter(function () {
                                return this.selected;
                            }).pluck('value') : this[0].value);
                        }
                    },
                    offset: function offset(coordinates) {
                        if (coordinates) return this.each(function (index) {
                            var $this = $(this),
                                coords = funcArg(this, coordinates, index, $this.offset()),
                                parentOffset = $this.offsetParent().offset(),
                                props = {
                                    top: coords.top - parentOffset.top,
                                    left: coords.left - parentOffset.left
                                };

                            if ($this.css('position') == 'static') props['position'] = 'relative';
                            $this.css(props);
                        });
                        if (!this.length) return null;
                        if (document.documentElement !== this[0] && !$.contains(document.documentElement, this[0])) return { top: 0, left: 0 };
                        var obj = this[0].getBoundingClientRect();

                        obj.width = this[0].offsetWidth; //wanghao 2020-3-22 add 
                        obj.height = this[0].offsetHeight;

                        return {
                            left: obj.left + window.pageXOffset,
                            top: obj.top + window.pageYOffset,
                            width: Math.round(obj.width),
                            height: Math.round(obj.height)
                        };
                    },
                    css: function css(property, value) {
                        if (arguments.length < 2) {
                            var element = this[0];
                            if (typeof property == 'string') {
                                if (!element) return;
                                return element.style[camelize(property)] || getComputedStyle(element, '').getPropertyValue(property);
                            } else if (isArray(property)) {
                                if (!element) return;
                                var props = {};
                                var computedStyle = getComputedStyle(element, '');
                                $.each(property, function (_, prop) {
                                    props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);
                                });
                                return props;
                            }
                        }

                        var css = '';
                        if (type(property) == 'string') {
                            if (!value && value !== 0) this.each(function () {
                                this.style.removeProperty(dasherize(property));
                            }); else css = dasherize(property) + ":" + maybeAddPx(property, value);
                        } else {
                            for (key in property) {
                                if (!property[key] && property[key] !== 0) this.each(function () {
                                    this.style.removeProperty(dasherize(key));
                                }); else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';
                            }
                        }

                        return this.each(function () {
                            if (!this.style) return;
                            this.style.cssText += ';' + css;
                        });
                    },
                    index: function index(element) {
                        return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);
                    },
                    hasClass: function hasClass(name) {
                        if (!name) return false;
                        return emptyArray.some.call(this, function (el) {
                            return this.test(className(el));
                        }, classRE(name));
                    },
                    addClass: function addClass(name) {
                        if (!name) return this;
                        return this.each(function (idx) {
                            if (!('className' in this)) return;
                            classList = [];
                            var cls = className(this),
                                newName = funcArg(this, name, idx, cls);
                            newName.split(/\s+/g).forEach(function (klass) {
                                if (!$(this).hasClass(klass)) classList.push(klass);
                            }, this);
                            classList.length && className(this, cls + (cls ? " " : "") + classList.join(" "));
                        });
                    },
                    removeClass: function removeClass(name) {
                        return this.each(function (idx) {
                            if (!('className' in this)) return;
                            if (name === undefined) return className(this, '');
                            classList = className(this);
                            funcArg(this, name, idx, classList).split(/\s+/g).forEach(function (klass) {
                                classList = classList.replace(classRE(klass), " ");
                            });
                            className(this, classList.trim());
                        });
                    },
                    toggleClass: function toggleClass(name, when) {
                        if (!name) return this;
                        return this.each(function (idx) {
                            var $this = $(this),
                                names = funcArg(this, name, idx, className(this));
                            names.split(/\s+/g).forEach(function (klass) {
                                (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);
                            });
                        });
                    },
                    scrollTop: function scrollTop(value) {
                        if (!this.length) return;
                        var hasScrollTop = 'scrollTop' in this[0];
                        if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;
                        return this.each(hasScrollTop ? function () {
                            this.scrollTop = value;
                        } : function () {
                            this.scrollTo(this.scrollX, value);
                        });
                    },
                    scrollLeft: function scrollLeft(value) {
                        if (!this.length) return;
                        var hasScrollLeft = 'scrollLeft' in this[0];
                        if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;
                        return this.each(hasScrollLeft ? function () {
                            this.scrollLeft = value;
                        } : function () {
                            this.scrollTo(value, this.scrollY);
                        });
                    },
                    position: function position() {
                        if (!this.length) return;

                        var elem = this[0],

                            // Get *real* offsetParent
                            offsetParent = this.offsetParent(),

                            // Get correct offsets
                            offset = this.offset(),
                            parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

                        // Subtract element margins
                        // note: when an element has margin: auto the offsetLeft and marginLeft
                        // are the same in Safari causing offset.left to incorrectly be 0
                        offset.top -= parseFloat($(elem).css('margin-top')) || 0;
                        offset.left -= parseFloat($(elem).css('margin-left')) || 0;

                        // Add offsetParent borders
                        parentOffset.top += parseFloat($(offsetParent[0]).css('border-top-width')) || 0;
                        parentOffset.left += parseFloat($(offsetParent[0]).css('border-left-width')) || 0;

                        // Subtract the two offsets
                        return {
                            top: offset.top - parentOffset.top,
                            left: offset.left - parentOffset.left
                        };
                    },
                    offsetParent: function offsetParent() {
                        return this.map(function () {
                            var parent = this.offsetParent || document.body;
                            while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css("position") == "static") {
                                parent = parent.offsetParent;
                            } return parent;
                        });
                    }

                    // for now
                }; $.fn.detach = $.fn.remove

                    // Generate the `width` and `height` functions
                    ;['width', 'height'].forEach(function (dimension) {
                        var dimensionProperty = dimension.replace(/./, function (m) {
                            return m[0].toUpperCase();
                        });

                        $.fn[dimension] = function (value) {
                            var offset,
                                el = this[0];
                            if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) && offset[dimension]; else return this.each(function (idx) {
                                el = $(this);
                                el.css(dimension, funcArg(this, value, idx, el[dimension]()));
                            });
                        };
                    });

                function traverseNode(node, fun) {
                    fun(node);
                    for (var i = 0, len = node.childNodes.length; i < len; i++) {
                        traverseNode(node.childNodes[i], fun);
                    }
                }

                // Generate the `after`, `prepend`, `before`, `append`,
                // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.
                adjacencyOperators.forEach(function (operator, operatorIndex) {
                    var inside = operatorIndex % 2; //=> prepend, append

                    $.fn[operator] = function () {
                        // arguments can be nodes, arrays of nodes, zepto objects and HTML strings
                        var argType,
                            nodes = $.map(arguments, function (arg) {
                                var arr = [];
                                argType = type(arg);
                                if (argType == "array") {
                                    arg.forEach(function (el) {
                                        if (el.nodeType !== undefined) return arr.push(el); else if ($.zepto.isZ(el)) return arr = arr.concat(el.get());
                                        arr = arr.concat(zepto.fragment(el));
                                    });
                                    return arr;
                                }
                                return argType == "object" || arg == null ? arg : zepto.fragment(arg);
                            }),
                            parent,
                            copyByClone = this.length > 1;
                        if (nodes.length < 1) return this;

                        return this.each(function (_, target) {
                            parent = inside ? target : target.parentNode;

                            // convert all methods to a "before" operation
                            target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;

                            var parentInDocument = $.contains(document.documentElement, parent);

                            nodes.forEach(function (node) {
                                if (copyByClone) node = node.cloneNode(true); else if (!parent) return $(node).remove();

                                parent.insertBefore(node, target);
                                if (parentInDocument) traverseNode(node, function (el) {
                                    if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' && (!el.type || el.type === 'text/javascript') && !el.src) {
                                        var target = el.ownerDocument ? el.ownerDocument.defaultView : window;
                                        target['eval'].call(target, el.innerHTML);
                                    }
                                });
                            });
                        });
                    };

                    // after    => insertAfter
                    // prepend  => prependTo
                    // before   => insertBefore
                    // append   => appendTo
                    $.fn[inside ? operator + 'To' : 'insert' + (operatorIndex ? 'Before' : 'After')] = function (html) {
                        $(html)[operator](this);
                        return this;
                    };
                });

                zepto.Z.prototype = Z.prototype = $.fn;

                // Export internal API functions in the `$.zepto` namespace
                zepto.uniq = uniq;
                zepto.deserializeValue = deserializeValue;
                $.zepto = zepto;

                return $;
            }(); (function ($) {
                var _zid = 1,
                    undefined,
                    slice = Array.prototype.slice,
                    isFunction = $.isFunction,
                    isString = function isString(obj) {
                        return typeof obj == 'string';
                    },
                    handlers = {},
                    specialEvents = {},
                    focusinSupported = 'onfocusin' in window,
                    focus = { focus: 'focusin', blur: 'focusout' },
                    hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' };

                specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents';

                function zid(element) {
                    return element._zid || (element._zid = _zid++);
                }
                function findHandlers(element, event, fn, selector) {
                    event = parse(event);
                    if (event.ns) var matcher = matcherFor(event.ns);
                    return (handlers[zid(element)] || []).filter(function (handler) {
                        return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);
                    });
                }
                function parse(event) {
                    var parts = ('' + event).split('.');
                    return { e: parts[0], ns: parts.slice(1).sort().join(' ') };
                }
                function matcherFor(ns) {
                    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');
                }

                function eventCapture(handler, captureSetting) {
                    return handler.del && !focusinSupported && handler.e in focus || !!captureSetting;
                }

                function realEvent(type) {
                    return hover[type] || focusinSupported && focus[type] || type;
                }

                function add(element, events, fn, data, selector, delegator, capture) {
                    var id = zid(element),
                        set = handlers[id] || (handlers[id] = []);
                    events.split(/\s/).forEach(function (event) {
                        if (event == 'ready') return $(document).ready(fn);
                        var handler = parse(event);
                        handler.fn = fn;
                        handler.sel = selector;
                        // emulate mouseenter, mouseleave
                        if (handler.e in hover) fn = function fn(e) {
                            var related = e.relatedTarget;
                            if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);
                        };
                        handler.del = delegator;
                        var callback = delegator || fn;
                        handler.proxy = function (e) {
                            e = compatible(e);
                            if (e.isImmediatePropagationStopped()) return;
                            e.data = data;
                            var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));
                            if (result === false) e.preventDefault(), e.stopPropagation();
                            return result;
                        };
                        handler.i = set.length;
                        set.push(handler);
                        if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
                    });
                }
                function remove(element, events, fn, selector, capture) {
                    var id = zid(element); (events || '').split(/\s/).forEach(function (event) {
                        findHandlers(element, event, fn, selector).forEach(function (handler) {
                            delete handlers[id][handler.i];
                            if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));
                        });
                    });
                }

                $.event = { add: add, remove: remove };

                $.proxy = function (fn, context) {
                    var args = 2 in arguments && slice.call(arguments, 2);
                    if (isFunction(fn)) {
                        var proxyFn = function proxyFn() {
                            return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);
                        };
                        proxyFn._zid = zid(fn);
                        return proxyFn;
                    } else if (isString(context)) {
                        if (args) {
                            args.unshift(fn[context], fn);
                            return $.proxy.apply(null, args);
                        } else {
                            return $.proxy(fn[context], fn);
                        }
                    } else {
                        throw new TypeError("expected function");
                    }
                };

                $.fn.bind = function (event, data, callback) {
                    return this.on(event, data, callback);
                };
                $.fn.unbind = function (event, callback) {
                    return this.off(event, callback);
                };
                $.fn.one = function (event, selector, data, callback) {
                    return this.on(event, selector, data, callback, 1);
                };

                var returnTrue = function returnTrue() {
                    return true;
                },
                    returnFalse = function returnFalse() {
                        return false;
                    },
                    ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$|webkitMovement[XY]$)/,
                    eventMethods = {
                        preventDefault: 'isDefaultPrevented',
                        stopImmediatePropagation: 'isImmediatePropagationStopped',
                        stopPropagation: 'isPropagationStopped'
                    };

                function compatible(event, source) {
                    if (source || !event.isDefaultPrevented) {
                        source || (source = event);

                        $.each(eventMethods, function (name, predicate) {
                            var sourceMethod = source[name];
                            event[name] = function () {
                                this[predicate] = returnTrue;
                                return sourceMethod && sourceMethod.apply(source, arguments);
                            };
                            event[predicate] = returnFalse;
                        });

                        event.timeStamp || (event.timeStamp = Date.now());

                        if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;
                    }
                    return event;
                }

                function createProxy(event) {
                    var key,
                        proxy = { originalEvent: event };
                    for (key in event) {
                        if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];
                    } return compatible(proxy, event);
                }

                $.fn.delegate = function (selector, event, callback) {
                    return this.on(event, selector, callback);
                };
                $.fn.undelegate = function (selector, event, callback) {
                    return this.off(event, selector, callback);
                };

                $.fn.live = function (event, callback) {
                    $(document.body).delegate(this.selector, event, callback);
                    return this;
                };
                $.fn.die = function (event, callback) {
                    $(document.body).undelegate(this.selector, event, callback);
                    return this;
                };

                $.fn.on = function (event, selector, data, callback, one) {
                    var autoRemove,
                        delegator,
                        $this = this;
                    if (event && !isString(event)) {
                        $.each(event, function (type, fn) {
                            $this.on(type, selector, data, fn, one);
                        });
                        return $this;
                    }

                    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, data = selector, selector = undefined;
                    if (callback === undefined || data === false) callback = data, data = undefined;

                    if (callback === false) callback = returnFalse;

                    return $this.each(function (_, element) {
                        if (one) autoRemove = function autoRemove(e) {
                            remove(element, e.type, callback);
                            return callback.apply(this, arguments);
                        };

                        if (selector) delegator = function delegator(e) {
                            var evt,
                                match = $(e.target).closest(selector, element).get(0);
                            if (match && match !== element) {
                                evt = $.extend(createProxy(e), { currentTarget: match, liveFired: element });
                                return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)));
                            }
                        };

                        add(element, event, callback, data, selector, delegator || autoRemove);
                    });
                };
                $.fn.off = function (event, selector, callback) {
                    var $this = this;
                    if (event && !isString(event)) {
                        $.each(event, function (type, fn) {
                            $this.off(type, selector, fn);
                        });
                        return $this;
                    }

                    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, selector = undefined;

                    if (callback === false) callback = returnFalse;

                    return $this.each(function () {
                        remove(this, event, callback, selector);
                    });
                };

                $.fn.trigger = function (event, args) {
                    event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);
                    event._args = args;
                    return this.each(function () {
                        // handle focus(), blur() by calling them directly
                        if (event.type in focus && typeof this[event.type] == "function") this[event.type]();
                        // items in the collection might not be DOM elements
                        else if ('dispatchEvent' in this) this.dispatchEvent(event); else $(this).triggerHandler(event, args);
                    });
                };

                // triggers event handlers on current element just as if an event occurred,
                // doesn't trigger an actual event, doesn't bubble
                $.fn.triggerHandler = function (event, args) {
                    var e, result;
                    this.each(function (i, element) {
                        e = createProxy(isString(event) ? $.Event(event) : event);
                        e._args = args;
                        e.target = element;
                        $.each(findHandlers(element, event.type || event), function (i, handler) {
                            result = handler.proxy(e);
                            if (e.isImmediatePropagationStopped()) return false;
                        });
                    });
                    return result;
                }

                    // shortcut methods for `.bind(event, fn)` for each event type
                    ; ('focusin focusout focus blur load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select keydown keypress keyup error').split(' ').forEach(function (event) {
                        $.fn[event] = function (callback) {
                            return 0 in arguments ? this.bind(event, callback) : this.trigger(event);
                        };
                    });

                $.Event = function (type, props) {
                    if (!isString(type)) props = type, type = props.type;
                    var event = document.createEvent(specialEvents[type] || 'Events'),
                        bubbles = true;
                    if (props) for (var name in props) {
                        name == 'bubbles' ? bubbles = !!props[name] : event[name] = props[name];
                    } event.initEvent(type, bubbles, true);
                    return compatible(event);
                };
            })(zepto); (function ($) {
                var jsonpID = +new Date(),
                    document = window.document,
                    key,
                    name,
                    rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
                    scriptTypeRE = /^(?:text|application)\/javascript/i,
                    xmlTypeRE = /^(?:text|application)\/xml/i,
                    jsonType = 'application/json',
                    htmlType = 'text/html',
                    blankRE = /^\s*$/,
                    originAnchor = document.createElement('a');

                originAnchor.href = window.location.href;

                // trigger a custom event and return false if it was cancelled
                function triggerAndReturn(context, eventName, data) {
                    var event = $.Event(eventName);
                    $(context).trigger(event, data);
                    return !event.isDefaultPrevented();
                }

                // trigger an Ajax "global" event
                function triggerGlobal(settings, context, eventName, data) {
                    if (settings.global) return triggerAndReturn(context || document, eventName, data);
                }

                // Number of active Ajax requests
                $.active = 0;

                function ajaxStart(settings) {
                    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart');
                }
                function ajaxStop(settings) {
                    if (settings.global && ! --$.active) triggerGlobal(settings, null, 'ajaxStop');
                }

                // triggers an extra global event "ajaxBeforeSend" that's like "ajaxSend" but cancelable
                function ajaxBeforeSend(xhr, settings) {
                    var context = settings.context;
                    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false;

                    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]);
                }
                function ajaxSuccess(data, xhr, settings, deferred) {
                    var context = settings.context,
                        status = 'success';
                    settings.success.call(context, data, status, xhr);
                    if (deferred) deferred.resolveWith(context, [data, status, xhr]);
                    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]);
                    ajaxComplete(status, xhr, settings);
                }
                // type: "timeout", "error", "abort", "parsererror"
                function ajaxError(error, type, xhr, settings, deferred) {
                    var context = settings.context;
                    settings.error.call(context, xhr, type, error);
                    if (deferred) deferred.rejectWith(context, [xhr, type, error]);
                    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]);
                    ajaxComplete(type, xhr, settings);
                }
                // status: "success", "notmodified", "error", "timeout", "abort", "parsererror"
                function ajaxComplete(status, xhr, settings) {
                    var context = settings.context;
                    settings.complete.call(context, xhr, status);
                    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]);
                    ajaxStop(settings);
                }

                function ajaxDataFilter(data, type, settings) {
                    if (settings.dataFilter == empty) return data;
                    var context = settings.context;
                    return settings.dataFilter.call(context, data, type);
                }

                // Empty function, used as default callback
                function empty() { }

                $.ajaxJSONP = function (options, deferred) {
                    if (!('type' in options)) return $.ajax(options);

                    var _callbackName = options.jsonpCallback,
                        callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || 'Zepto' + jsonpID++,
                        script = document.createElement('script'),
                        originalCallback = window[callbackName],
                        responseData,
                        abort = function abort(errorType) {
                            $(script).triggerHandler('error', errorType || 'abort');
                        },
                        xhr = { abort: abort },
                        abortTimeout;

                    if (deferred) deferred.promise(xhr);

                    $(script).on('load error', function (e, errorType) {
                        clearTimeout(abortTimeout);
                        $(script).off().remove();

                        if (e.type == 'error' || !responseData) {
                            ajaxError(null, errorType || 'error', xhr, options, deferred);
                        } else {
                            ajaxSuccess(responseData[0], xhr, options, deferred);
                        }

                        window[callbackName] = originalCallback;
                        if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);

                        originalCallback = responseData = undefined;
                    });

                    if (ajaxBeforeSend(xhr, options) === false) {
                        abort('abort');
                        return xhr;
                    }

                    window[callbackName] = function () {
                        responseData = arguments;
                    };

                    script.src = options.url.replace(/\?(.+)=\?/, '?$1=' + callbackName);
                    document.head.appendChild(script);

                    if (options.timeout > 0) abortTimeout = setTimeout(function () {
                        abort('timeout');
                    }, options.timeout);

                    return xhr;
                };

                $.ajaxSettings = {
                    // Default type of request
                    type: 'GET',
                    // Callback that is executed before request
                    beforeSend: empty,
                    // Callback that is executed if the request succeeds
                    success: empty,
                    // Callback that is executed the the server drops error
                    error: empty,
                    // Callback that is executed on request complete (both: error and success)
                    complete: empty,
                    // The context for the callbacks
                    context: null,
                    // Whether to trigger "global" Ajax events
                    global: true,
                    // Transport
                    xhr: function xhr() {
                        return new window.XMLHttpRequest();
                    },
                    // MIME types mapping
                    // IIS returns Javascript as "application/x-javascript"
                    accepts: {
                        script: 'text/javascript, application/javascript, application/x-javascript',
                        json: jsonType,
                        xml: 'application/xml, text/xml',
                        html: htmlType,
                        text: 'text/plain'
                    },
                    // Whether the request is to another domain
                    crossDomain: false,
                    // Default timeout
                    timeout: 0,
                    // Whether data should be serialized to string
                    processData: true,
                    // Whether the browser should be allowed to cache GET responses
                    cache: true,
                    //Used to handle the raw response data of XMLHttpRequest.
                    //This is a pre-filtering function to sanitize the response.
                    //The sanitized response should be returned
                    dataFilter: empty
                };

                function mimeToDataType(mime) {
                    if (mime) mime = mime.split(';', 2)[0];
                    return mime && (mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) && 'xml') || 'text';
                }

                function appendQuery(url, query) {
                    if (query == '') return url;
                    return (url + '&' + query).replace(/[&?]{1,2}/, '?');
                }

                // serialize payload and append it to the URL for GET requests
                function serializeData(options) {
                    if (options.processData && options.data && $.type(options.data) != "string") options.data = $.param(options.data, options.traditional);
                    if (options.data && (!options.type || options.type.toUpperCase() == 'GET' || 'jsonp' == options.dataType)) options.url = appendQuery(options.url, options.data), options.data = undefined;
                }

                $.ajax = function (options) {
                    var settings = $.extend({}, options || {}),
                        deferred = $.Deferred && $.Deferred(),
                        urlAnchor,
                        hashIndex;
                    for (key in $.ajaxSettings) {
                        if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];
                    } ajaxStart(settings);

                    if (!settings.crossDomain) {
                        urlAnchor = document.createElement('a');
                        urlAnchor.href = settings.url;
                        // cleans up URL for .href (IE only), see https://github.com/madrobby/zepto/pull/1049
                        urlAnchor.href = urlAnchor.href;
                        settings.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                    }

                    if (!settings.url) settings.url = window.location.toString();
                    if ((hashIndex = settings.url.indexOf('#')) > -1) settings.url = settings.url.slice(0, hashIndex);
                    serializeData(settings);

                    var dataType = settings.dataType,
                        hasPlaceholder = /\?.+=\?/.test(settings.url);
                    if (hasPlaceholder) dataType = 'jsonp';

                    if (settings.cache === false || (!options || options.cache !== true) && ('script' == dataType || 'jsonp' == dataType)) settings.url = appendQuery(settings.url, '_=' + Date.now());

                    if ('jsonp' == dataType) {
                        if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + '=?' : settings.jsonp === false ? '' : 'callback=?');
                        return $.ajaxJSONP(settings, deferred);
                    }

                    var mime = settings.accepts[dataType],
                        headers = {},
                        setHeader = function setHeader(name, value) {
                            headers[name.toLowerCase()] = [name, value];
                        },
                        protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol,
                        xhr = settings.xhr(),
                        nativeSetHeader = xhr.setRequestHeader,
                        abortTimeout;

                    if (deferred) deferred.promise(xhr);

                    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest');
                    setHeader('Accept', mime || '*/*');
                    if (mime = settings.mimeType || mime) {
                        if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0];
                        xhr.overrideMimeType && xhr.overrideMimeType(mime);
                    }
                    if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET') setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded');

                    if (settings.headers) for (name in settings.headers) {
                        setHeader(name, settings.headers[name]);
                    } xhr.setRequestHeader = setHeader;

                    xhr.onreadystatechange = function () {
                        if (xhr.readyState == 4) {
                            xhr.onreadystatechange = empty;
                            clearTimeout(abortTimeout);
                            var result,
                                error = false;
                            if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == 'file:') {
                                dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'));

                                if (xhr.responseType == 'arraybuffer' || xhr.responseType == 'blob') result = xhr.response; else {
                                    result = xhr.responseText;

                                    try {
                                        // http://perfectionkills.com/global-eval-what-are-the-options/
                                        // sanitize response accordingly if data filter callback provided
                                        result = ajaxDataFilter(result, dataType, settings);
                                        if (dataType == 'script') (1, eval)(result); else if (dataType == 'xml') result = xhr.responseXML; else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result);
                                    } catch (e) {
                                        error = e;
                                    }

                                    if (error) return ajaxError(error, 'parsererror', xhr, settings, deferred);
                                }

                                ajaxSuccess(result, xhr, settings, deferred);
                            } else {
                                ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred);
                            }
                        }
                    };

                    if (ajaxBeforeSend(xhr, settings) === false) {
                        xhr.abort();
                        ajaxError(null, 'abort', xhr, settings, deferred);
                        return xhr;
                    }

                    var async = 'async' in settings ? settings.async : true;
                    xhr.open(settings.type, settings.url, async, settings.username, settings.password);

                    if (settings.xhrFields) for (name in settings.xhrFields) {
                        xhr[name] = settings.xhrFields[name];
                    } for (name in headers) {
                        nativeSetHeader.apply(xhr, headers[name]);
                    } if (settings.timeout > 0) abortTimeout = setTimeout(function () {
                        xhr.onreadystatechange = empty;
                        xhr.abort();
                        ajaxError(null, 'timeout', xhr, settings, deferred);
                    }, settings.timeout);

                    // avoid sending empty string (#319)
                    xhr.send(settings.data ? settings.data : null);
                    return xhr;
                };

                // handle optional data/success arguments
                function parseArguments(url, data, success, dataType) {
                    if ($.isFunction(data)) dataType = success, success = data, data = undefined;
                    if (!$.isFunction(success)) dataType = success, success = undefined;
                    return {
                        url: url,
                        data: data,
                        success: success,
                        dataType: dataType
                    };
                }

                $.get = function () /* url, data, success, dataType */ {
                    return $.ajax(parseArguments.apply(null, arguments));
                };

                $.post = function () /* url, data, success, dataType */ {
                    var options = parseArguments.apply(null, arguments);
                    options.type = 'POST';
                    return $.ajax(options);
                };

                $.getJSON = function () /* url, data, success */ {
                    var options = parseArguments.apply(null, arguments);
                    options.dataType = 'json';
                    return $.ajax(options);
                };

                $.fn.load = function (url, data, success) {
                    if (!this.length) return this;
                    var self = this,
                        parts = url.split(/\s/),
                        selector,
                        options = parseArguments(url, data, success),
                        callback = options.success;
                    if (parts.length > 1) options.url = parts[0], selector = parts[1];
                    options.success = function (response) {
                        self.html(selector ? $('<div>').html(response.replace(rscript, "")).find(selector) : response);
                        callback && callback.apply(self, arguments);
                    };
                    $.ajax(options);
                    return this;
                };

                var escape = encodeURIComponent;

                function serialize(params, obj, traditional, scope) {
                    var type,
                        array = $.isArray(obj),
                        hash = $.isPlainObject(obj);
                    $.each(obj, function (key, value) {
                        type = $.type(value);
                        if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']';
                        // handle data in serializeArray() format
                        if (!scope && array) params.add(value.name, value.value);
                        // recurse into nested objects
                        else if (type == "array" || !traditional && type == "object") serialize(params, value, traditional, key); else params.add(key, value);
                    });
                }

                $.param = function (obj, traditional) {
                    var params = [];
                    params.add = function (key, value) {
                        if ($.isFunction(value)) value = value();
                        if (value == null) value = "";
                        this.push(escape(key) + '=' + escape(value));
                    };
                    serialize(params, obj, traditional);
                    return params.join('&').replace(/%20/g, '+');
                };
            })(zepto); (function ($) {
                $.fn.serializeArray = function () {
                    var name,
                        type,
                        result = [],
                        add = function add(value) {
                            if (value.forEach) return value.forEach(add);
                            result.push({ name: name, value: value });
                        };
                    if (this[0]) $.each(this[0].elements, function (_, field) {
                        type = field.type, name = field.name;
                        if (name && field.nodeName.toLowerCase() != 'fieldset' && !field.disabled && type != 'submit' && type != 'reset' && type != 'button' && type != 'file' && (type != 'radio' && type != 'checkbox' || field.checked)) add($(field).val());
                    });
                    return result;
                };

                $.fn.serialize = function () {
                    var result = [];
                    this.serializeArray().forEach(function (elm) {
                        result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value));
                    });
                    return result.join('&');
                };

                $.fn.submit = function (callback) {
                    if (0 in arguments) this.bind('submit', callback); else if (this.length) {
                        var event = $.Event('submit');
                        this.eq(0).trigger(event);
                        if (!event.isDefaultPrevented()) this.get(0).submit();
                    }
                    return this;
                };
            })(zepto); (function () {
                // getComputedStyle shouldn't freak out when called
                // without a valid element as argument
                try {
                    getComputedStyle(undefined);
                } catch (e) {
                    var nativeGetComputedStyle = getComputedStyle;
                    window.getComputedStyle = function (element, pseudoElement) {
                        try {
                            return nativeGetComputedStyle(element, pseudoElement);
                        } catch (e) {
                            return null;
                        }
                    };
                }
            })();

            /***/
}),
/* 7 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.mercators2lonlats = exports.mercator2lonlat = exports.mercators2cartesians = exports.mercator2cartesian = exports.lonlats2mercators = exports.lonlat2mercator = exports.lonlats2cartesians = exports.lonlat2cartesian = exports.cartesians2mercators = exports.cartesian2mercator = exports.cartesians2lonlats = exports.cartesian2lonlat = exports.cancelFn = exports.requestFn = exports.emptyImageUrl = exports.lastId = exports.create = undefined;
            exports.extend = extend;
            exports.bind = bind;
            exports.stamp = stamp;
            exports.throttle = throttle;
            exports.wrapNum = wrapNum;
            exports.falseFn = falseFn;
            exports.formatNum = formatNum;
            exports.trim = trim;
            exports.splitWords = splitWords;
            exports.setOptions = setOptions;
            exports.getParamString = getParamString;
            exports.template = template;
            exports.indexOf = indexOf;
            exports.requestAnimFrame = requestAnimFrame;
            exports.cancelAnimFrame = cancelAnimFrame;
            exports.removeGeoJsonDefVal = removeGeoJsonDefVal;
            exports.addGeoJsonDefVal = addGeoJsonDefVal;
            exports.getDefStyle = getDefStyle;
            exports.getPositionByGeoJSON = getPositionByGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            // @function extend(dest: Object, src?: Object): Object
            // Merges the properties of the `src` object (or multiple objects) into `dest` object and returns the latter. Has an `L.extend` shortcut.
            function extend(dest) {
                var i, j, len, src;

                for (j = 1, len = arguments.length; j < len; j++) {
                    src = arguments[j];
                    for (i in src) {
                        dest[i] = src[i];
                    }
                }
                return dest;
            }

            // @function create(proto: Object, properties?: Object): Object
            // Compatibility polyfill for [Object.create](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/create)
            var create = exports.create = Object.create || function () {
                function F() { }
                return function (proto) {
                    F.prototype = proto;
                    return new F();
                };
            }();

            // @function bind(fn: Function, …): Function
            // Returns a new function bound to the arguments passed, like [Function.prototype.bind](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
            function bind(fn, obj) {
                var slice = Array.prototype.slice;

                if (fn.bind) {
                    return fn.bind.apply(fn, slice.call(arguments, 1));
                }

                var args = slice.call(arguments, 2);

                return function () {
                    return fn.apply(obj, args.length ? args.concat(slice.call(arguments)) : arguments);
                };
            }

            // @property lastId: Number
            // Last unique ID used by [`stamp()`](#util-stamp)
            var lastId = exports.lastId = 0;

            // @function stamp(obj: Object): Number
            // Returns the unique ID of an object, assigning it one if it doesn't have it.
            function stamp(obj) {
                /*eslint-disable */
                obj._leaflet_id = obj._leaflet_id || (exports.lastId = lastId += 1);
                return obj._leaflet_id;
                /* eslint-enable */
            }

            // @function throttle(fn: Function, time: Number, context: Object): Function
            // Returns a function which executes function `fn` with the given scope `context`
            // (so that the `this` keyword refers to `context` inside `fn`'s code). The function
            // `fn` will be called no more than one time per given amount of `time`. The arguments
            // received by the bound function will be any arguments passed when binding the
            // function, followed by any arguments passed when invoking the bound function.
            function throttle(fn, time, context) {
                var lock, args, wrapperFn, later;

                later = function later() {
                    // reset lock and call if queued
                    lock = false;
                    if (args) {
                        wrapperFn.apply(context, args);
                        args = false;
                    }
                };

                wrapperFn = function wrapperFn() {
                    if (lock) {
                        // called too soon, queue to call later
                        args = arguments;
                    } else {
                        // call and lock until later
                        fn.apply(context, arguments);
                        setTimeout(later, time);
                        lock = true;
                    }
                };

                return wrapperFn;
            }

            // @function wrapNum(num: Number, range: Number[], includeMax?: Boolean): Number
            // Returns the number `num` modulo `range` in such a way so it lies within
            // `range[0]` and `range[1]`. The returned value will be always smaller than
            // `range[1]` unless `includeMax` is set to `true`.
            function wrapNum(x, range, includeMax) {
                var max = range[1],
                    min = range[0],
                    d = max - min;
                return x === max && includeMax ? x : ((x - min) % d + d) % d + min;
            }

            // @function falseFn(): Function
            // Returns a function which always returns `false`.
            function falseFn() {
                return false;
            }

            // @function formatNum(num: Number, digits?: Number): Number
            // Returns the number `num` rounded to `digits` decimals, or to 6 decimals by default.
            function formatNum(num, digits) {
                //var pow = Math.pow(10, (digits === undefined ? 6 : digits));
                //return Math.round(num * pow) / pow;
                return Number(num.toFixed(digits || 0));
            }

            // @function trim(str: String): String
            // Compatibility polyfill for [String.prototype.trim](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/String/Trim)
            function trim(str) {
                return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
            }

            // @function splitWords(str: String): String[]
            // Trims and splits the string on whitespace and returns the array of parts.
            function splitWords(str) {
                return trim(str).split(/\s+/);
            }

            // @function setOptions(obj: Object, options: Object): Object
            // Merges the given properties to the `options` of the `obj` object, returning the resulting options. See `MapVClass options`. Has an `L.setOptions` shortcut.
            function setOptions(obj, options) {
                if (!obj.hasOwnProperty('options')) {
                    obj.options = obj.options ? create(obj.options) : {};
                }
                for (var i in options) {
                    obj.options[i] = options[i];
                }
                return obj.options;
            }

            // @function getParamString(obj: Object, existingUrl?: String, uppercase?: Boolean): String
            // Converts an object into a parameter URL string, e.g. `{a: "foo", b: "bar"}`
            // translates to `'?a=foo&b=bar'`. If `existingUrl` is set, the parameters will
            // be appended at the end. If `uppercase` is `true`, the parameter names will
            // be uppercased (e.g. `'?A=foo&B=bar'`)
            function getParamString(obj, existingUrl, uppercase) {
                var params = [];
                for (var i in obj) {
                    params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
                }
                return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');
            }

            var templateRe = /\{ *([\w_-]+) *\}/g;

            // @function template(str: String, data: Object): String
            // Simple templating facility, accepts a template string of the form `'Hello {a}, {b}'`
            // and a data object like `{a: 'foo', b: 'bar'}`, returns evaluated string
            // `('Hello foo, bar')`. You can also specify functions instead of strings for
            // data values — they will be evaluated passing `data` as an argument.
            function template(str, data) {
                return str.replace(templateRe, function (str, key) {
                    var value = data[key];

                    if (value === undefined) {
                        throw new Error('No value provided for variable ' + str);
                    } else if (typeof value === 'function') {
                        value = value(data);
                    }
                    return value;
                });
            }

            // @function indexOf(array: Array, el: Object): Number
            // Compatibility polyfill for [Array.prototype.indexOf](https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)
            function indexOf(array, el) {
                for (var i = 0; i < array.length; i++) {
                    if (array[i] === el) {
                        return i;
                    }
                }
                return -1;
            }

            // @property emptyImageUrl: String
            // Data URI string containing a base64-encoded empty GIF image.
            // Used as a hack to free memory from unused images on WebKit-powered
            // mobile devices (by setting image `src` to this string).
            var emptyImageUrl = exports.emptyImageUrl = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';

            // inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

            function getPrefixed(name) {
                return window['webkit' + name] || window['moz' + name] || window['ms' + name];
            }

            var lastTime = 0;

            // fallback for IE 7-8
            function timeoutDefer(fn) {
                var time = +new Date(),
                    timeToCall = Math.max(0, 16 - (time - lastTime));

                lastTime = time + timeToCall;
                return window.setTimeout(fn, timeToCall);
            }

            var requestFn = exports.requestFn = window.requestAnimationFrame || getPrefixed('RequestAnimationFrame') || timeoutDefer;
            var cancelFn = exports.cancelFn = window.cancelAnimationFrame || getPrefixed('CancelAnimationFrame') || getPrefixed('CancelRequestAnimationFrame') || function (id) {
                window.clearTimeout(id);
            };

            // @function requestAnimFrame(fn: Function, context?: Object, immediate?: Boolean): Number
            // Schedules `fn` to be executed when the browser repaints. `fn` is bound to
            // `context` if given. When `immediate` is set, `fn` is called immediately if
            // the browser doesn't have native support for
            // [`window.requestAnimationFrame`](https://developer.mozilla.org/docs/Web/API/window/requestAnimationFrame),
            // otherwise it's delayed. Returns a request ID that can be used to cancel the request.
            function requestAnimFrame(fn, context, immediate) {
                if (immediate && requestFn === timeoutDefer) {
                    fn.call(context);
                } else {
                    return requestFn.call(window, bind(fn, context));
                }
            }

            // @function cancelAnimFrame(id: Number): undefined
            // Cancels a previous `requestAnimFrame`. See also [window.cancelAnimationFrame](https://developer.mozilla.org/docs/Web/API/window/cancelAnimationFrame).
            function cancelAnimFrame(id) {
                if (id) {
                    cancelFn.call(window, id);
                }
            }

            //从plot的 标号默认值F12打印 拷贝，方便读取 
            var defConfigStyle = { "label": { "text": "文字", "color": "#ffffff", "opacity": 1, "font_family": "楷体", "font_size": 30, "border": true, "border_color": "#000000", "border_width": 3, "background": false, "background_color": "#000000", "background_opacity": 0.5, "font_weight": "normal", "font_style": "normal", "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "point": { "pixelSize": 10, "color": "#3388ff", "opacity": 1, "outline": true, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "outlineWidth": 2, "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "billboard": { "opacity": 1, "scale": 1, "rotation": 0, "horizontalOrigin": "CENTER", "verticalOrigin": "BOTTOM", "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "font-point": { "iconClass": "fa fa-automobile", "iconSize": 50, "color": "#00ffff", "opacity": 1, "horizontalOrigin": "CENTER", "verticalOrigin": "CENTER", "rotation": 0, "scaleByDistance": false, "scaleByDistance_far": 1000000, "scaleByDistance_farValue": 0.1, "scaleByDistance_near": 1000, "scaleByDistance_nearValue": 1, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false, "visibleDepth": true }, "model": { "scale": 1, "heading": 0, "pitch": 0, "roll": 0, "fill": false, "color": "#3388ff", "opacity": 1, "silhouette": false, "silhouetteColor": "#ffffff", "silhouetteSize": 2, "silhouetteAlpha": 0.8, "clampToGround": false }, "polyline": { "lineType": "solid", "animationDuration": 1000, "animationImage": "img/textures/lineClr.png", "color": "#3388ff", "width": 4, "clampToGround": false, "outline": false, "outlineColor": "#ffffff", "outlineWidth": 2, "opacity": 1, "zIndex": 0 }, "polylineVolume": { "color": "#00FF00", "radius": 10, "shape": "pipeline", "outline": false, "outlineColor": "#ffffff", "opacity": 1 }, "wall": { "extrudedHeight": 50, "fill": true, "fillType": "color", "animationDuration": 1000, "animationImage": "img/textures/fence.png", "animationRepeatX": 1, "animationAxisY": false, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6 }, "corridor": { "height": 0, "width": 100, "cornerType": "ROUNDED", "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "color": "#3388ff", "opacity": 0.6, "clampToGround": false, "zIndex": 0 }, "extrudedCorridor": { "height": 0, "extrudedHeight": 50, "width": 100, "cornerType": "ROUNDED", "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "color": "#00FF00", "opacity": 0.6, "clampToGround": false, "zIndex": 0 }, "polygon": { "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "clampToGround": false, "zIndex": 0 }, "polygon_clampToGround": { "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedPolygon": { "extrudedHeight": 100, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "perPositionHeight": true, "zIndex": 0 }, "rectangle": { "height": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "stRotation": 0, "clampToGround": false, "zIndex": 0 }, "rectangleImg": { "opacity": 1, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedRectangle": { "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "stRotation": 0, "zIndex": 0 }, "circle": { "radius": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "clampToGround": false, "zIndex": 0 }, "circle_clampToGround": { "radius": 100, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedCircle": { "radius": 100, "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "zIndex": 0 }, "ellipse": { "semiMinorAxis": 100, "semiMajorAxis": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#3388ff", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "clampToGround": false, "zIndex": 0 }, "ellipse_clampToGround": { "semiMinorAxis": 100, "semiMajorAxis": 100, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#ffff00", "opacity": 0.6, "stRotation": 0, "rotation": 0, "clampToGround": true, "zIndex": 0 }, "extrudedEllipse": { "semiMinorAxis": 100, "semiMajorAxis": 100, "extrudedHeight": 100, "height": 0, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "stRotation": 0, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "rotation": 0, "zIndex": 0 }, "cylinder": { "topRadius": 0, "bottomRadius": 100, "length": 100, "fill": true, "fillType": "color", "animationDuration": 1000, "animationCount": 1, "animationGradient": 0.1, "color": "#00FF00", "opacity": 0.6, "outline": false, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6 }, "ellipsoid": { "extentRadii": 100, "widthRadii": 100, "heightRadii": 100, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6 }, "plane": { "dimensionsX": 100, "dimensionsY": 100, "plane_normal": "z", "plane_distance": 0, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0 }, "box": { "dimensionsX": 100, "dimensionsY": 100, "dimensionsZ": 100, "fill": true, "fillType": "color", "grid_lineCount": 8, "grid_lineThickness": 2, "grid_cellAlpha": 0.1, "stripe_oddcolor": "#ffffff", "stripe_repeat": 6, "checkerboard_oddcolor": "#ffffff", "checkerboard_repeat": 4, "color": "#00FF00", "opacity": 0.6, "outline": true, "outlineWidth": 1, "outlineColor": "#ffffff", "outlineOpacity": 0.6, "distanceDisplayCondition": false, "distanceDisplayCondition_far": 10000, "distanceDisplayCondition_near": 0, "clampToGround": false } };
            defConfigStyle.imagepoint = defConfigStyle.billboard; //兼容历史命名
            defConfigStyle.ellipse = defConfigStyle.circle;

            //剔除与默认值相同的值
            function removeGeoJsonDefVal(geojson) {
                if (!geojson.properties || !geojson.properties.type) return geojson;

                var type = geojson.properties.edittype || geojson.properties.type;
                var defStyle = defConfigStyle[type];
                if (!defStyle) return geojson;

                var newgeojson = util.clone(geojson);
                if (geojson.properties.style) {
                    var newstyle = {};
                    for (var i in geojson.properties.style) {
                        var val = geojson.properties.style[i];
                        if (!Cesium.defined(val)) continue;

                        var valDef = defStyle[i];
                        if (valDef === val) continue;
                        newstyle[i] = val;
                    }
                    newgeojson.properties.style = newstyle;
                }

                return newgeojson;
            }

            function addGeoJsonDefVal(properties) {
                //赋默认值 
                var defStyle = defConfigStyle[properties.edittype || properties.type];
                if (defStyle) {
                    properties.style = properties.style || {};
                    for (var key in defStyle) {
                        var val = properties.style[key];
                        if (Cesium.defined(val)) continue;

                        properties.style[key] = defStyle[key];
                    }
                }
                return properties;
            }

            //获取默认的样式
            function getDefStyle(type, style) {
                style = style || {};
                //赋默认值 
                var defStyle = defConfigStyle[type];
                if (defStyle) {
                    for (var key in defStyle) {
                        var val = style[key];
                        if (val != null) continue;

                        style[key] = defStyle[key];
                    }
                }
                return util.clone(style);
            }

            //geojson转entity
            function getPositionByGeoJSON(geojson, defHeight) {
                var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
                    coords = geometry ? geometry.coordinates : null;

                if (!coords && !geometry) {
                    return null;
                }

                switch (geometry.type) {
                    case 'Point':
                        return pointconvert.lonlat2cartesian(coords, defHeight);
                    case 'MultiPoint':
                    case 'LineString':
                        return pointconvert.lonlats2cartesians(coords, defHeight);

                    case 'MultiLineString':
                    case 'Polygon':
                        return pointconvert.lonlats2cartesians(coords[0], defHeight);
                    case 'MultiPolygon':
                        return pointconvert.lonlats2cartesians(coords[0][0], defHeight);
                    default:
                        throw new Error('Invalid GeoJSON object.');
                }
            }

            //兼容历史，2.02迁移以下方法到pointconvert
            var cartesian2lonlat = exports.cartesian2lonlat = pointconvert.cartesian2lonlat;
            var cartesians2lonlats = exports.cartesians2lonlats = pointconvert.cartesians2lonlats;
            var cartesian2mercator = exports.cartesian2mercator = pointconvert.cartesian2mercator;
            var cartesians2mercators = exports.cartesians2mercators = pointconvert.cartesians2mercators;

            var lonlat2cartesian = exports.lonlat2cartesian = pointconvert.lonlat2cartesian;
            var lonlats2cartesians = exports.lonlats2cartesians = pointconvert.lonlats2cartesians;
            var lonlat2mercator = exports.lonlat2mercator = pointconvert.lonlat2mercator;
            var lonlats2mercators = exports.lonlats2mercators = pointconvert.lonlats2mercators;

            var mercator2cartesian = exports.mercator2cartesian = pointconvert.mercator2cartesian;
            var mercators2cartesians = exports.mercators2cartesians = pointconvert.mercators2cartesians;
            var mercator2lonlat = exports.mercator2lonlat = pointconvert.mercator2lonlat;
            var mercators2lonlats = exports.mercators2lonlats = pointconvert.mercators2lonlats;

            /***/
}),
/* 8 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.PointColor = exports.PointType = exports.PixelSize = undefined;
            exports.createDragger = createDragger;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Tooltip = __webpack_require__(5);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //拖拽点控制类
            var PixelSize = exports.PixelSize = 12; //编辑点的像素大小

            //拖拽点分类
            var PointType = exports.PointType = {
                Control: 1, //位置控制
                MoveAll: 2, //整体平移(如线面)
                AddMidPoint: 3, //辅助增加新点
                MoveHeight: 4, //上下移动高度
                EditAttr: 5, //辅助修改属性（如半径）
                EditRotation: 6 //旋转角度修改


                //拖拽点分类
            }; var PointColor = exports.PointColor = {
                Control: new Cesium.Color.fromCssColorString("#1c197d"), //位置控制拖拽点
                MoveAll: new Cesium.Color.fromCssColorString("#8c003a"), //整体平移(如线面)拖拽点
                MoveHeight: new Cesium.Color.fromCssColorString("#9500eb"), //上下移动高度的拖拽点
                EditAttr: new Cesium.Color.fromCssColorString("#f531e8"), //辅助修改属性（如半径）的拖拽点
                AddMidPoint: new Cesium.Color.fromCssColorString("#04c2c9").withAlpha(0.3) //增加新点，辅助拖拽点
            };

            function getAttrForType(type, attr) {
                switch (type) {
                    case PointType.AddMidPoint:
                        attr.color = PointColor.AddMidPoint;
                        attr.outlineColor = new Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.4);
                        break;
                    case PointType.MoveAll:
                        attr.color = PointColor.MoveAll;
                        break;
                    case PointType.MoveHeight:
                        attr.color = PointColor.MoveHeight;
                        break;
                    case PointType.EditAttr:
                        attr.color = PointColor.EditAttr;
                        break;
                    case PointType.Control:
                    default:
                        attr.color = PointColor.Control;
                        break;
                }
                return attr;
            }

            /** 创建Dragger拖动点的公共方法 */
            function createDragger(dataSource, options) {
                var dragger;
                if (options.dragger) {
                    dragger = options.dragger;
                } else {
                    var attr = {
                        scale: 1,
                        pixelSize: PixelSize,
                        outlineColor: new Cesium.Color.fromCssColorString("#ffffff").withAlpha(0.5),
                        outlineWidth: 2,
                        scaleByDistance: new Cesium.NearFarScalar(1000, 1, 1000000, 0.5),
                        disableDepthTestDistance: Number.POSITIVE_INFINITY //一直显示，不被地形等遮挡
                    };
                    attr = getAttrForType(options.type, attr);

                    dragger = dataSource.entities.add({
                        position: Cesium.defaultValue(options.position, Cesium.Cartesian3.ZERO),
                        point: attr,
                        draw_tooltip: options.tooltip || _Tooltip.message.dragger.def
                    });
                    dragger.contextmenuItems = false; //不加右键菜单
                }

                dragger._isDragger = true;
                dragger._noMousePosition = true; //不被getCurrentMousePosition拾取
                dragger._pointType = options.type || PointType.Control; //默认是位置控制拖拽点

                dragger.onDragStart = Cesium.defaultValue(options.onDragStart, null);
                dragger.onDrag = Cesium.defaultValue(options.onDrag, null);
                dragger.onDragEnd = Cesium.defaultValue(options.onDragEnd, null);

                return dragger;
            }

            /***/
}),
/* 9 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPolygonEx = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(61);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //用于外部扩展使用，绘制的点与显示的点不一致的标号
            var DrawPolygonEx = exports.DrawPolygonEx = _Draw.DrawPolygon.extend({
                _positions_show: null,
                getDrawPosition: function getDrawPosition() {
                    return this._positions_show;
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
                        this._positions_show = this._positions_draw;
                        return;
                    }

                    this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);
                },
                //子类中重写 ，根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return positions;
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    //抛弃多余的无效绘制点
                    if (this._positions_draw.length > this._maxPointNum) this._positions_draw.splice(this._maxPointNum, this._positions_draw.length - this._maxPointNum);

                    this.entity._positions_draw = this._positions_draw;
                    this.entity._positions_show = this._positions_show;

                    entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                        var positions = entity._positions_show;
                        return new Cesium.PolygonHierarchy(positions);
                    }, false);

                    this._positions_draw = null;
                    this._positions_show = null;
                },
                toGeoJSON: function toGeoJSON(entity) {
                    return this.attrClass.toGeoJSON(entity, true); //不用闭合最后一个点
                }

            });

            /***/
}),
/* 10 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPolygonEx = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Edit = __webpack_require__(25);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //用于外部扩展使用，绘制的点与显示的点不一致的标号
            var EditPolygonEx = exports.EditPolygonEx = _Edit.EditPolygon.extend({
                _hasMidPoint: false,
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;
                    this._positions_show = this.entity._positions_show;
                },
                //坐标位置相关  
                updateAttrForEditing: function updateAttrForEditing() {
                    if (this._positions_draw == null || this._positions_draw.length < this._minPointNum) {
                        this._positions_show = this._positions_draw;
                        return;
                    }

                    this._positions_show = this.getShowPositions(this._positions_draw, this.entity.attribute);

                    this.entity._positions_show = this._positions_show;
                },
                //子类中重写 ，根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return positions;
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_show = this._positions_show;
                    this.entity._positions_draw = this._positions_draw;
                }

            });

            /***/
}),
/* 11 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.plotUtil = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //基本计算方法
            var PlotUtilClass = function () {
                function PlotUtilClass() {
                    _classCallCheck(this, PlotUtilClass);

                    this.HALF_PI = Math.PI / 2;
                    this.ZERO_TOLERANCE = 0.0001;
                }

                //获取第三点 


                _createClass(PlotUtilClass, [{
                    key: "getThirdPoint",
                    value: function getThirdPoint(startPnt, endPnt, angle, distance, clockWise) {
                        var azimuth = this.getAzimuth(startPnt, endPnt);
                        var alpha = clockWise ? azimuth + angle : azimuth - angle;
                        var dx = distance * Math.cos(alpha);
                        var dy = distance * Math.sin(alpha);
                        return [endPnt[0] + dx, endPnt[1] + dy];
                    }

                    //计算夹角

                }, {
                    key: "getAzimuth",
                    value: function getAzimuth(startPoint, endPoint) {
                        var azimuth = void 0;
                        var angle = Math.asin(Math.abs(endPoint[1] - startPoint[1]) / this.MathDistance(startPoint, endPoint));
                        if (endPoint[1] >= startPoint[1] && endPoint[0] >= startPoint[0]) {
                            azimuth = angle + Math.PI;
                        } else if (endPoint[1] >= startPoint[1] && endPoint[0] < startPoint[0]) {
                            azimuth = Math.PI * 2 - angle;
                        } else if (endPoint[1] < startPoint[1] && endPoint[0] < startPoint[0]) {
                            azimuth = angle;
                        } else if (endPoint[1] < startPoint[1] && endPoint[0] >= startPoint[0]) {
                            azimuth = Math.PI - angle;
                        }
                        return azimuth;
                    }
                }, {
                    key: "MathDistance",
                    value: function MathDistance(pnt1, pnt2) {
                        return Math.sqrt(Math.pow(pnt1[0] - pnt2[0], 2) + Math.pow(pnt1[1] - pnt2[1], 2));
                    }
                    //计算闭合曲面上的点

                }, {
                    key: "isClockWise",
                    value: function isClockWise(pnt1, pnt2, pnt3) {
                        return (pnt3[1] - pnt1[1]) * (pnt2[0] - pnt1[0]) > (pnt2[1] - pnt1[1]) * (pnt3[0] - pnt1[0]);
                    }
                }, {
                    key: "getBisectorNormals",
                    value: function getBisectorNormals(t, pnt1, pnt2, pnt3) {
                        var normal = this.getNormal(pnt1, pnt2, pnt3);
                        var bisectorNormalRight = null,
                            bisectorNormalLeft = null,
                            dt = null,
                            x = null,
                            y = null;

                        var dist = Math.sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
                        var uX = normal[0] / dist;
                        var uY = normal[1] / dist;
                        var d1 = this.MathDistance(pnt1, pnt2);
                        var d2 = this.MathDistance(pnt2, pnt3);
                        if (dist > this.ZERO_TOLERANCE) {
                            if (this.isClockWise(pnt1, pnt2, pnt3)) {
                                dt = t * d1;
                                x = pnt2[0] - dt * uY;
                                y = pnt2[1] + dt * uX;
                                bisectorNormalRight = [x, y];
                                dt = t * d2;
                                x = pnt2[0] + dt * uY;
                                y = pnt2[1] - dt * uX;
                                bisectorNormalLeft = [x, y];
                            } else {
                                dt = t * d1;
                                x = pnt2[0] + dt * uY;
                                y = pnt2[1] - dt * uX;
                                bisectorNormalRight = [x, y];
                                dt = t * d2;
                                x = pnt2[0] - dt * uY;
                                y = pnt2[1] + dt * uX;
                                bisectorNormalLeft = [x, y];
                            }
                        } else {
                            x = pnt2[0] + t * (pnt1[0] - pnt2[0]);
                            y = pnt2[1] + t * (pnt1[1] - pnt2[1]);
                            bisectorNormalRight = [x, y];
                            x = pnt2[0] + t * (pnt3[0] - pnt2[0]);
                            y = pnt2[1] + t * (pnt3[1] - pnt2[1]);
                            bisectorNormalLeft = [x, y];
                        }
                        return [bisectorNormalRight, bisectorNormalLeft];
                    }
                }, {
                    key: "getCubicValue",
                    value: function getCubicValue(t, startPnt, cPnt1, cPnt2, endPnt) {
                        t = Math.max(Math.min(t, 1), 0);
                        var tp = 1 - t,
                            t2 = t * t;

                        var t3 = t2 * t;
                        var tp2 = tp * tp;
                        var tp3 = tp2 * tp;
                        var x = tp3 * startPnt[0] + 3 * tp2 * t * cPnt1[0] + 3 * tp * t2 * cPnt2[0] + t3 * endPnt[0];
                        var y = tp3 * startPnt[1] + 3 * tp2 * t * cPnt1[1] + 3 * tp * t2 * cPnt2[1] + t3 * endPnt[1];
                        return [x, y];
                    }
                }, {
                    key: "getNormal",
                    value: function getNormal(pnt1, pnt2, pnt3) {
                        var dX1 = pnt1[0] - pnt2[0];
                        var dY1 = pnt1[1] - pnt2[1];
                        var d1 = Math.sqrt(dX1 * dX1 + dY1 * dY1);
                        dX1 /= d1;
                        dY1 /= d1;
                        var dX2 = pnt3[0] - pnt2[0];
                        var dY2 = pnt3[1] - pnt2[1];
                        var d2 = Math.sqrt(dX2 * dX2 + dY2 * dY2);
                        dX2 /= d2;
                        dY2 /= d2;
                        var uX = dX1 + dX2;
                        var uY = dY1 + dY2;
                        return [uX, uY];
                    }
                }, {
                    key: "getArcPoints",
                    value: function getArcPoints(center, radius, startAngle, endAngle) {
                        var x = null,
                            y = null,
                            pnts = [],
                            angleDiff = endAngle - startAngle;
                        angleDiff = angleDiff < 0 ? angleDiff + Math.PI * 2 : angleDiff;
                        for (var i = 0; i <= 100; i++) {
                            var angle = startAngle + angleDiff * i / 100;
                            x = center[0] + radius * Math.cos(angle);
                            y = center[1] + radius * Math.sin(angle);
                            pnts.push([x, y]);
                        }
                        return pnts;
                    }
                }, {
                    key: "getBaseLength",
                    value: function getBaseLength(points) {
                        return Math.pow(this.wholeDistance(points), 0.99);
                    }
                }, {
                    key: "wholeDistance",
                    value: function wholeDistance(points) {
                        var distance = 0;
                        var that = this;
                        if (points && Array.isArray(points) && points.length > 0) {
                            points.forEach(function (item, index) {
                                if (index < points.length - 1) {
                                    distance += that.MathDistance(item, points[index + 1]);
                                }
                            });
                        }
                        return distance;
                    }
                }, {
                    key: "getArrowHeadPoints",
                    value: function getArrowHeadPoints(obj) {
                        if (!obj) return [];
                        var points = obj.points;
                        var tailLeft = obj.tailLeft;
                        var tailRight = obj.tailRight;
                        var headTailFactor = obj.headTailFactor;
                        var neckWidthFactor = obj.neckWidthFactor;
                        var neckHeightFactor = obj.neckHeightFactor;
                        var headWidthFactor = obj.headWidthFactor;
                        var headHeightFactor = obj.headHeightFactor;
                        var len = this.getBaseLength(points);
                        var headHeight = len * headHeightFactor;
                        var headPnt = points[points.length - 1];
                        len = this.MathDistance(headPnt, points[points.length - 2]);
                        var tailWidth = this.MathDistance(tailLeft, tailRight);
                        if (headHeight > tailWidth * headTailFactor) {
                            headHeight = tailWidth * headTailFactor;
                        }
                        var headWidth = headHeight * headWidthFactor;
                        var neckWidth = headHeight * neckWidthFactor;
                        headHeight = headHeight > len ? len : headHeight;
                        var neckHeight = headHeight * neckHeightFactor;
                        var headEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
                        var neckEndPnt = this.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
                        var headLeft = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, false);
                        var headRight = this.getThirdPoint(headPnt, headEndPnt, this.HALF_PI, headWidth, true);
                        var neckLeft = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, false);
                        var neckRight = this.getThirdPoint(headPnt, neckEndPnt, this.HALF_PI, neckWidth, true);
                        return [neckLeft, headLeft, headPnt, headRight, neckRight];
                    }
                }, {
                    key: "getTailPoints",
                    value: function getTailPoints(obj) {
                        if (!obj) return;
                        var points = obj.points;
                        var tailWidthFactor = obj.tailWidthFactor;
                        var swallowTailFactor = obj.swallowTailFactor;
                        var allLen = this.getBaseLength(points);
                        var tailWidth = allLen * tailWidthFactor;
                        var tailLeft = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, false);
                        var tailRight = this.getThirdPoint(points[1], points[0], this.HALF_PI, tailWidth, true);
                        var len = tailWidth * swallowTailFactor;
                        var swallowTailPnt = this.getThirdPoint(points[1], points[0], 0, len, true);
                        return [tailLeft, swallowTailPnt, tailRight];
                    }
                }, {
                    key: "getArrowBodyPoints",
                    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
                        var allLen = this.wholeDistance(points);
                        var len = this.getBaseLength(points);
                        var tailWidth = len * tailWidthFactor;
                        var neckWidth = this.MathDistance(neckLeft, neckRight);
                        var widthDif = (tailWidth - neckWidth) / 2;
                        var tempLen = 0,
                            leftBodyPnts = [],
                            rightBodyPnts = [];

                        for (var i = 1; i < points.length - 1; i++) {
                            var angle = this.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                            tempLen += this.MathDistance(points[i - 1], points[i]);
                            var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                            var left = this.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                            var right = this.getThirdPoint(points[i - 1], points[i], angle, w, false);
                            leftBodyPnts.push(left);
                            rightBodyPnts.push(right);
                        }
                        return leftBodyPnts.concat(rightBodyPnts);
                    }
                }, {
                    key: "getAngleOfThreePoints",
                    value: function getAngleOfThreePoints(pntA, pntB, pntC) {
                        var angle = this.getAzimuth(pntB, pntA) - this.getAzimuth(pntB, pntC);
                        return angle < 0 ? angle + Math.PI * 2 : angle;
                    }
                }, {
                    key: "getQBSplinePoints",
                    value: function getQBSplinePoints(points) {
                        if (points.length <= 2) {
                            return points;
                        } else {
                            var n = 2,
                                bSplinePoints = [];

                            var m = points.length - n - 1;
                            bSplinePoints.push(points[0]);
                            for (var i = 0; i <= m; i++) {
                                for (var t = 0; t <= 1; t += 0.05) {
                                    var x = 0,
                                        y = 0;

                                    for (var k = 0; k <= n; k++) {
                                        var factor = this.getQuadricBSplineFactor(k, t);
                                        x += factor * points[i + k][0];
                                        y += factor * points[i + k][1];
                                    }
                                    bSplinePoints.push([x, y]);
                                }
                            }
                            bSplinePoints.push(points[points.length - 1]);
                            return bSplinePoints;
                        }
                    }
                }, {
                    key: "getQuadricBSplineFactor",
                    value: function getQuadricBSplineFactor(k, t) {
                        var res = 0;
                        if (k === 0) {
                            res = Math.pow(t - 1, 2) / 2;
                        } else if (k === 1) {
                            res = (-2 * Math.pow(t, 2) + 2 * t + 1) / 2;
                        } else if (k === 2) {
                            res = Math.pow(t, 2) / 2;
                        }
                        return res;
                    }
                }, {
                    key: "Mid",
                    value: function Mid(point1, point2) {
                        return [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
                    }
                }, {
                    key: "getCircleCenterOfThreePoints",
                    value: function getCircleCenterOfThreePoints(point1, point2, point3) {
                        var pntA = [(point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2];
                        var pntB = [pntA[0] - point1[1] + point2[1], pntA[1] + point1[0] - point2[0]];
                        var pntC = [(point1[0] + point3[0]) / 2, (point1[1] + point3[1]) / 2];
                        var pntD = [pntC[0] - point1[1] + point3[1], pntC[1] + point1[0] - point3[0]];
                        return this.getIntersectPoint(pntA, pntB, pntC, pntD);
                    }
                }, {
                    key: "getIntersectPoint",
                    value: function getIntersectPoint(pntA, pntB, pntC, pntD) {
                        if (pntA[1] === pntB[1]) {
                            var _f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
                            var _x = _f * (pntA[1] - pntC[1]) + pntC[0];
                            var _y = pntA[1];
                            return [_x, _y];
                        }
                        if (pntC[1] === pntD[1]) {
                            var _e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
                            var _x2 = _e * (pntC[1] - pntA[1]) + pntA[0];
                            var _y2 = pntC[1];
                            return [_x2, _y2];
                        }
                        var e = (pntB[0] - pntA[0]) / (pntB[1] - pntA[1]);
                        var f = (pntD[0] - pntC[0]) / (pntD[1] - pntC[1]);
                        var y = (e * pntA[1] - pntA[0] - f * pntC[1] + pntC[0]) / (e - f);
                        var x = e * y - e * pntA[1] + pntA[0];
                        return [x, y];
                    }
                }, {
                    key: "getBezierPoints",
                    value: function getBezierPoints(points) {
                        if (points.length <= 2) {
                            return points;
                        } else {
                            var bezierPoints = [];
                            var n = points.length - 1;
                            for (var t = 0; t <= 1; t += 0.01) {
                                var x = 0,
                                    y = 0;

                                for (var index = 0; index <= n; index++) {
                                    var factor = this.getBinomialFactor(n, index);
                                    var a = Math.pow(t, index);
                                    var b = Math.pow(1 - t, n - index);
                                    x += factor * a * b * points[index][0];
                                    y += factor * a * b * points[index][1];
                                }
                                bezierPoints.push([x, y]);
                            }
                            // bezierPoints.push(points[n]);
                            return bezierPoints;
                        }
                    }
                }, {
                    key: "getFactorial",
                    value: function getFactorial(n) {
                        var result = 1;
                        switch (n) {
                            case n <= 1:
                                result = 1;
                                break;
                            case n === 2:
                                result = 2;
                                break;
                            case n === 3:
                                result = 6;
                                break;
                            case n === 24:
                                result = 24;
                                break;
                            case n === 5:
                                result = 120;
                                break;
                            default:
                                for (var i = 1; i <= n; i++) {
                                    result *= i;
                                }
                                break;
                        }
                        return result;
                    }
                }, {
                    key: "getBinomialFactor",
                    value: function getBinomialFactor(n, index) {
                        return this.getFactorial(n) / (this.getFactorial(index) * this.getFactorial(n - index));
                    }
                }]);

                return PlotUtilClass;
            }();

            //外部使用，单例模式


            var plotUtil = exports.plotUtil = new PlotUtilClass();

            /***/
}),
/* 12 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.interPolygon = interPolygon;
            exports.getHeightRange = getHeightRange;
            exports.computeVolume = computeVolume;
            exports.updateVolume = updateVolume;
            exports.getEllipseOuterPositions = getEllipseOuterPositions;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //面内进行贴地(或贴模型)插值, 返回三角网等计算结果
            function interPolygon(opts) {
                var pos = opts.positions;
                var scene = opts.scene;

                var maxHeight = 0;
                var minHeight = 9999;
                var arrSJW = [];

                //复制数组
                var positions = [];
                for (var i = 0; i < pos.length; i++) {
                    positions.push(pos[i].clone());
                }

                var onlyHeight = Cesium.defaultValue(opts.onlyHeight, true); //只求高度,不需要返回点时
                var onlyPoint = Cesium.defaultValue(opts.onlyPoint, false); //只返回点，不需要三角网时

                //格式化每个点
                function onFormatPoint(position, opts) {
                    var height = (0, _point.getSurfaceHeight)(scene, position, opts);

                    var point;
                    var pointDM;
                    if (onlyHeight) {
                        var carto = Cesium.Cartographic.fromCartesian(position);
                        point = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
                        pointDM = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, height);
                    }

                    if (maxHeight < height) maxHeight = height;
                    if (minHeight > height) minHeight = height;

                    return {
                        height: height,
                        point: point,
                        pointDM: pointDM
                    };
                }

                var granularity = (0, _util.getGranularity)(positions, opts.splitNum); //splitNum分割的个数

                //插值求面的三角网   
                var polygonGeometry = new Cesium.PolygonGeometry.fromPositions({
                    positions: positions,
                    vertexFormat: Cesium.PerInstanceColorAppearance.FLAT_VERTEX_FORMAT,
                    granularity: granularity
                });
                var geom = new Cesium.PolygonGeometry.createGeometry(polygonGeometry);

                var i0, i1, i2;
                var cartesian1, cartesian2, cartesian3;
                var obj1, obj2, obj3;
                for (var i = 0; i < geom.indices.length; i += 3) {
                    i0 = geom.indices[i];
                    i1 = geom.indices[i + 1];
                    i2 = geom.indices[i + 2];

                    //三角形 点1
                    cartesian1 = new Cesium.Cartesian3(geom.attributes.position.values[i0 * 3], geom.attributes.position.values[i0 * 3 + 1], geom.attributes.position.values[i0 * 3 + 2]);
                    obj1 = onFormatPoint(cartesian1, opts);

                    //三角形 点2
                    cartesian2 = new Cesium.Cartesian3(geom.attributes.position.values[i1 * 3], geom.attributes.position.values[i1 * 3 + 1], geom.attributes.position.values[i1 * 3 + 2]);
                    obj2 = onFormatPoint(cartesian2, opts);

                    //三角形 点3
                    cartesian3 = new Cesium.Cartesian3(geom.attributes.position.values[i2 * 3], geom.attributes.position.values[i2 * 3 + 1], geom.attributes.position.values[i2 * 3 + 2]);
                    obj3 = onFormatPoint(cartesian3, opts);

                    if (onlyPoint) {
                        //只返回点，不需要三角网
                        addPointFoyArrOnly(arrSJW, obj1);
                        addPointFoyArrOnly(arrSJW, obj2);
                        addPointFoyArrOnly(arrSJW, obj3);
                    } else {
                        //常规返回，三角网
                        arrSJW.push({
                            point1: obj1,
                            point2: obj2,
                            point3: obj3
                        });
                    }
                }

                return {
                    granularity: granularity,
                    maxHeight: maxHeight,
                    minHeight: minHeight,
                    list: arrSJW //三角网 
                };
            }

            //判断坐标点是否在数组内
            function addPointFoyArrOnly(arr, newItem) {
                var isIn = false;
                var point = newItem.point;
                for (var z = 0; z < arr.length; z++) {
                    var item = arr[z].point;
                    if (point.x == item.x && point.y == item.y && point.z == item.z) {
                        isIn = true;
                        break;
                    }
                }
                if (!isIn) arr.push(newItem);
            }

            //计算面内最大、最小高度值
            function getHeightRange(positions, scene) {
                var resultInter = interPolygon({
                    positions: positions,
                    scene: scene,
                    onlyHeight: false
                });

                return {
                    maxHeight: resultInter.maxHeight,
                    minHeight: resultInter.minHeight
                };
            }

            //体积计算 
            function computeVolume(opts) {
                var resultInter = interPolygon(opts);

                var minHeight = resultInter.minHeight;
                // var maxHeight = resultInter.maxHeight

                var totalArea = 0; //总面积(横截面/投影底面)
                var totalVolume = 0; //总体积

                for (var i = 0, len = resultInter.list.length; i < len; i++) {
                    var item = resultInter.list[i];

                    var pt1 = item.point1;
                    var pt2 = item.point2;
                    var pt3 = item.point3;

                    //横截面面积 
                    var bottomArea = (0, _util.getAreaOfTriangle)(pt1.point, pt2.point, pt3.point);
                    item.area = bottomArea;
                    totalArea += bottomArea;

                    //概略挖方体积 （横截面面积 * 3个点的平均高） 
                    var cutVolume = bottomArea * (pt1.height - minHeight + pt2.height - minHeight + pt3.height - minHeight) / 3;
                    item.cutVolume = cutVolume;
                    totalVolume = totalVolume + cutVolume;
                }

                resultInter.totalArea = totalArea; //总面积(横截面/投影底面)
                resultInter.totalVolume = totalVolume; //总体积

                return resultInter;
            }

            //根据 基准面高度 重新计算填挖方体积 
            function updateVolume(resultInter, cutHeight) {
                if (!resultInter) return;

                var minHeight = resultInter.minHeight;
                var totalVolume = resultInter.totalVolume; //总体积

                if (cutHeight <= minHeight) {
                    resultInter.fillVolume = 0; //填方体积
                    resultInter.digVolume = totalVolume; //挖方体积

                    return resultInter;
                }

                var totalV = 0;
                var totalBottomV = 0;
                for (var i = 0, len = resultInter.list.length; i < len; i++) {
                    var item = resultInter.list[i];

                    var pt1 = item.point1;
                    var pt2 = item.point2;
                    var pt3 = item.point3;

                    var height1 = pt1.height;
                    var height2 = pt2.height;
                    var height3 = pt3.height;
                    if (height1 > cutHeight) height1 = cutHeight;
                    if (height2 > cutHeight) height2 = cutHeight;
                    if (height3 > cutHeight) height3 = cutHeight;

                    //概略挖方体积 （横截面面积 * 3个点的平均高）  
                    totalBottomV += item.area * (height1 - minHeight + height2 - minHeight + height3 - minHeight) / 3;
                    totalV += item.area * (cutHeight - minHeight);
                }

                resultInter.fillVolume = totalV - totalBottomV; //填方体积
                resultInter.digVolume = totalVolume - totalBottomV; //挖方体积

                return resultInter;
            }

            //获取圆（或椭圆）边线上的坐标点数组
            function getEllipseOuterPositions(opts) {
                var position = opts.position;

                var count = Cesium.defaultValue(opts.count, 1); //点的数量，总数为count*4
                var semiMajorAxis = Cesium.defaultValue(opts.semiMajorAxis, opts.radius);
                var semiMinorAxis = Cesium.defaultValue(opts.semiMinorAxis, opts.radius);
                var rotation = Cesium.defaultValue(opts.rotation, 0);

                //获取椭圆上的坐标点数组
                var cep = Cesium.EllipseGeometryLibrary.computeEllipsePositions({
                    center: position,
                    semiMajorAxis: semiMajorAxis, //长半轴
                    semiMinorAxis: semiMinorAxis, //短半轴
                    rotation: rotation,
                    granularity: Math.PI / (16 * count)
                }, true, true);

                var arr = cep.outerPositions;
                var positions = [];
                for (var i = 0, len = arr.length; i < len; i += 3) {
                    //长半轴上的坐标点
                    var pt = new Cesium.Cartesian3(arr[i], arr[i + 1], arr[i + 2]);
                    positions.push(pt);
                }
                return positions;
            }

            /***/
}),
/* 13 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.BaseLayer = undefined;

            var _MapVClass = __webpack_require__(23);

            var _util = __webpack_require__(1);

            var BaseLayer = _MapVClass.MapVClass.extend({
                config: {}, //配置的config信息 
                viewer: null,
                initialize: function initialize(cfg, viewer) {
                    this.viewer = viewer;
                    this.config = cfg;

                    this.name = cfg.name;
                    if (this.config.hasOwnProperty("alpha")) this._opacity = Number(this.config.alpha); else if (this.config.hasOwnProperty("opacity")) //兼容opacity参数来配置
                        this._opacity = Number(this.config.opacity);

                    if (this.config.hasOwnProperty("hasOpacity")) this.hasOpacity = this.config.hasOpacity;

                    this.create();
                    if (cfg.visible) this.setVisible(true); else this._visible = false;

                    if (cfg.visible && cfg.flyTo) {
                        this.centerAt(0);
                    }
                },
                create: function create() {
                    if (this.config.onCreate) {
                        this.config.onCreate(this.viewer);
                    }
                },
                showError: function showError(title, error) {
                    if (!error) error = '未知错误';

                    if (this.viewer) this.viewer.cesiumWidget.showErrorPanel(title, undefined, error);

                    console.log('layer错误:' + title + error);
                },
                //显示隐藏控制
                _visible: null,
                getVisible: function getVisible() {
                    return this._visible;
                },
                setVisible: function setVisible(val) {
                    if (this._visible != null && this._visible == val) return;
                    this._visible = val;

                    if (val) {
                        if (this.config.msg) (0, _util.msg)(this.config.msg);

                        this.add();
                    } else this.remove();
                },
                //添加 
                add: function add() {
                    this._visible = true;

                    if (this.config.onAdd) {
                        this.config.onAdd(this.viewer);
                    }
                },
                //移除
                remove: function remove() {
                    this._visible = false;

                    if (this.config.onRemove) {
                        this.config.onRemove(this.viewer);
                    }
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    if (this.config.extent || this.config.center) {
                        this.viewer.mapv.centerAt(this.config.extent || this.config.center, { duration: duration, isWgs84: true });
                    } else if (this.config.onCenterAt) {
                        this.config.onCenterAt(duration, this.viewer);
                    }
                },
                hasOpacity: false,
                _opacity: 1,
                //设置透明度
                setOpacity: function setOpacity(value) {
                    if (this.config.onSetOpacity) {
                        this.config.onSetOpacity(value, this.viewer);
                    }
                },
                hasZIndex: false,
                //设置叠加顺序
                setZIndex: function setZIndex(value) {
                    if (this.config.onSetZIndex) {
                        this.config.onSetZIndex(value, this.viewer);
                    }
                },
                destroy: function destroy() {
                    this.setVisible(false);
                }

            });

            exports.BaseLayer = BaseLayer;

            /***/
}),
/* 14 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPolyline = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(32);

            var _point = __webpack_require__(2);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            var _Tooltip = __webpack_require__(5);

            var _Attr = __webpack_require__(29);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(22);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPolyline = exports.DrawPolyline = _Draw.DrawBase.extend({
                type: 'polyline',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 9999, //最多允许点的个数
                //获取编辑对象   
                editClass: _Edit.EditPolyline,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
                    if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

                    if (attribute.config) {
                        //允许外部传入
                        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
                    } else {
                        this._minPointNum = this._minPointNum_def;
                        this._maxPointNum = this._maxPointNum_def;
                    }

                    var that = this;
                    var addattr = {
                        polyline: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    addattr.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        return that.getDrawPosition();
                    }, false);

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    this.entity._positions_draw = this._positions_draw;
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.polyline);
                },
                //绑定鼠标事件
                bindEvent: function bindEvent() {
                    var _this = this;

                    var lastPointTemporary = false;
                    this.getHandler().setInputAction(function (event) {
                        //单击添加点
                        var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.position, _this.entity);
                        if (point) {
                            if (lastPointTemporary) {
                                _this._positions_draw.pop();
                            }
                            lastPointTemporary = false;

                            //在绘制点基础自动增加高度
                            if (_this.entity.attribute && _this.entity.attribute.config && _this.entity.attribute.config.addHeight) point = (0, _point.addPositionsHeight)(point, _this.entity.attribute.config.addHeight);

                            _this._positions_draw.push(point);
                            _this.updateAttrForDrawing();

                            _this.fire(EventType.DrawAddPoint, { drawtype: _this.type, entity: _this.entity, position: point, positions: _this._positions_draw });

                            if (_this._positions_draw.length >= _this._maxPointNum) {
                                //点数满足最大数量，自动结束
                                _this.disable();
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                    this.getHandler().setInputAction(function (event) {
                        //右击删除上一个点
                        _this._positions_draw.pop(); //删除最后标的一个点

                        var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.position, _this.entity);
                        if (point) {
                            if (lastPointTemporary) {
                                _this._positions_draw.pop();
                            }
                            lastPointTemporary = true;

                            _this.fire(EventType.DrawRemovePoint, { drawtype: _this.type, entity: _this.entity, position: point, positions: _this._positions_draw });

                            _this._positions_draw.push(point);
                            _this.updateAttrForDrawing();
                        }
                    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

                    this.getHandler().setInputAction(function (event) {
                        //鼠标移动

                        if (_this._positions_draw.length <= 1) _this.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.start); else if (_this._positions_draw.length < _this._minPointNum) //点数不满足最少数量
                            _this.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.cont); else if (_this._positions_draw.length >= _this._maxPointNum) //点数满足最大数量
                            _this.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end2); else _this.tooltip.showAt(event.endPosition, _Tooltip.message.draw.polyline.end);

                        var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.endPosition, _this.entity);
                        if (point) {
                            if (lastPointTemporary) {
                                _this._positions_draw.pop();
                            }
                            lastPointTemporary = true;

                            _this._positions_draw.push(point);
                            _this.updateAttrForDrawing();

                            _this.fire(EventType.DrawMouseMove, { drawtype: _this.type, entity: _this.entity, position: point, positions: _this._positions_draw });
                        }
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    this.getHandler().setInputAction(function (event) {
                        //双击结束标绘
                        //必要代码 消除双击带来的多余经纬度 
                        _this._positions_draw.pop();
                        _this.endDraw();
                    }, Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                },
                //外部控制，完成绘制，比如手机端无法双击结束
                endDraw: function endDraw() {
                    if (!this._enabled) {
                        return this;
                    }

                    if (this._positions_draw.length < this._minPointNum) return; //点数不够
                    this.updateAttrForDrawing();
                    this.disable();
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }

            });

            /***/
}),
/* 15 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.setFillMaterial = setFillMaterial;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _LineFlowMaterial = __webpack_require__(36);

            var _CircleWaveMaterial = __webpack_require__(47);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function setFillMaterial(entityattr, style) {
                if (style.material) {
                    //material属性优先
                    entityattr.material = style.material;
                    return entityattr;
                }

                if (style.color || style.fillType) {
                    var color = new Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));

                    switch (style.fillType) {
                        default:
                        case "color":
                            //纯色填充 
                            entityattr.material = color;
                            break;
                        case "image":
                            //图片填充  
                            entityattr.material = new Cesium.ImageMaterialProperty({
                                image: style.image,
                                color: new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)))
                            });
                            break;
                        case "grid":
                            //网格
                            var lineCount = Cesium.defaultValue(style.grid_lineCount, 8);
                            var lineThickness = Cesium.defaultValue(style.grid_lineThickness, 2.0);
                            entityattr.material = new Cesium.GridMaterialProperty({
                                color: color,
                                cellAlpha: Cesium.defaultValue(style.grid_cellAlpha, 0.1),
                                lineCount: new Cesium.Cartesian2(lineCount, lineCount),
                                lineThickness: new Cesium.Cartesian2(lineThickness, lineThickness)
                            });
                            break;
                        case "checkerboard":
                            //棋盘 
                            var repeat = Cesium.defaultValue(style.checkerboard_repeat, 4);
                            entityattr.material = new Cesium.CheckerboardMaterialProperty({
                                evenColor: color,
                                oddColor: new Cesium.Color.fromCssColorString(style.checkerboard_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                                repeat: new Cesium.Cartesian2(repeat, repeat)
                            });
                            break;
                        case "stripe":
                            // 条纹 
                            entityattr.material = new Cesium.StripeMaterialProperty({
                                evenColor: color,
                                oddColor: new Cesium.Color.fromCssColorString(style.stripe_oddcolor || "#ffffff").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                                repeat: Cesium.defaultValue(style.stripe_repeat, 6)
                            });
                            break;
                        case "animationLine":
                            //流动线 
                            entityattr.material = new _LineFlowMaterial.LineFlowMaterial({ //动画线材质
                                color: color,
                                duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
                                url: style.animationImage, //图片
                                repeat: new Cesium.Cartesian2(style.animationRepeatX || 1, style.animationRepeatY || 1),
                                axisY: style.animationAxisY,
                                bgUrl: style.bgUrl,
                                bgColor: style.bgColor ? new Cesium.Color.fromCssColorString(style.bgColor) : null
                            });
                            break;
                        case "animationCircle":
                            //动态圆 
                            entityattr.material = new _CircleWaveMaterial.CircleWaveMaterial({
                                duration: Cesium.defaultValue(style.animationDuration, 2000), //时长，控制速度
                                color: new Cesium.Color.fromCssColorString(style.color || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0))),
                                gradient: Cesium.defaultValue(style.animationGradient, 0),
                                count: Cesium.defaultValue(style.animationCount, 1)
                            });
                            break;
                    }
                }

                //如果未设置任何material，默认设置随机颜色
                if (entityattr.material == null || style.randomColor) {
                    entityattr.material = Cesium.Color.fromRandom({
                        minimumRed: Cesium.defaultValue(style.minimumRed, 0.0),
                        maximumRed: Cesium.defaultValue(style.maximumRed, 0.75),
                        minimumGreen: Cesium.defaultValue(style.minimumGreen, 0.0),
                        maximumGreen: Cesium.defaultValue(style.maximumGreen, 0.75),
                        minimumBlue: Cesium.defaultValue(style.minimumBlue, 0.0),
                        maximumBlue: Cesium.defaultValue(style.maximumBlue, 0.75),
                        alpha: Cesium.defaultValue(style.opacity, 1.0)
                    });
                }

                return entityattr;
            } //通用处理方法

            /***/
}),
/* 16 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr, textAttr) {
                style = style || {};
                if (entityattr == null) {
                    //默认值
                    entityattr = {
                        scale: 1.0,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                    };
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "font_style": //跳过扩展其他属性的参数
                        case "font_weight":
                        case "font_size":
                        case "font_family":
                        case "scaleByDistance_near":
                        case "scaleByDistance_nearValue":
                        case "scaleByDistance_far":
                        case "scaleByDistance_farValue":
                        case "distanceDisplayCondition_far":
                        case "distanceDisplayCondition_near":
                        case "background_opacity":
                        case "pixelOffsetY":
                            break;

                        case "text":
                            //文字内容
                            if (textAttr) {
                                //存在属性时，采用格式化字符串
                                value = (0, _util.template)(value, textAttr);
                            }
                            entityattr.text = value.replace(new RegExp("<br />", "gm"), "\n");
                            break;
                        case "color":
                            //颜色
                            entityattr.fillColor = new Cesium.Color.fromCssColorString(value || "#ffffff").withAlpha(Number(style.opacity || 1.0));
                            break;

                        case "border":
                            //是否衬色
                            entityattr.style = value ? Cesium.LabelStyle.FILL_AND_OUTLINE : Cesium.LabelStyle.FILL;
                            break;
                        case "border_color":
                            //衬色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "border_width":
                            entityattr.outlineWidth = value;
                            break;
                        case "background":
                            //是否背景色
                            entityattr.showBackground = value;
                            break;
                        case "background_color":
                            //背景色
                            entityattr.backgroundColor = new Cesium.Color.fromCssColorString(value || "#000000").withAlpha(Number(style.background_opacity || style.opacity || 0.5));
                            break;
                        case "pixelOffset":
                            //偏移量
                            entityattr.pixelOffset = new Cesium.Cartesian2(style.pixelOffset[0], style.pixelOffset[1]);
                            break;
                        case "hasPixelOffset":
                            //是否存在偏移量
                            if (!value) entityattr.pixelOffset = new Cesium.Cartesian2(0, 0);
                            break;
                        case "pixelOffsetX":
                            //偏移量
                            entityattr.pixelOffset = new Cesium.Cartesian2(value, style.pixelOffsetY);
                            break;
                        case "scaleByDistance":
                            //是否按视距缩放
                            if (value) {
                                entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
                            } else {
                                entityattr.scaleByDistance = undefined;
                            }
                            break;
                        case "distanceDisplayCondition":
                            //是否按视距显示
                            if (value) {
                                entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(style.distanceDisplayCondition_near || 0), Number(style.distanceDisplayCondition_far || 100000));
                            } else {
                                entityattr.distanceDisplayCondition = undefined;
                            }
                            break;

                        case "clampToGround":
                            //贴地
                            if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND; else entityattr.heightReference = Cesium.HeightReference.NONE;
                            break;
                        case "heightReference":
                            switch (value) {
                                case "NONE":
                                    entityattr.heightReference = Cesium.HeightReference.NONE;
                                    break;
                                case "CLAMP_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                                    break;
                                case "RELATIVE_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                    break;
                                default:
                                    entityattr.heightReference = value;
                                    break;
                            }
                            break;

                        case "visibleDepth":
                            if (value) entityattr.disableDepthTestDistance = 0; else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                            break;

                    }
                }

                //样式（倾斜、加粗等）
                var fontStyle = (style.font_style || "normal") + " small-caps " + (style.font_weight || "normal") + " " + (style.font_size || "25") + "px " + (style.font_family || "楷体");
                entityattr.font = fontStyle;

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 17 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getHeadingPitchRollByOrientation = getHeadingPitchRollByOrientation;
            exports.getHeadingPitchRollByMatrix = getHeadingPitchRollByMatrix;
            exports.getHeadingPitchRollByMatrixOld = getHeadingPitchRollByMatrixOld;
            exports.getHeadingPitchRollForLine = getHeadingPitchRollForLine;
            exports.getRotateCenterPoint = getRotateCenterPoint;
            exports.getOnLinePointByLen = getOnLinePointByLen;
            exports.getPositionTranslation = getPositionTranslation;
            exports.getOffsetLine = getOffsetLine;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var matrix3Scratch = new Cesium.Matrix3(); //一些涉及矩阵计算的方法

            var matrix4Scratch = new Cesium.Matrix4();

            // 根据模型的orientation求方位角
            function getHeadingPitchRollByOrientation(position, orientation, ellipsoid, fixedFrameTransform) {
                if (!Cesium.defined(orientation) || !Cesium.defined(position)) return new Cesium.HeadingPitchRoll();

                var matrix = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4Scratch);
                var hpr = getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform);
                return hpr;
            }

            // 根据模型的matrix矩阵求方位角 
            function getHeadingPitchRollByMatrix(matrix, ellipsoid, fixedFrameTransform, result) {
                return Cesium.Transforms.fixedFrameToHeadingPitchRoll(matrix, ellipsoid, fixedFrameTransform, result);
            }

            // 根据模型的matrix矩阵求方位角 
            function getHeadingPitchRollByMatrixOld(position, matrix, ellipsoid, fixedFrameTransform) {
                fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

                // 计算当前模型中心处的变换矩阵
                var m1 = fixedFrameTransform(position, ellipsoid, new Cesium.Matrix4());
                // 矩阵相除
                var m3 = Cesium.Matrix4.multiply(Cesium.Matrix4.inverse(m1, new Cesium.Matrix4()), matrix, new Cesium.Matrix4());
                // 得到旋转矩阵
                var mat3 = Cesium.Matrix4.getMatrix3(m3, new Cesium.Matrix3());
                // 计算四元数
                var q = Cesium.Quaternion.fromRotationMatrix(mat3);
                // 计算旋转角(弧度)
                var hpr = Cesium.HeadingPitchRoll.fromQuaternion(q);
                return hpr;
            }

            var cartesian3 = new Cesium.Cartesian3();
            var matrix4Scratch = new Cesium.Matrix4();
            var rotationScratch = new Cesium.Matrix3();

            //求localStart点到localEnd点的方向
            function getHeadingPitchRollForLine(localStart, localEnd, ellipsoid, fixedFrameTransform) {
                ellipsoid = ellipsoid || Cesium.Ellipsoid.WGS84;

                var velocity = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(localEnd, localStart, cartesian3), cartesian3);
                Cesium.Transforms.rotationMatrixFromPositionVelocity(localStart, velocity, ellipsoid, rotationScratch);
                var modelMatrix = Cesium.Matrix4.fromRotationTranslation(rotationScratch, localStart, matrix4Scratch);

                Cesium.Matrix4.multiplyTransformation(modelMatrix, Cesium.Axis.Z_UP_TO_X_UP, modelMatrix);

                var hpr = getHeadingPitchRollByMatrix(modelMatrix, ellipsoid, fixedFrameTransform);
                return hpr;
            }

            //获取点point1绕点center的地面法向量旋转顺时针angle角度后新坐标
            function getRotateCenterPoint(center, point1, angle) {
                // 计算center的地面法向量
                var chicB = Cesium.Cartographic.fromCartesian(center);
                chicB.height = 0;
                var dB = Cesium.Cartographic.toCartesian(chicB);
                var normaB = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(dB, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());

                // 构造基于center的法向量旋转90度的矩阵
                var Q = Cesium.Quaternion.fromAxisAngle(normaB, Cesium.Math.toRadians(angle));
                var m3 = Cesium.Matrix3.fromQuaternion(Q);
                var m4 = Cesium.Matrix4.fromRotationTranslation(m3);

                // 计算point1点相对center点的坐标A1
                var A1 = Cesium.Cartesian3.subtract(point1, center, new Cesium.Cartesian3());

                //对A1应用旋转矩阵
                var p = Cesium.Matrix4.multiplyByPoint(m4, A1, new Cesium.Cartesian3());
                // 新点的坐标
                var pointNew = Cesium.Cartesian3.add(p, center, new Cesium.Cartesian3());

                return pointNew;
            }

            //求p1指向p2方向线上，指定len长度的新的点  
            function getOnLinePointByLen(p1, p2, len) {
                var mtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(p1);
                var mtx4_inverser = Cesium.Matrix4.inverse(mtx4, new Cesium.Matrix4());
                p1 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p1, new Cesium.Cartesian3());
                p2 = Cesium.Matrix4.multiplyByPoint(mtx4_inverser, p2, new Cesium.Cartesian3());

                var substrct = Cesium.Cartesian3.subtract(p2, p1, new Cesium.Cartesian3());

                var dis = Cesium.Cartesian3.distance(p1, p2);
                var scale = len / dis; //求比例

                var newP = Cesium.Cartesian3.multiplyByScalar(substrct, scale, new Cesium.Cartesian3());
                newP = Cesium.Matrix4.multiplyByPoint(mtx4, newP, new Cesium.Cartesian3());
                return newP;
            }

            //获取点的offest平移矩阵后点
            function getPositionTranslation(position, offest, degree, type, fixedFrameTransform) {
                fixedFrameTransform = fixedFrameTransform || Cesium.Transforms.eastNorthUpToFixedFrame;

                var rotate = Cesium.Math.toRadians(-Cesium.defaultValue(degree, 0)); //转成弧度

                type = (type || "z").toUpperCase();
                var _normal = Cesium.Cartesian3["UNIT_" + type];

                var quaternion = Cesium.Quaternion.fromAxisAngle(_normal, rotate); //quaternion为围绕这个z轴旋转d度的四元数
                var rotateMatrix3 = Cesium.Matrix3.fromQuaternion(quaternion); //rotateMatrix3为根据四元数求得的旋转矩阵

                var pointCartesian3 = new Cesium.Cartesian3(Cesium.defaultValue(offest.x, 0), Cesium.defaultValue(offest.y, 0), Cesium.defaultValue(offest.z, 0)); //point的局部坐标
                var rotateTranslationMatrix4 = Cesium.Matrix4.fromRotationTranslation(rotateMatrix3, Cesium.Cartesian3.ZERO); //rotateTranslationMatrix4为旋转加平移的4x4变换矩阵，这里平移为(0,0,0)，故填个Cesium.Cartesian3.ZERO
                Cesium.Matrix4.multiplyByTranslation(rotateTranslationMatrix4, pointCartesian3, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4  X  pointCartesian3
                var originPositionCartesian3 = Cesium.Ellipsoid.WGS84.cartographicToCartesian(Cesium.Cartographic.fromCartesian(position)); //得到局部坐标原点的全局坐标
                var originPositionTransform = fixedFrameTransform(originPositionCartesian3); //m1为局部坐标的z轴垂直于地表，局部坐标的y轴指向正北的4x4变换矩阵
                Cesium.Matrix4.multiplyTransformation(originPositionTransform, rotateTranslationMatrix4, rotateTranslationMatrix4); //rotateTranslationMatrix4 = rotateTranslationMatrix4 X originPositionTransform
                var pointCartesian = new Cesium.Cartesian3();
                Cesium.Matrix4.getTranslation(rotateTranslationMatrix4, pointCartesian); //根据最终变换矩阵m得到p2
                return pointCartesian;
            }

            //计算平行线，offset正负决定方向（单位米）
            function getOffsetLine(positions, offset) {
                var arrNew = [];
                for (var i = 1; i < positions.length; i++) {
                    var point1 = positions[i - 1];
                    var point2 = positions[i];

                    var dir12 = Cesium.Cartesian3.subtract(point1, point2, new Cesium.Cartesian3());
                    var dir21left = Cesium.Cartesian3.cross(point1, dir12, new Cesium.Cartesian3());

                    var p1offset = computedOffsetData(point1, dir21left, offset * 1000);
                    var p2offset = computedOffsetData(point2, dir21left, offset * 1000);

                    if (i == 1) {
                        arrNew.push(p1offset);
                    }
                    arrNew.push(p2offset);
                }
                return arrNew;
            }

            function computedOffsetData(ori, dir, wid) {
                var currRay = new Cesium.Ray(ori, dir);
                return Cesium.Ray.getPoint(currRay, wid, new Cesium.Cartesian3());
            }

            /***/
}),
/* 18 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            //事件类型

            var DrawStart = exports.DrawStart = 'draw-start'; //开始绘制
            var DrawAddPoint = exports.DrawAddPoint = 'draw-add-point'; //绘制过程中增加了点
            var DrawRemovePoint = exports.DrawRemovePoint = 'draw-remove-lastpoint'; //绘制过程中删除了last点
            var DrawMouseMove = exports.DrawMouseMove = 'draw-mouse-move'; //绘制过程中鼠标移动了点
            var DrawCreated = exports.DrawCreated = 'draw-created'; //创建完成


            var EditStart = exports.EditStart = 'edit-start'; //开始编辑
            var EditMovePoint = exports.EditMovePoint = 'edit-move-point'; //编辑修改了点
            var EditRemovePoint = exports.EditRemovePoint = 'edit-remove-point'; //编辑删除了点
            var EditStop = exports.EditStop = 'edit-stop'; //停止编辑

            var Delete = exports.Delete = 'delete'; //删除对象

            /***/
}),
/* 19 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "color": //跳过扩展其他属性的参数
                        case "opacity":
                        case "outlineOpacity":

                        case "grid_lineCount":
                        case "grid_lineThickness":
                        case "grid_cellAlpha":
                        case "checkerboard_repeat":
                        case "checkerboard_oddcolor":
                        case "stripe_oddcolor":
                        case "stripe_repeat":
                        case "animationDuration":
                        case "animationImage":
                        case "animationRepeatX":
                        case "animationRepeatY":
                        case "animationAxisY":
                        case "animationGradient":
                        case "animationCount":
                        case "randomColor":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || style.color || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                            break;
                        case "extrudedHeight":
                            //高度 
                            var maxHight = 0;
                            if (entityattr.hierarchy) {
                                var positions = getPositions({ polygon: entityattr });
                                maxHight = (0, _point.getMaxHeight)(positions);
                            }
                            entityattr.extrudedHeight = Number(value) + maxHight;
                            break;
                        case "clampToGround":
                            //贴地
                            entityattr.perPositionHeight = !value;
                            break;
                        case "stRotation":
                            //材质旋转角度 
                            entityattr.stRotation = Cesium.Math.toRadians(value);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity, isShowPositions) {
                if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //箭头标绘等情形时，取绑定的数据

                var arr = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
                if (arr && arr instanceof Cesium.PolygonHierarchy) return arr.positions;
                return arr;
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity, noAdd) {
                var coordinates = getCoordinates(entity);

                if (!noAdd && coordinates.length > 0) coordinates.push(coordinates[0]);

                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "Polygon",
                        coordinates: [coordinates]
                    }
                };
            }

            /***/
}),
/* 20 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.hasTerrain = hasTerrain;
            exports.getEllipsoidTerrain = getEllipsoidTerrain;
            exports.getTerrainProvider = getTerrainProvider;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _BaseLayer = __webpack_require__(13);

            var _GroupLayer = __webpack_require__(83);

            var _TileLayer = __webpack_require__(48);

            var _GraticuleLayer = __webpack_require__(84);

            var _CustomFeatureGridLayer = __webpack_require__(37);

            var _POILayer = __webpack_require__(86);

            var _WFSLayer = __webpack_require__(87);

            var _GeoJsonLayer = __webpack_require__(39);

            var _GltfLayer = __webpack_require__(88);

            var _Tiles3dLayer = __webpack_require__(89);

            var _KmlLayer = __webpack_require__(90);

            var _CzmlLayer = __webpack_require__(91);

            var _TerrainLayer = __webpack_require__(92);

            var _DrawLayer = __webpack_require__(93);

            var _BaiduImageryProvider = __webpack_require__(94);

            var _FeatureGridImageryProvider = __webpack_require__(95);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            exports.BaseLayer = _BaseLayer.BaseLayer;

            exports.GroupLayer = _GroupLayer.GroupLayer;

            exports.TileLayer = _TileLayer.TileLayer;

            exports.GraticuleLayer = _GraticuleLayer.GraticuleLayer;

            exports.CustomFeatureGridLayer = _CustomFeatureGridLayer.CustomFeatureGridLayer;

            exports.POILayer = _POILayer.POILayer;

            exports.WFSLayer = _WFSLayer.WFSLayer;

            exports.GeoJsonLayer = _GeoJsonLayer.GeoJsonLayer;

            exports.GltfLayer = _GltfLayer.GltfLayer;

            exports.Tiles3dLayer = _Tiles3dLayer.Tiles3dLayer;

            exports.KmlLayer = _KmlLayer.KmlLayer;

            exports.CzmlLayer = _CzmlLayer.CzmlLayer;

            exports.TerrainLayer = _TerrainLayer.TerrainLayer;

            exports.DrawLayer = _DrawLayer.DrawLayer;

            exports.BaiduImageryProvider = _BaiduImageryProvider.BaiduImageryProvider;

            exports.FeatureGridImageryProvider = _FeatureGridImageryProvider.FeatureGridImageryProvider;

            //类库外部的类
            var exLayer = {};
            exports.regLayerForConfig = function (type, layerClass) {
                exLayer[type] = layerClass;
            };

            //创建图层
            exports.createLayer = function createLayer(item, viewer, serverURL) {
                var layer;

                if (item.url) {
                    if (serverURL) {
                        item.url = item.url.replace('$serverURL$', serverURL);
                    }
                    item.url = item.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
                }

                switch (item.type) {
                    //===============地图数组====================
                    case "group":
                        //示例：{ "name": "电子地图", "type": "group","layers": [    ]}
                        if (item.layers && item.layers.length > 0) {
                            var arrVec = [];
                            for (var index = 0; index < item.layers.length; index++) {
                                var temp = createLayer(item.layers[index], viewer, serverURL);
                                if (temp == null) continue;
                                arrVec.push(temp);
                            }
                            var newItem = {};
                            for (var key in item) {
                                newItem[key] = item[key];
                            }
                            newItem._layers = arrVec;
                            layer = new _GroupLayer.GroupLayer(newItem, viewer);
                        }
                        break;
                    case "base":
                        layer = new _BaseLayer.BaseLayer(item, viewer);
                        break;
                    case "www_bing": //bing地图 
                    case "www_osm": //OSM开源地图 
                    case "www_google": //谷歌国内
                    case "www_gaode": //高德
                    case "www_baidu": //百度 
                    case "www_tdt": //天地图
                    case "mapbox":
                    case "www_mapbox":
                    case "mapboxstyle":
                    case "www_mapboxstyle":
                    case "arcgis_cache":
                    case "arcgis":
                    case "arcgis_tile":
                    case "arcgis_dynamic":
                    case "sm_img": //超图底图支持
                    case "supermap_img":
                    case "wmts":
                    case "tms":
                    case "wms":
                    case "xyz":
                    case "tile":
                    case "single":
                    case "image":
                    case "gee":
                    case "custom_tilecoord": //瓦片信息
                    case "custom_grid":
                        //网格线 
                        //瓦片图层
                        layer = new _TileLayer.TileLayer(item, viewer);
                        layer.isTile = true;
                        break;
                    case "www_poi":
                        //在线poi数据
                        layer = new _POILayer.POILayer(item, viewer);
                        break;
                    case "custom_featuregrid":
                        //自定义矢量网格图层 
                        layer = new _CustomFeatureGridLayer.CustomFeatureGridLayer(item, viewer);
                        break;
                    case "custom_graticule":
                        layer = new _GraticuleLayer.GraticuleLayer(item, viewer);
                        break;

                    case "3dtiles":
                        layer = new _Tiles3dLayer.Tiles3dLayer(item, viewer);
                        break;
                    case "gltf":
                        layer = new _GltfLayer.GltfLayer(item, viewer);
                        break;
                    case "geojson":
                        layer = new _GeoJsonLayer.GeoJsonLayer(item, viewer);
                        break;
                    case "geojson-draw":
                        //基于框架内部draw绘制保存的geojson数据的加载
                        layer = new _DrawLayer.DrawLayer(item, viewer);
                        break;
                    case "kml":
                        layer = new _KmlLayer.KmlLayer(item, viewer);
                        break;
                    case "czml":
                        layer = new _CzmlLayer.CzmlLayer(item, viewer);
                        break;
                    case "wfs":
                        layer = new _WFSLayer.WFSLayer(item, viewer);
                        break;
                    case "terrain":
                        layer = new _TerrainLayer.TerrainLayer(item, viewer);
                        break;
                    default:
                        if (exLayer[item.type]) {
                            layer = new exLayer[item.type](item, viewer);
                        }
                        if (layer == null) {
                            try {
                                console.log("配置中的图层未处理：" + JSON.stringify(item));
                            } catch (e) { }
                        }
                        break;
                }

                return layer;
            };

            //创建地图底图
            exports.createImageryProvider = function (item, serverURL) {
                if (item.url) {
                    if (serverURL) {
                        item.url = item.url.replace('$serverURL$', serverURL);
                    }
                    item.url = item.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
                }

                var opts = {};
                for (var key in item) {
                    var value = item[key];
                    if (value == null) continue;

                    switch (key) {
                        default:
                            //直接赋值
                            opts[key] = value;
                            break;
                        case "crs":
                            value = (value + "").toUpperCase();
                            if (value == "4326" || value == "EPSG4326" || value == "EPSG:4326") {
                                opts.tilingScheme = new Cesium.GeographicTilingScheme({
                                    numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
                                    numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                                });
                            } else if (value == "4490" || value == "EPSG4490" || value == "EPSG:4490") {
                                opts.tilingScheme = new Cesium.GeographicTilingScheme({
                                    numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 2,
                                    numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                                });
                                opts.is4490 = true;
                            } else {
                                opts.tilingScheme = new Cesium.WebMercatorTilingScheme({
                                    numberOfLevelZeroTilesX: item.numberOfLevelZeroTilesX || 1,
                                    numberOfLevelZeroTilesY: item.numberOfLevelZeroTilesY || 1
                                });
                            }
                            break;
                        case "rectangle":
                            opts.rectangle = Cesium.Rectangle.fromDegrees(value.xmin, value.ymin, value.xmax, value.ymax);
                            break;
                    }
                }

                //4490坐标系z值是+1的
                if (opts.is4490 && opts.url) {
                    opts.url = opts.url.replace('{z}', '{z4490}');
                    opts.url = opts.url.replace('{arc_z}', '{arc_z4490}');
                    opts.url = opts.url.replace('{arc_Z}', '{arc_Z4490}');
                }

                if (opts.url && opts.proxy) {
                    opts = (0, _util.getProxyUrl)(opts);
                }

                var layer;
                switch (opts.type_new || opts.type) {
                    //===============地图底图==================== 
                    case "single":
                    case "image":
                        layer = new Cesium.SingleTileImageryProvider(opts);
                        break;
                    case "xyz":
                    case "tile":
                        opts.customTags = opts.customTags || {};
                        opts.customTags["z4490"] = function (imageryProvider, x, y, level) {
                            return level + 1;
                        };
                        layer = new Cesium.UrlTemplateImageryProvider(opts);
                        break;
                    case "wms":
                        layer = new Cesium.WebMapServiceImageryProvider(opts);
                        break;
                    case "tms":
                        if (!opts.url) opts.url = Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII');
                        layer = new Cesium.TileMapServiceImageryProvider(opts);
                        break;
                    case "wmts":
                        layer = new Cesium.WebMapTileServiceImageryProvider(opts);
                        break;
                    case "gee":
                        //谷歌地球
                        layer = new Cesium.GoogleEarthEnterpriseImageryProvider({
                            metadata: new Cesium.GoogleEarthEnterpriseMetadata(opts)
                        });
                        break;
                    case "mapbox": //mapbox
                    case "www_mapbox":
                        layer = new Cesium.MapboxImageryProvider(opts);
                        break;
                    case "mapboxstyle":
                    case "www_mapboxstyle":
                        layer = new Cesium.MapboxStyleImageryProvider(opts);
                        break;
                    case "arcgis":
                    case "arcgis_tile":
                    case "arcgis_dynamic":
                        layer = new Cesium.ArcGisMapServerImageryProvider(opts);
                        break;
                    case "sm_img": //超图底图支持
                    case "supermap_img":
                        layer = new Cesium.SuperMapImageryProvider(opts);
                        break;
                    case "arcgis_cache":
                        // 示例 /google/_alllayers/L{arc_z}/R{arc_y}/C{arc_x}.jpg
                        if (!Cesium.UrlTemplateImageryProvider.prototype.padLeft0) {
                            Cesium.UrlTemplateImageryProvider.prototype.padLeft0 = function (numStr, n) {
                                numStr = String(numStr);
                                var len = numStr.length;
                                while (len < n) {
                                    numStr = "0" + numStr;
                                    len++;
                                }
                                return numStr;
                            };
                        }
                        opts.customTags = {
                            //小写
                            "arc_x": function arc_x(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(x.toString(16), 8);
                            },
                            "arc_y": function arc_y(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(y.toString(16), 8);
                            },
                            "arc_z": function arc_z(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(level.toString(), 2);
                            },
                            "arc_z4490": function arc_z4490(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0((level + 1).toString(), 2);
                            },
                            //大写
                            "arc_X": function arc_X(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(x.toString(16), 8).toUpperCase();
                            },
                            "arc_Y": function arc_Y(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(y.toString(16), 8).toUpperCase();
                            },
                            "arc_Z": function arc_Z(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0(level.toString(), 2).toUpperCase();
                            },
                            "arc_Z4490": function arc_Z4490(imageryProvider, x, y, level) {
                                return imageryProvider.padLeft0((level + 1).toString(), 2).toUpperCase();
                            }
                        };

                        layer = new Cesium.UrlTemplateImageryProvider(opts);
                        break;

                    //===============互联网常用地图==================== 

                    case "www_tdt":
                        //天地图
                        var _layer;
                        var maxLevel = 18;
                        switch (opts.layer) {
                            default:
                            case "vec_d":
                                _layer = "vec";
                                break;
                            case "vec_z":
                                _layer = "cva";
                                break;
                            case "img_d":
                                _layer = "img";
                                break;
                            case "img_z":
                                _layer = "cia";
                                break;
                            case "ter_d":
                                _layer = "ter";
                                maxLevel = 14;
                                break;
                            case "ter_z":
                                _layer = "cta";
                                maxLevel = 14;
                                break;
                        }

                        var _key;
                        if (opts.key == null || opts.key.length == 0) _key = '87949882c75775b5069a0076357b7530'; //默认
                        else _key = getOneKey(opts.key);

                        if (item.crs == '4326') {
                            //wgs84   
                            var matrixIds = new Array(maxLevel);
                            for (var z = 0; z <= maxLevel; z++) {
                                matrixIds[z] = (z + 1).toString();
                            }
                            var _url = '//t{s}.tianditu.gov.cn/' + _layer + '_c/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=' + _layer + '&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=' + _key;

                            if (opts.proxy) //存在代理时
                                _url = (0, _util.getProxyUrl)({ url: _url.replace('{s}', '0'), proxy: opts.proxy }).url;

                            layer = new Cesium.WebMapTileServiceImageryProvider({
                                url: _url,
                                layer: _layer,
                                style: 'default',
                                format: 'tiles',
                                tileMatrixSetID: 'c',
                                subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
                                tileMatrixLabels: matrixIds,
                                tilingScheme: new Cesium.GeographicTilingScheme(), //WebMercatorTilingScheme、GeographicTilingScheme
                                maximumLevel: maxLevel
                            });
                        } else {
                            //墨卡托  
                            var matrixIds = new Array(maxLevel);
                            for (var z = 0; z <= maxLevel; z++) {
                                matrixIds[z] = z.toString();
                            }
                            var _url = '//t{s}.tianditu.gov.cn/' + _layer + '_w/wmts?service=WMTS&version=1.0.0&request=GetTile&tilematrix={TileMatrix}&layer=' + _layer + '&style={style}&tilerow={TileRow}&tilecol={TileCol}&tilematrixset={TileMatrixSet}&format=tiles&tk=' + _key;

                            if (opts.proxy) //存在代理时
                                _url = (0, _util.getProxyUrl)({ url: _url.replace('{s}', '0'), proxy: opts.proxy }).url;

                            layer = new Cesium.WebMapTileServiceImageryProvider({
                                url: _url,
                                layer: _layer,
                                style: 'default',
                                format: 'tiles',
                                tileMatrixSetID: 'w',
                                subdomains: ['0', '1', '2', '3', '4', '5', '6', '7'],
                                tileMatrixLabels: matrixIds,
                                tilingScheme: new Cesium.WebMercatorTilingScheme(),
                                maximumLevel: maxLevel
                            });
                        }
                        break;
                    case "www_gaode":
                        //高德
                        var _url;
                        switch (opts.layer) {
                            case "vec":
                            default:
                                //style=7是立体的，style=8是灰色平面的
                                _url = '//' + (opts.bigfont ? 'wprd' : 'webrd') + '0{s}.is.autonavi.com/appmaptile?lang=zh_cn&size=1&scale=1&style=7&x={x}&y={y}&z={z}';
                                break;
                            case "img_d":
                                _url = '//webst0{s}.is.autonavi.com/appmaptile?style=6&x={x}&y={y}&z={z}';
                                break;
                            case "img_z":
                                _url = '//webst0{s}.is.autonavi.com/appmaptile?x={x}&y={y}&z={z}&lang=zh_cn&size=1&scale=1&style=8';
                                break;
                            case "time":
                                var time = new Date().getTime();
                                _url = '//tm.amap.com/trafficengine/mapabc/traffictile?v=1.0&;t=1&x={x}&y={y}&z={z}&&t=' + time;
                                break;
                        }

                        if (opts.proxy) //存在代理时
                            _url = (0, _util.getProxyUrl)({ url: _url.replace('{s}', '1'), proxy: opts.proxy }).url;

                        layer = new Cesium.UrlTemplateImageryProvider({
                            url: _url,
                            subdomains: ['1', '2', '3', '4'],
                            maximumLevel: 18
                        });
                        break;
                    case "www_baidu":
                        //百度
                        layer = new _BaiduImageryProvider.BaiduImageryProvider(opts);
                        break;
                    case "www_google":
                        //谷歌国内   
                        var _url;

                        if (item.crs == '4326' || item.crs == 'wgs84') {
                            //wgs84   无偏移
                            switch (opts.layer) {
                                default:
                                case "img_d":
                                    _url = '//www.google.cn/maps/vt?lyrs=s&x={x}&y={y}&z={z}';
                                    break;
                            }
                        } else {
                            //有偏移  
                            switch (opts.layer) {
                                case "vec":
                                default:
                                    _url = '//mt{s}.google.cn/vt/lyrs=m@207000000&hl=zh-CN&gl=CN&src=app&x={x}&y={y}&z={z}&s=Galile';
                                    break;
                                case "img_d":
                                    _url = '//mt{s}.google.cn/vt/lyrs=s&hl=zh-CN&gl=CN&x={x}&y={y}&z={z}&s=Gali';
                                    break;
                                case "img_z":
                                    _url = '//mt{s}.google.cn/vt/imgtp=png32&lyrs=h@207000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galil';
                                    break;
                                case "ter":
                                    _url = '//mt{s}.google.cn/vt/lyrs=t@131,r@227000000&hl=zh-CN&gl=cn&x={x}&y={y}&z={z}&s=Galile';
                                    break;
                            }
                        }

                        if (opts.proxy) //存在代理时
                            _url = (0, _util.getProxyUrl)({ url: _url.replace('{s}', '1'), proxy: opts.proxy }).url;

                        layer = new Cesium.UrlTemplateImageryProvider({
                            url: _url,
                            subdomains: ['1', '2', '3'],
                            maximumLevel: 20
                        });
                        break;

                    case "www_osm":
                        //OSM开源地图 
                        var _url = '//{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
                        if (opts.proxy) //存在代理时
                            _url = (0, _util.getProxyUrl)({ url: _url.replace('{s}', 'a'), proxy: opts.proxy }).url;

                        layer = new Cesium.UrlTemplateImageryProvider({
                            url: _url,
                            subdomains: "abc",
                            maximumLevel: 18
                        });
                        break;
                    case "www_bing":
                        //bing地图 

                        var _url = 'https://dev.virtualearth.net';
                        if (opts.proxy) //存在代理时
                            _url = (0, _util.getProxyUrl)({ url: _url, proxy: opts.proxy }).url;

                        //无标记影像 Aerial,
                        //有英文标记影像   AerialWithLabels,
                        //矢量道路  Road 
                        //OrdnanceSurvey,
                        //CollinsBart
                        var style = opts.layer || Cesium.BingMapsStyle.Aerial;
                        layer = new Cesium.BingMapsImageryProvider({
                            url: _url,
                            key: opts.key || 'AtkX3zhnRe5fyGuLU30uZw8r3sxdBDnpQly7KfFTCB2rGlDgXBG3yr-qEiQEicEc',
                            mapStyle: style
                        });
                        break;

                    //===============内部定义的图层====================
                    case "custom_grid":
                        //网格线  
                        opts.cells = opts.cells || 2;
                        opts.color = Cesium.Color.fromCssColorString(opts.color || 'rgba(255,255,255,1)');
                        opts.glowWidth = opts.glowWidth || 3;
                        if (opts.glowColor) opts.glowColor = Cesium.Color.fromCssColorString(opts.glowColor); else opts.glowColor = opts.color.withAlpha(0.3);
                        opts.backgroundColor = Cesium.Color.fromCssColorString(opts.backgroundColor || 'rgba(0,0,0,0)');

                        layer = new Cesium.GridImageryProvider(opts);
                        break;
                    case "custom_tilecoord":
                        //瓦片信息
                        layer = new Cesium.TileCoordinatesImageryProvider(opts);
                        break;
                    case "custom_featuregrid":
                        //自定义矢量网格图层
                        layer = new _FeatureGridImageryProvider.FeatureGridImageryProvider(opts);
                        break;
                    default:
                        console.log("config配置图层未处理:" + item);
                        break;
                }
                layer.config = opts;

                return layer;
            };

            function getOneKey(arr) {
                var n = Math.floor(Math.random() * arr.length + 1) - 1;
                return arr[n];
            }

            //===================================== 地形相关 ================================= 

            var _ellipsoid = new Cesium.EllipsoidTerrainProvider({
                ellipsoid: Cesium.Ellipsoid.WGS84
            });

            //是否无地形
            function hasTerrain(viewer) {
                return !(viewer.terrainProvider == _ellipsoid || viewer.terrainProvider instanceof Cesium.EllipsoidTerrainProvider);
            }
            function getEllipsoidTerrain() {
                return _ellipsoid;
            }
            function getTerrainProvider(cfg) {
                cfg = cfg || { type: "ion" };
                cfg.requestWaterMask = Cesium.defaultValue(cfg.requestWaterMask, true);
                cfg.requestVertexNormals = Cesium.defaultValue(cfg.requestVertexNormals, true);

                var terrainProvider;
                switch (cfg.type) {
                    default:
                        //默认是自定义的 
                        terrainProvider = new Cesium.CesiumTerrainProvider((0, _util.getProxyUrl)(cfg));
                        break;
                    case "ion":
                    case "cesium":
                        //cesium官方在线的
                        terrainProvider = new Cesium.CesiumTerrainProvider({
                            url: Cesium.IonResource.fromAssetId(1),
                            requestWaterMask: cfg.requestWaterMask,
                            requestVertexNormals: cfg.requestVertexNormals
                        });
                        break;
                    case "gee":
                    case "google":
                        //谷歌地球地形服务
                        terrainProvider = new Cesium.GoogleEarthEnterpriseTerrainProvider({
                            metadata: new Cesium.GoogleEarthEnterpriseMetadata((0, _util.getProxyUrl)(cfg))
                        });
                        break;
                    case "arcgis":
                        //ArcGIS地形服务 
                        terrainProvider = new Cesium.ArcGISTiledElevationTerrainProvider((0, _util.getProxyUrl)(cfg));
                        break;
                    case "ellipsoid":
                        terrainProvider = _ellipsoid;
                        break;
                }

                return terrainProvider;
            }

            /***/
}),
/* 21 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditBase = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _MapVClass = __webpack_require__(23);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditBase = exports.EditBase = _MapVClass.MapVClass.extend({
                _dataSource: null,
                _minPointNum: 1, //至少需要点的个数 (值是draw中传入)
                _maxPointNum: 9999, //最多允许点的个数 (值是draw中传入)
                initialize: function initialize(entity, viewer, dataSource) {
                    this.entity = entity;
                    this.viewer = viewer;
                    this.dataSource = dataSource;

                    this.draggers = [];
                },
                fire: function fire(type, data, propagate) {
                    if (this._fire) this._fire(type, data, propagate);
                },
                formatNum: function formatNum(num, digits) {
                    return Util.formatNum(num, digits);
                },
                setCursor: function setCursor(val) {
                    this.viewer._container.style.cursor = val ? 'crosshair' : '';
                },
                //激活绘制
                activate: function activate() {
                    if (this._enabled) {
                        return this;
                    }
                    this._enabled = true;

                    this.entity.inProgress = true;
                    this.changePositionsToCallback();
                    this.bindDraggers();
                    this.bindEvent();

                    this.fire(EventType.EditStart, { edittype: this.entity.attribute.type, entity: this.entity });

                    return this;
                },
                //释放绘制
                disable: function disable() {
                    if (!this._enabled) {
                        return this;
                    }
                    this._enabled = false;

                    this.destroyEvent();
                    this.destroyDraggers();
                    this.finish();

                    this.entity.inProgress = false;
                    this.fire(EventType.EditStop, { edittype: this.entity.attribute.type, entity: this.entity });
                    this.tooltip.setVisible(false);

                    return this;
                },
                changePositionsToCallback: function changePositionsToCallback() { },
                //图形编辑结束后调用
                finish: function finish() { },
                //拖拽点 事件
                bindEvent: function bindEvent() {
                    var _this = this;

                    var scratchBoundingSphere = new Cesium.BoundingSphere();
                    var zOffset = new Cesium.Cartesian3();

                    var draggerHandler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);
                    draggerHandler.dragger = null;

                    //选中后拖动
                    draggerHandler.setInputAction(function (event) {
                        var pickedObject = _this.viewer.scene.pick(event.position);
                        if (Cesium.defined(pickedObject)) {
                            var entity = pickedObject.id || pickedObject.primitive.id || pickedObject.primitive;
                            if (entity && Cesium.defaultValue(entity._isDragger, false)) {
                                _this.viewer.scene.screenSpaceCameraController.enableRotate = false;
                                _this.viewer.scene.screenSpaceCameraController.enableTilt = false;
                                _this.viewer.scene.screenSpaceCameraController.enableTranslate = false;
                                _this.viewer.scene.screenSpaceCameraController.enableInputs = false;

                                if (_this.viewer.mapv) _this.viewer.mapv.popup.close(entity);

                                draggerHandler.dragger = entity;

                                if (draggerHandler.dragger.point) draggerHandler.dragger.show = false;
                                _this.setCursor(true);

                                if (draggerHandler.dragger.onDragStart) {
                                    var position = draggerHandler.dragger.position;
                                    if (position && position.getValue) position = position.getValue(_this.viewer.clock.currentTime);
                                    draggerHandler.dragger.onDragStart(draggerHandler.dragger, position);
                                }
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

                    draggerHandler.setInputAction(function (event) {
                        var dragger = draggerHandler.dragger;
                        if (dragger) {
                            switch (dragger._pointType) {
                                case draggerCtl.PointType.MoveHeight:
                                    //改变高度垂直拖动
                                    var dy = event.endPosition.y - event.startPosition.y;

                                    var position = dragger.position;
                                    if (position && position.getValue) position = position.getValue(_this.viewer.clock.currentTime);

                                    var tangentPlane = new Cesium.EllipsoidTangentPlane(position);

                                    scratchBoundingSphere.center = position;
                                    scratchBoundingSphere.radius = 1;

                                    var metersPerPixel = _this.viewer.scene.frameState.camera.getPixelSize(scratchBoundingSphere, _this.viewer.scene.frameState.context.drawingBufferWidth, _this.viewer.scene.frameState.context.drawingBufferHeight) * 1.5;

                                    Cesium.Cartesian3.multiplyByScalar(tangentPlane.zAxis, -dy * metersPerPixel, zOffset);
                                    var newPosition = Cesium.Cartesian3.clone(position);
                                    Cesium.Cartesian3.add(position, zOffset, newPosition);

                                    dragger.position = newPosition;
                                    if (dragger.onDrag) {
                                        dragger.onDrag(dragger, newPosition, position);
                                    }
                                    _this.updateAttrForEditing();
                                    break;
                                default:
                                    //默认修改位置
                                    _this.tooltip.showAt(event.endPosition, _Tooltip.message.edit.end);

                                    var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.endPosition, _this.entity);

                                    if (point) {
                                        dragger.position = point;
                                        if (dragger.onDrag) {
                                            dragger.onDrag(dragger, point);
                                        }
                                        _this.updateAttrForEditing();
                                    }
                                    break;
                            }
                        } else {
                            _this.tooltip.setVisible(false);

                            var pickedObject = _this.viewer.scene.pick(event.endPosition);
                            if (Cesium.defined(pickedObject)) {
                                var entity = pickedObject.id;
                                if (entity && Cesium.defaultValue(entity._isDragger, false) && entity.draw_tooltip) {
                                    var draw_tooltip = entity.draw_tooltip;

                                    //可删除时，提示右击删除
                                    if (draggerCtl.PointType.Control == entity._pointType && _this._positions_draw && _this._positions_draw.length && _this._positions_draw.length > _this._minPointNum) draw_tooltip += _Tooltip.message.del.def;

                                    _this.tooltip.showAt(event.endPosition, draw_tooltip);
                                }
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    draggerHandler.setInputAction(function (event) {
                        var dragger = draggerHandler.dragger;
                        if (dragger) {
                            _this.setCursor(false);
                            dragger.show = true;

                            var position = dragger.position;
                            if (position && position.getValue) position = position.getValue(_this.viewer.clock.currentTime);

                            if (dragger.onDragEnd) {
                                dragger.onDragEnd(dragger, position);
                            }
                            _this.fire(EventType.EditMovePoint, { edittype: _this.entity.attribute.type, entity: _this.entity, position: position });

                            draggerHandler.dragger = null;

                            _this.viewer.scene.screenSpaceCameraController.enableRotate = true;
                            _this.viewer.scene.screenSpaceCameraController.enableTilt = true;
                            _this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
                            _this.viewer.scene.screenSpaceCameraController.enableInputs = true;
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_UP);

                    //右击删除一个点
                    draggerHandler.setInputAction(function (event) {
                        //右击删除上一个点
                        var pickedObject = _this.viewer.scene.pick(event.position);
                        if (Cesium.defined(pickedObject)) {
                            var entity = pickedObject.id;
                            if (entity && Cesium.defaultValue(entity._isDragger, false) && draggerCtl.PointType.Control == entity._pointType) {
                                var isDelOk = _this.deletePointForDragger(entity, event.position);

                                if (isDelOk) _this.fire(EventType.EditRemovePoint, { edittype: _this.entity.attribute.type, entity: _this.entity });
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);

                    this.draggerHandler = draggerHandler;
                },
                destroyEvent: function destroyEvent() {
                    this.viewer.scene.screenSpaceCameraController.enableRotate = true;
                    this.viewer.scene.screenSpaceCameraController.enableTilt = true;
                    this.viewer.scene.screenSpaceCameraController.enableTranslate = true;
                    this.viewer.scene.screenSpaceCameraController.enableInputs = true;

                    this.setCursor(false);

                    if (this.draggerHandler) {
                        if (this.draggerHandler.dragger) this.draggerHandler.dragger.show = true;

                        this.draggerHandler.destroy();
                        this.draggerHandler = null;
                    }
                },
                bindDraggers: function bindDraggers() { },
                updateDraggers: function updateDraggers() {
                    if (!this._enabled) {
                        return this;
                    }

                    this.destroyDraggers();
                    this.bindDraggers();
                },
                destroyDraggers: function destroyDraggers() {
                    for (var i = 0, len = this.draggers.length; i < len; i++) {
                        this.dataSource.entities.remove(this.draggers[i]);
                    }
                    this.draggers = [];
                },
                //删除点
                deletePointForDragger: function deletePointForDragger(dragger, position) {
                    if (!this._positions_draw) return;
                    if (this._positions_draw.length - 1 < this._minPointNum) {
                        this.tooltip.showAt(position, _Tooltip.message.del.min + this._minPointNum);
                        return false;
                    }

                    var index = dragger.index;
                    if (index >= 0 && index < this._positions_draw.length) {
                        this._positions_draw.splice(index, 1);
                        this.updateDraggers();
                        this.updateAttrForEditing();
                        return true;
                    } else {
                        return false;
                    }
                },
                updateAttrForEditing: function updateAttrForEditing() { }

            });

            /***/
}),
/* 22 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPolyline = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPolyline = exports.EditPolyline = _Edit.EditBase.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.polyline;
                },
                //坐标位置相关
                _positions_draw: [],
                getPosition: function getPosition() {
                    return this._positions_draw;
                },
                //外部更新位置
                setPositions: function setPositions(positions) {
                    this._positions_draw = positions;
                    this.updateAttrForEditing();
                    this.finish();
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_draw = this.getPosition();
                },
                isClampToGround: function isClampToGround() {
                    return this.entity.attribute.style.clampToGround;
                },
                _hasMidPoint: true,
                //是否可在中间新增点 
                hasMidPoint: function hasMidPoint() {
                    return this._hasMidPoint && this.getPosition().length < this._maxPointNum;
                },
                //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
                hasClosure: false,
                //子类用，根据属性更新坐标
                updatePositionsHeightByAttr: function updatePositionsHeightByAttr(position) {

                    return position;
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var positions = this.getPosition();

                    var clampToGround = this.isClampToGround();
                    var hasMidPoint = this.hasMidPoint();

                    for (var i = 0, len = positions.length; i < len; i++) {
                        var loc = positions[i];

                        loc = this.updatePositionsHeightByAttr(loc);
                        if (clampToGround) {
                            //贴地时求贴模型和贴地的高度
                            loc = (0, _point.setPositionSurfaceHeight)(this.viewer, loc);
                            positions[i] = loc;
                        }

                        //各顶点
                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: loc,
                            //clampToGround: clampToGround,
                            onDrag: function onDrag(dragger, position) {
                                position = that.updatePositionsHeightByAttr(position);
                                dragger.position = position;
                                positions[dragger.index] = position;

                                //============高度调整拖拽点处理（子类用）=============
                                if (that.heightDraggers && that.heightDraggers.length > 0) {
                                    var extrudedHeight = that.getGraphic().extrudedHeight.getValue(that.viewer.clock.currentTime);
                                    that.heightDraggers[dragger.index].position = (0, _point.setPositionsHeight)(position, extrudedHeight);
                                }

                                //============新增点拖拽点处理=============
                                if (hasMidPoint) {
                                    var draggersIdx;
                                    var nextPositionIdx;
                                    //与前一个点之间的中点 
                                    if (that.hasClosure || !that.hasClosure && dragger.index != 0) {
                                        if (dragger.index == 0) {
                                            draggersIdx = len * 2 - 1;
                                            nextPositionIdx = len - 1;
                                        } else {
                                            draggersIdx = dragger.index * 2 - 1;
                                            nextPositionIdx = dragger.index - 1;
                                        }
                                        var nextPosition = positions[nextPositionIdx];
                                        var midpoint = Cesium.Cartesian3.midpoint(position, nextPosition, new Cesium.Cartesian3());
                                        midpoint = that.updatePositionsHeightByAttr(midpoint);
                                        if (clampToGround) {
                                            //贴地时求贴模型和贴地的高度 
                                            midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                                        }
                                        that.draggers[draggersIdx].position = midpoint;
                                    }

                                    //与后一个点之间的中点
                                    if (that.hasClosure || !that.hasClosure && dragger.index != len - 1) {
                                        if (dragger.index == len - 1) {
                                            draggersIdx = dragger.index * 2 + 1;
                                            nextPositionIdx = 0;
                                        } else {
                                            draggersIdx = dragger.index * 2 + 1;
                                            nextPositionIdx = dragger.index + 1;
                                        }
                                        var midpoint = Cesium.Cartesian3.midpoint(position, positions[nextPositionIdx], new Cesium.Cartesian3());
                                        midpoint = that.updatePositionsHeightByAttr(midpoint);
                                        if (clampToGround) {
                                            //贴地时求贴模型和贴地的高度 
                                            midpoint = (0, _point.setPositionSurfaceHeight)(that.viewer, midpoint);
                                        }
                                        that.draggers[draggersIdx].position = midpoint;
                                    }
                                }

                                //============整体平移移动点处理============= 
                                positionMove = (0, _point.centerOfMass)(positions);
                                positionMove = that.updatePositionsHeightByAttr(positionMove);
                                if (clampToGround) {
                                    //贴地时求贴模型和贴地的高度
                                    positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
                                }
                                draggerMove.position = positionMove;
                            }
                        });
                        dragger.index = i;
                        this.draggers.push(dragger);

                        //中间点，拖动后新增点
                        if (hasMidPoint && (this.hasClosure || !this.hasClosure && i < len - 1)) {
                            var nextIndex = (i + 1) % len;
                            var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
                            midpoint = that.updatePositionsHeightByAttr(midpoint);
                            if (clampToGround) {
                                //贴地时求贴模型和贴地的高度 
                                midpoint = (0, _point.setPositionSurfaceHeight)(this.viewer, midpoint);
                            }

                            var draggerMid = draggerCtl.createDragger(this.dataSource, {
                                position: midpoint,
                                type: draggerCtl.PointType.AddMidPoint,
                                tooltip: _Tooltip.message.dragger.addMidPoint,
                                //clampToGround: clampToGround,
                                onDragStart: function onDragStart(dragger, position) {
                                    positions.splice(dragger.index, 0, position); //插入点 
                                },
                                onDrag: function onDrag(dragger, position) {
                                    positions[dragger.index] = position;
                                },
                                onDragEnd: function onDragEnd(dragger, position) {
                                    that.updateDraggers();
                                }
                            });
                            draggerMid.index = nextIndex;
                            this.draggers.push(draggerMid);
                        }
                    }

                    //整体平移移动点 
                    var positionMove = (0, _point.centerOfMass)(positions);
                    positionMove = this.updatePositionsHeightByAttr(positionMove);
                    if (clampToGround) {
                        //贴地时求贴模型和贴地的高度
                        positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
                    }

                    var draggerMove = draggerCtl.createDragger(this.dataSource, {
                        position: positionMove,
                        type: draggerCtl.PointType.MoveAll,
                        tooltip: _Tooltip.message.dragger.moveAll,
                        onDrag: function onDrag(dragger, position) {
                            // dragger.position = position;

                            //记录差值 
                            var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                            positionMove = position;

                            positions.forEach(function (pos, index, arr) {
                                var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                                positions[index] = newPos;
                            });

                            //=====全部更新========== 
                            that.updateDraggers();
                        }
                    });
                    this.draggers.push(draggerMove);

                    //创建高程拖拽点
                    if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
                },
                //子类用，高度调整拖拽点 
                heightDraggers: null,
                bindHeightDraggers: function bindHeightDraggers(positions) {
                    var that = this;

                    this.heightDraggers = [];

                    positions = positions || this.getPosition();
                    var extrudedHeight = that.getGraphic().extrudedHeight.getValue(this.viewer.clock.currentTime);

                    for (var i = 0, len = positions.length; i < len; i++) {
                        var loc = positions[i];
                        loc = (0, _point.setPositionsHeight)(loc, extrudedHeight);

                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: loc,
                            type: draggerCtl.PointType.MoveHeight,
                            tooltip: _Tooltip.message.dragger.moveHeight,
                            onDrag: function onDrag(dragger, position) {
                                var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
                                that.getGraphic().extrudedHeight = thisHeight;

                                var maxHeight = (0, _point.getMaxHeight)(that.getPosition());
                                that.entity.attribute.style.extrudedHeight = that.formatNum(thisHeight - maxHeight, 2);

                                that.updateHeightDraggers(thisHeight);
                            }
                        });

                        this.draggers.push(dragger);
                        this.heightDraggers.push(dragger);
                    }
                },
                updateHeightDraggers: function updateHeightDraggers(extrudedHeight) {
                    for (var i = 0; i < this.heightDraggers.length; i++) {
                        var heightDragger = this.heightDraggers[i];

                        var position = (0, _point.setPositionsHeight)(heightDragger.position.getValue(this.viewer.clock.currentTime), extrudedHeight);
                        heightDragger.position.setValue(position);
                    }
                }

            });

            /***/
}),
/* 23 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MapVClass = MapVClass;

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function MapVClass() { }

            MapVClass.extend = function (props) {

                // @function extend(props: Object): Function
                // [Extends the current class](#class-inheritance) given the properties to be included.
                // Returns a Javascript function that is a class constructor (to be called with `new`).
                var NewClass = function NewClass() {

                    // call the constructor
                    if (this.initialize) {
                        this.initialize.apply(this, arguments);
                    }

                    // call all constructor hooks
                    this.callInitHooks();
                };

                var parentProto = NewClass.__super__ = this.prototype;

                var proto = Util.create(parentProto);
                proto.constructor = NewClass;

                NewClass.prototype = proto;

                // inherit parent's statics
                for (var i in this) {
                    if (this.hasOwnProperty(i) && i !== 'prototype' && i !== '__super__') {
                        NewClass[i] = this[i];
                    }
                }

                // mix static properties into the class
                if (props.statics) {
                    Util.extend(NewClass, props.statics);
                    delete props.statics;
                }

                // mix includes into the prototype
                if (props.includes) {
                    // checkDeprecatedMixinEvents(props.includes);
                    Util.extend.apply(null, [proto].concat(props.includes));
                    delete props.includes;
                }

                // merge options
                if (proto.options) {
                    props.options = Util.extend(Util.create(proto.options), props.options);
                }

                // mix given properties into the prototype
                Util.extend(proto, props);

                proto._initHooks = [];

                // add method for calling all hooks
                proto.callInitHooks = function () {

                    if (this._initHooksCalled) {
                        return;
                    }

                    if (parentProto.callInitHooks) {
                        parentProto.callInitHooks.call(this);
                    }

                    this._initHooksCalled = true;

                    for (var i = 0, len = proto._initHooks.length; i < len; i++) {
                        proto._initHooks[i].call(this);
                    }
                };

                return NewClass;
            };

            // @function include(properties: Object): this
            // [Includes a mixin](#class-includes) into the current class.
            MapVClass.include = function (props) {
                Util.extend(this.prototype, props);
                return this;
            };

            // @function mergeOptions(options: Object): this
            // [Merges `options`](#class-options) into the defaults of the class.
            MapVClass.mergeOptions = function (options) {
                Util.extend(this.prototype.options, options);
                return this;
            };

            // @function addInitHook(fn: Function): this
            // Adds a [constructor hook](#class-constructor-hooks) to the class.
            MapVClass.addInitHook = function (fn) {
                // (Function) || (String, args...)
                var args = Array.prototype.slice.call(arguments, 1);

                var init = typeof fn === 'function' ? fn : function () {
                    this[fn].apply(this, args);
                };

                this.prototype._initHooks = this.prototype._initHooks || [];
                this.prototype._initHooks.push(init);
                return this;
            };

            /***/
}),
/* 24 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPoint = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(32);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(38);

            var attr = _interopRequireWildcard(_Attr);

            var _Tooltip = __webpack_require__(5);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            var _Edit = __webpack_require__(57);

            var _Attr2 = __webpack_require__(16);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPoint = exports.DrawPoint = _Draw.DrawBase.extend({
                type: 'point',
                //获取编辑对象  
                editClass: _Edit.EditPoint,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        show: false,
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        point: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    if (attribute.style && attribute.style.label) {
                        //同时加文字
                        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
                    }

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    if (style && style.label) {
                        //同时加文字
                        (0, _Attr2.style2Entity)(style.label, entity.label);
                    }
                    return attr.style2Entity(style, entity.point);
                },
                //绑定鼠标事件
                bindEvent: function bindEvent() {
                    var _this = this;

                    this.getHandler().setInputAction(function (event) {
                        var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.endPosition, _this.entity);
                        if (point) {
                            _this._positions_draw = point;
                        }
                        _this.tooltip.showAt(event.endPosition, _Tooltip.message.draw.point.start);

                        _this.fire(EventType.DrawMouseMove, { drawtype: _this.type, entity: _this.entity, position: point });
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    this.getHandler().setInputAction(function (event) {
                        var point = (0, _point.getCurrentMousePosition)(_this.viewer.scene, event.position, _this.entity);
                        if (point) {
                            _this._positions_draw = point;
                            _this.disable();
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                },
                //获取外部entity的坐标到_positions_draw
                setDrawPositionByEntity: function setDrawPositionByEntity(entity) {
                    var positions = this.getPositions(entity);
                    this._positions_draw = positions[0];
                },
                //图形绘制结束,更新属性
                finish: function finish() {
                    this.entity.show = true;

                    this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象     
                    this.entity.position = this.getDrawPosition();
                }

            });

            /***/
}),
/* 25 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPolygon = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Attr = __webpack_require__(19);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(22);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPolygon = exports.EditPolygon = _Edit.EditPolyline.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.polygon;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw || attr.getPositions(this.entity);
                },
                //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
                hasClosure: true,
                isClampToGround: function isClampToGround() {
                    return this.entity.attribute.style.hasOwnProperty('clampToGround') ? this.entity.attribute.style.clampToGround : !this.entity.attribute.style.perPositionHeight;
                }

            });

            /***/
}),
/* 26 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.box = exports.plan = exports.corridor = exports.ellipsoid = exports.rectangle = exports.cylinder = exports.ellipse = exports.circle = exports.polygon = exports.wall = exports.polylineVolume = exports.polyline = exports.model = exports.point = exports.label = exports.billboard = undefined;
            exports.getTypeName = getTypeName;
            exports.getCoordinates = getCoordinates;
            exports.getPositions = getPositions;
            exports.getCenterPosition = getCenterPosition;
            exports.toGeoJSON = toGeoJSON;
            exports.style2Entity = style2Entity;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(30);

            var billboard = _interopRequireWildcard(_Attr);

            var _Attr2 = __webpack_require__(16);

            var label = _interopRequireWildcard(_Attr2);

            var _Attr3 = __webpack_require__(38);

            var point = _interopRequireWildcard(_Attr3);

            var _Attr4 = __webpack_require__(31);

            var model = _interopRequireWildcard(_Attr4);

            var _Attr5 = __webpack_require__(49);

            var plan = _interopRequireWildcard(_Attr5);

            var _Attr6 = __webpack_require__(50);

            var box = _interopRequireWildcard(_Attr6);

            var _Attr7 = __webpack_require__(29);

            var polyline = _interopRequireWildcard(_Attr7);

            var _Attr8 = __webpack_require__(51);

            var polylineVolume = _interopRequireWildcard(_Attr8);

            var _Attr9 = __webpack_require__(52);

            var wall = _interopRequireWildcard(_Attr9);

            var _Attr10 = __webpack_require__(53);

            var corridor = _interopRequireWildcard(_Attr10);

            var _Attr11 = __webpack_require__(19);

            var polygon = _interopRequireWildcard(_Attr11);

            var _Attr12 = __webpack_require__(40);

            var circle = _interopRequireWildcard(_Attr12);

            var _Attr13 = __webpack_require__(54);

            var cylinder = _interopRequireWildcard(_Attr13);

            var _Attr14 = __webpack_require__(55);

            var rectangle = _interopRequireWildcard(_Attr14);

            var _Attr15 = __webpack_require__(56);

            var ellipsoid = _interopRequireWildcard(_Attr15);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var ellipse = circle;

            exports.billboard = billboard;
            exports.label = label;
            exports.point = point;
            exports.model = model;
            exports.polyline = polyline;
            exports.polylineVolume = polylineVolume;
            exports.wall = wall;
            exports.polygon = polygon;
            exports.circle = circle;
            exports.ellipse = ellipse;
            exports.cylinder = cylinder;
            exports.rectangle = rectangle;
            exports.ellipsoid = ellipsoid;
            exports.corridor = corridor;
            exports.plan = plan;
            exports.box = box;
            function getTypeName(entity) {
                if (entity.billboard) return "billboard";
                if (entity.point) return "point";
                if (entity.label) return "label";
                if (entity.model) return "model";
                if (entity.polyline) return "polyline";
                if (entity.polylineVolume) return "polylineVolume";
                if (entity.corridor) return "corridor";
                if (entity.wall) return "wall";
                if (entity.ellipse) return "circle";
                if (entity.cylinder) return "cylinder";
                if (entity.polygon) return "polygon";
                if (entity.rectangle) return "rectangle";
                if (entity.ellipsoid) return "ellipsoid";
                if (entity.plan) return "plan";
                if (entity.box) return "box";

                return "";
            }

            function defNullFun(entity) {
                return null;
            }

            function getAttrClass(entity) {
                if (entity.point) return point;
                if (entity.billboard) return billboard;
                if (entity.label) return label;
                if (entity.model) return model;
                if (entity.polyline) return polyline;
                if (entity.polylineVolume) return polylineVolume;
                if (entity.corridor) return corridor;
                if (entity.wall) return wall;
                if (entity.ellipse) return circle;
                if (entity.cylinder) return cylinder;
                if (entity.polygon) return polygon;
                if (entity.rectangle) return rectangle;
                if (entity.ellipsoid) return ellipsoid;
                if (entity.plan) return plan;
                if (entity.box) return box;

                return {
                    getCoordinates: defNullFun,
                    getPositions: defNullFun,
                    toGeoJSON: defNullFun,
                    style2Entity: defNullFun
                };
            }

            function getCoordinates(entity) {
                return getAttrClass(entity).getCoordinates(entity);
            }

            function getPositions(entity) {
                return getAttrClass(entity).getPositions(entity);
            }

            function getCenterPosition(entity) {
                var position;
                if (entity.position) {
                    //存在position属性时，直接取
                    position = (0, _point.getPositionValue)(entity.position);
                    if (position) return position;
                }

                var pots = getPositions(entity);
                if (!pots || pots.length == 0) return null;
                if (pots.length == 1) return pots[0];

                if (entity.polygon) position = (0, _point.centerOfMass)(pots); else position = pots[Math.floor(pots.length / 2)];
                return position;
            }

            function toGeoJSON(entity) {
                return getAttrClass(entity).toGeoJSON(entity);
            }

            function style2Entity(style, entity) {
                return getAttrClass(entity).style2Entity(style, entity);
            }

            /***/
}),
/* 27 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.getCenter = getCenter;
            exports.updateMatrix = updateMatrix;
            exports.pick3DTileset = pick3DTileset;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //获取模型的中心点信息
            function getCenter(tileset, transform) {
                var result = {};

                //记录模型原始的中心点
                var boundingSphere = tileset.boundingSphere;
                var position = boundingSphere.center;
                var catographic = Cesium.Cartographic.fromCartesian(position);

                var height = Number(catographic.height.toFixed(2));
                var longitude = Number(Cesium.Math.toDegrees(catographic.longitude).toFixed(6));
                var latitude = Number(Cesium.Math.toDegrees(catographic.latitude).toFixed(6));
                result = { x: longitude, y: latitude, z: height };

                console.log("模型内部原始位置:" + JSON.stringify(result));

                //如果tileset自带世界矩阵矩阵，那么计算放置的经纬度和heading
                if (transform) {
                    var matrix = Cesium.Matrix4.fromArray(tileset._root.transform);
                    var pos = Cesium.Matrix4.getTranslation(matrix, new Cesium.Cartesian3());
                    var wpos = Cesium.Cartographic.fromCartesian(pos);
                    if (Cesium.defined(wpos)) {
                        result.x = Number(Cesium.Math.toDegrees(wpos.longitude).toFixed(6));
                        result.y = Number(Cesium.Math.toDegrees(wpos.latitude).toFixed(6));
                        result.z = Number(wpos.height.toFixed(2));

                        //取旋转矩阵
                        var rotmat = Cesium.Matrix4.getMatrix3(matrix, new Cesium.Matrix3());
                        //默认的旋转矩阵
                        var defrotmat = Cesium.Matrix4.getMatrix3(Cesium.Transforms.eastNorthUpToFixedFrame(pos), new Cesium.Matrix3());

                        //计算rotmat 的x轴，在defrotmat 上 旋转
                        var xaxis = Cesium.Matrix3.getColumn(defrotmat, 0, new Cesium.Cartesian3());
                        var yaxis = Cesium.Matrix3.getColumn(defrotmat, 1, new Cesium.Cartesian3());
                        var zaxis = Cesium.Matrix3.getColumn(defrotmat, 2, new Cesium.Cartesian3());

                        var dir = Cesium.Matrix3.getColumn(rotmat, 0, new Cesium.Cartesian3());

                        dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
                        dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
                        dir = Cesium.Cartesian3.normalize(dir, dir);

                        var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

                        var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);

                        if (ay > Math.PI * 0.5) {
                            heading = 2 * Math.PI - heading;
                        }
                        result.heading = Number(Cesium.Math.toDegrees(heading).toFixed(1));

                        console.log("模型内部世界矩阵:" + JSON.stringify(result));
                    }
                }

                return result;
            }

            //变换轴，兼容旧版本数据z轴方向不对的情况
            //如果可以修改模型json源文件，可以在json文件里面加了一行来修正："gltfUpAxis" : "Z", 
            //3dtiles相关计算常用方法
            function updateAxis(matrix, axis) {
                if (axis == null) return matrix;

                var rightaxis;
                switch (axis.toUpperCase()) {
                    case "Y_UP_TO_Z_UP":
                        rightaxis = Cesium.Axis.Y_UP_TO_Z_UP;
                        break;
                    case "Z_UP_TO_Y_UP":
                        rightaxis = Cesium.Axis.Z_UP_TO_Y_UP;
                        break;
                    case "X_UP_TO_Z_UP":
                        rightaxis = Cesium.Axis.X_UP_TO_Z_UP;
                        break;
                    case "Z_UP_TO_X_UP":
                        rightaxis = Cesium.Axis.Z_UP_TO_X_UP;
                        break;
                    case "X_UP_TO_Y_UP":
                        rightaxis = Cesium.Axis.X_UP_TO_Y_UP;
                        break;
                    case "Y_UP_TO_X_UP":
                        rightaxis = Cesium.Axis.Y_UP_TO_X_UP;
                        break;
                }
                if (rightaxis == null) return matrix;

                return Cesium.Matrix4.multiplyTransformation(matrix, rightaxis, matrix);
            }

            //变换模型位置等
            function updateMatrix(tileset, opts) {
                var matrix;

                //有自带世界矩阵矩阵 
                if (Cesium.defined(tileset._root) && Cesium.defined(tileset._root.transform) && opts.transform) {
                    // var mat = Cesium.Matrix4.fromArray(tileset_root.transform);
                    // var pos = Cesium.Matrix4.getTranslation(mat, new Cesium.Cartesian3());
                    // var wpos = Cesium.Cartographic.fromCartesian(pos);
                    // if (wpos) {  
                    // } 

                    var position = Cesium.Cartesian3.fromDegrees(opts.x, opts.y, opts.z);
                    matrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                    var rotationX = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(opts.heading || 0)));
                    Cesium.Matrix4.multiply(matrix, rotationX, matrix);

                    if (opts.scale > 0 && opts.scale != 1) //缩放比例
                        Cesium.Matrix4.multiplyByUniformScale(matrix, opts.scale, matrix);

                    if (opts.axis) //变换轴
                        matrix = updateAxis(matrix, opts.axis);

                    tileset._root.transform = matrix;
                } else {
                    //普通,此种方式[x，y不能多次更改]
                    var boundingSphere = tileset.boundingSphere;
                    var catographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
                    var surface = Cesium.Cartesian3.fromRadians(catographic.longitude, catographic.latitude, 0.0);
                    var offset = Cesium.Cartesian3.fromDegrees(opts.x, opts.y, opts.z);

                    var translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
                    matrix = Cesium.Matrix4.fromTranslation(translation);

                    tileset.modelMatrix = matrix;
                }
                return matrix;
            }

            //获取坐标点处的3dtiles模型，用于计算贴地时进行判断（和视角有关系，不一定精确）
            function pick3DTileset(scene, positions) {
                if (!positions) return null;

                if (scene instanceof Cesium.Viewer) //兼容scene传入viewer
                    scene = scene.scene;

                if (positions instanceof Cesium.Cartesian3) positions = [positions];

                for (var i = 0, len = positions.length; i < len; ++i) {
                    var position = positions[i];
                    var coorPX = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position);
                    if (!Cesium.defined(coorPX)) continue;

                    var pickedObject = scene.pick(coorPX, 10, 10);
                    if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive) && pickedObject.primitive instanceof Cesium.Cesium3DTileset) {
                        // Cesium.defined(pickedObject.primitive.isCesium3DTileset)
                        return pickedObject.primitive;
                    }
                }

                return null;
            }

            /***/
}),
/* 28 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.config2Entity = config2Entity;
            exports.style2Entity = style2Entity;
            exports.createDthEntity = createDthEntity;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _util = __webpack_require__(1);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(30);

            var _Attr2 = __webpack_require__(16);

            var _Attr3 = __webpack_require__(31);

            var _Attr4 = __webpack_require__(29);

            var _Attr5 = __webpack_require__(19);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var nullColor = new Cesium.Color(0.0, 0.0, 0.0, 0.01);

            //根据config配置，更新entitys
            function config2Entity(entities, config) {
                for (var i = 0, len = entities.length; i < len; i++) {
                    var entity = entities[i];

                    //属性
                    var attr;
                    if (typeof config.getAttrVal === 'function') {
                        attr = config.getAttrVal(entity);
                    } else {
                        attr = (0, _util.getAttrVal)(entity.properties);
                    }
                    entity.properties = attr || {}; //重新绑定，后续使用

                    //样式  
                    var symbol = config.symbol;
                    if (symbol) {
                        if (typeof symbol === 'function') {
                            //完全自定义的回调方法，自行处理entity
                            symbol(entity, entity.properties);
                        } else {
                            setConfigSymbol(entity, config);
                        }
                    }

                    //popup、鼠标事件等
                    bindMourseEvnet(entity, config);
                }

                return entities;
            }

            //根据config配置，更新entitys
            function style2Entity(entities, style) {
                for (var i = 0, len = entities.length; i < len; i++) {
                    var entity = entities[i];

                    //属性
                    var attr = (0, _util.getAttrVal)(entity.properties);
                    entity.properties = attr || {}; //重新绑定，后续使用

                    //样式  
                    setConfigSymbol(entity, { symbol: { styleOptions: style } });
                }
                return entities;
            }

            //外部配置的symbol
            function setConfigSymbol(entity, config) {
                var attr = entity.properties;

                var symbol = config.symbol;
                var styleOpt = symbol.styleOptions;

                if (symbol.styleField) {
                    //存在多个symbol，按styleField进行分类
                    var styleFieldVal = attr[symbol.styleField];
                    var styleOptField = symbol.styleFieldOptions[styleFieldVal];
                    if (styleOptField != null) {
                        styleOpt = (0, _util.clone)(styleOpt);
                        styleOpt = _zepto.zepto.extend(styleOpt, styleOptField);
                    }
                }

                //外部使用代码示例
                // var layerWork = viewer.mapv.getLayer(301087, "id")
                // layerWork.config.symbol.calback = function (attr, entity) {
                //     var val = Number(attr["floor"]._value);
                //     if (val < 10)
                //         return { color: "#ff0000" };
                //     else
                //         return { color: "#0000ff" };
                // }
                if (typeof symbol.calback === 'function') {
                    //只是动态返回symbol的自定义的回调方法，返回style
                    var styleOptField = symbol.calback(attr, entity, symbol);
                    if (!styleOptField) return;

                    styleOpt = (0, _util.clone)(styleOpt);
                    styleOpt = _zepto.zepto.extend(styleOpt, styleOptField);
                }
                styleOpt = styleOpt || {};

                //兼容v1历史的 label.field 定义方式
                if (styleOpt.label && styleOpt.label.field) styleOpt.label.text = "{" + styleOpt.label.field + "}";

                var entityCollection = entity.entityCollection; //entity原有的集合 

                if (entity.polyline) {
                    (0, _Attr4.style2Entity)(styleOpt, entity.polyline);

                    //线时，加上文字标签 
                    if (styleOpt.label && styleOpt.label.text) {
                        //计算中心点
                        var pots = (0, _Attr4.getPositions)(entity);
                        var position = pots[Math.floor(pots.length / 2)];
                        if (styleOpt.label.position) {
                            if (styleOpt.label.position == "center") {
                                position = (0, _point.centerOfMass)(pots);
                            } else if ((0, _util.isNumber)(styleOpt.label.position)) {
                                position = pots[styleOpt.label.position];
                            }
                        }

                        //文本属性
                        styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
                        var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                        var lblEx = entityCollection.add({
                            position: position,
                            label: labelattr,
                            properties: attr
                        });
                        bindMourseEvnet(lblEx, config);
                    }
                }
                if (entity.polygon) {
                    (0, _Attr5.style2Entity)(styleOpt, entity.polygon);

                    //加上线宽
                    if (styleOpt.outlineWidth && styleOpt.outlineWidth > 1) {
                        entity.polygon.outline = false;

                        var newopt = {
                            "color": styleOpt.outlineColor,
                            "width": styleOpt.outlineWidth,
                            "opacity": styleOpt.outlineOpacity,
                            "lineType": "solid",
                            "clampToGround": true,
                            "outline": false
                        };
                        var polyline = (0, _Attr4.style2Entity)(newopt);
                        polyline.positions = (0, _Attr5.getPositions)(entity);
                        var lineEx = entityCollection.add({
                            polyline: polyline,
                            properties: attr
                        });
                        bindMourseEvnet(lineEx, config);
                    }

                    //面时，加上文字标签 
                    if (styleOpt.label && styleOpt.label.text) {
                        styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                        var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                        var lblEx = entityCollection.add({
                            position: (0, _point.centerOfMass)((0, _Attr5.getPositions)(entity)),
                            label: labelattr,
                            properties: attr
                        });
                        bindMourseEvnet(lblEx, config);
                    }

                    //是建筑物时
                    if (config.buildings) {
                        var floor = Number(attr[config.buildings.cloumn] || 1); //层数

                        var height = 3.5; //层高
                        var heightCfg = config.buildings.height;
                        if ((0, _util.isNumber)(heightCfg)) {
                            height = heightCfg;
                        } else if ((0, _util.isString)(heightCfg)) {
                            height = attr[heightCfg] || height;
                        }

                        entity.polygon.extrudedHeight = floor * height;
                    }

                    //是建筑物单体化时
                    if (config.dth) {
                        entity.polygon.classificationType = Cesium.ClassificationType.BOTH;
                        if (!Cesium.defined(styleOpt.color)) entity.polygon.material = nullColor;
                        entity.polygon.perPositionHeight = false;
                        entity.polygon.zIndex = 99;
                    }
                }

                //entity本身存在文字标签 
                if (entity.label) {
                    styleOpt.label = styleOpt.label || styleOpt || {};
                    styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                    (0, _Attr2.style2Entity)(styleOpt.label, entity.label, attr);
                }

                if (entity.billboard) {
                    styleOpt.heightReference = Cesium.defaultValue(styleOpt.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);
                    (0, _Attr.style2Entity)(styleOpt, entity.billboard);

                    //图标时，加上文字标签 (entity本身不存在label时)
                    if (styleOpt.label && styleOpt.label.text && !entity.label) {
                        styleOpt.label.heightReference = Cesium.defaultValue(styleOpt.label.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                        var labelattr = (0, _Attr2.style2Entity)(styleOpt.label, null, attr);
                        var lblEx = entityCollection.add({
                            position: entity.position,
                            label: labelattr,
                            properties: attr
                        });
                        bindMourseEvnet(lblEx, config);
                    }

                    //支持小模型
                    if (styleOpt.model) {
                        styleOpt.model.heightReference = Cesium.defaultValue(styleOpt.model.heightReference, Cesium.HeightReference.CLAMP_TO_GROUND);

                        var modelattr = (0, _Attr3.style2Entity)(styleOpt.model);

                        var lblEx = entityCollection.add({
                            position: entity.position,
                            model: modelattr,
                            properties: attr
                        });
                        bindMourseEvnet(lblEx, config);
                    }
                }

                //记录下样式配置
                entity.styleOpt = styleOpt;
            }

            //鼠标事件，popup tooltip
            function bindMourseEvnet(entity, config) {
                //popup弹窗
                if (config.columns || config.popup) {
                    entity.popup = {
                        html: function html(entity) {
                            var attr = entity.properties;
                            if (attr && attr.type && attr.attr) {
                                //说明是内部标绘生产的geojson
                                attr = attr.attr;
                            }
                            if ((0, _util.isString)(attr)) return attr; else return (0, _util.getPopupForConfig)(config, attr);
                        },
                        anchor: config.popupAnchor || [0, -15]
                    };
                }
                if (config.tooltip) {
                    entity.tooltip = {
                        html: function html(entity) {
                            var attr = entity.properties;
                            if (attr && attr.type && attr.attr) {
                                //说明是内部标绘生产的geojson
                                attr = attr.attr;
                            }

                            if ((0, _util.isString)(attr)) return attr; else return (0, _util.getPopupForConfig)({ popup: config.tooltip }, attr);
                        },
                        anchor: config.tooltipAnchor || [0, -15]
                    };
                }

                if (config.click) {
                    entity.click = config.click;
                }
                if (config.mouseover) {
                    entity.mouseover = config.mouseover;
                }
                if (config.mouseout) {
                    entity.mouseout = config.mouseout;
                }
            }

            //单体化处理 
            var nullColor = new Cesium.Color(0.0, 0.0, 0.0, 0.01);
            var highlighted_hierarchy; //单体化坐标位置

            var highlighColor; //高亮时颜色
            var highlightedEntity; //单体化显示的面

            function mouseover(entity) {
                //移入 
                highlighted_hierarchy = entity.polygon.hierarchy.getValue((0, _util.currentTime)());
                highlightedEntity.polygon.show = true;

                highlightedEntity.properties = entity.properties;
                highlightedEntity.tooltip = entity.tooltip ? entity.tooltip : null;
                highlightedEntity.popup = entity.popup ? entity.popup : null;
            }

            function mouseout(entity) {
                //移出
                if (Cesium.defined(highlightedEntity)) {
                    highlightedEntity.polygon.show = false;
                }
            }

            //创建单体化显示的面【每个对象只用一次】
            function createDthEntity(dataSource, styleOpt) {
                styleOpt = styleOpt || {};

                if (!highlightedEntity) {
                    //高亮时颜色
                    highlighColor = new Cesium.Color.fromCssColorString(Cesium.defaultValue(styleOpt.color, "#ffff00")).withAlpha(Cesium.defaultValue(styleOpt.opacity, 0.3)); //高亮时颜色

                    //单体化显示的面
                    highlightedEntity = dataSource.entities.add({
                        name: "单体化高亮面",
                        noMouseMove: true, //标识下，内部不监听其移入事件 
                        polygon: {
                            perPositionHeight: false,
                            classificationType: Cesium.ClassificationType.BOTH,
                            material: highlighColor,
                            hierarchy: new Cesium.CallbackProperty(function (time) {
                                return highlighted_hierarchy;
                            }, false),
                            zIndex: 0
                        }
                    });
                }

                return {
                    mouseover: mouseover,
                    mouseout: mouseout
                };
            }

            /***/
}),
/* 29 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;
            exports.line2curve = line2curve;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _LineFlowMaterial = __webpack_require__(36);

            var _turf = __webpack_require__(35);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            // import { plotUtil } from '../../draw-ex/core/PlotUtil'


            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {};
                }

                if (style.clampToGround) {
                    entityattr.arcType = Cesium.ArcType.GEODESIC;
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "lineType": //跳过扩展其他属性的参数
                        case "color":
                        case "opacity":
                        case "outline":
                        case "outlineWidth":
                        case "outlineColor":
                        case "outlineOpacity":
                        case "flowDuration":
                        case "flowImage":
                        case "dashLength":
                        case "glowPower":

                        case "grid_lineCount":
                        case "grid_lineThickness":
                        case "grid_cellAlpha":
                        case "checkerboard_repeat":
                        case "checkerboard_oddcolor":
                        case "stripe_oddcolor":
                        case "stripe_repeat":
                        case "animationDuration":
                        case "animationImage":
                        case "animationRepeatX":
                        case "animationRepeatY":
                        case "animationAxisY":
                        case "animationGradient":
                        case "animationCount":
                        case "randomColor":
                            break;
                    }
                }

                if (style.color || style.lineType) {
                    var color = new Cesium.Color.fromCssColorString(style.color || "#FFFF00").withAlpha(Number(Cesium.defaultValue(style.opacity, 1.0)));

                    switch (style.lineType) {
                        default:
                        case "solid":
                            //实线 
                            if (style.outline) {
                                //存在衬色时
                                entityattr.material = new Cesium.PolylineOutlineMaterialProperty({
                                    color: color,
                                    outlineWidth: Number(style.outlineWidth || 1.0),
                                    outlineColor: new Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
                                });
                            } else {
                                entityattr.material = color;
                            }
                            break;
                        case "dash":
                            //虚线
                            if (style.outline) {
                                //存在衬色时
                                entityattr.material = new Cesium.PolylineDashMaterialProperty({
                                    dashLength: style.dashLength || style.outlineWidth || 16.0,
                                    color: color,
                                    gapColor: new Cesium.Color.fromCssColorString(style.outlineColor || "#FFFF00").withAlpha(Number(style.outlineOpacity || style.opacity || 1.0))
                                });
                            } else {
                                entityattr.material = new Cesium.PolylineDashMaterialProperty({
                                    dashLength: style.dashLength || 16.0,
                                    color: color
                                });
                            }

                            break;
                        case "glow":
                            //发光线
                            entityattr.material = new Cesium.PolylineGlowMaterialProperty({
                                glowPower: style.glowPower || 0.1,
                                color: color
                            });
                            break;
                        case "arrow":
                            //箭头线
                            entityattr.material = new Cesium.PolylineArrowMaterialProperty(color);
                            break;
                        case "animation":
                            //流动线 
                            entityattr.material = new _LineFlowMaterial.LineFlowMaterial({ //动画线材质
                                color: color,
                                duration: style.animationDuration || 2000, //时长，控制速度
                                url: style.animationImage //图片
                            });
                            break;
                    }
                }

                //材质优先
                if (style.material) entityattr.material = style.material;

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity, isShowPositions) {
                if (!isShowPositions && entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //曲线等情形时，取绑定的数据

                return entity.polyline.positions.getValue((0, _util.currentTime)());
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity, coordinates) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "LineString",
                        coordinates: coordinates
                    }
                };
            }

            //折线转曲线[基于bezierSpline算法]
            function line2curve(_positions_draw, closure) {
                var coordinates = _positions_draw.map(function (position) {
                    return pointconvert.cartesian2lonlat(position);
                });
                if (closure) //闭合曲线
                    coordinates.push(coordinates[0]);
                var defHeight = coordinates[coordinates.length - 1][2];

                var curved = (0, _turf.bezierSpline)({
                    type: "Feature",
                    geometry: {
                        type: "LineString",
                        coordinates: coordinates
                    }
                });
                var _positions_show = pointconvert.lonlats2cartesians(curved.geometry.coordinates, defHeight);
                return _positions_show;
            }

            //折线转曲线[基于自己的算法]
            // export function line2curve2(_positions_draw, closure) {
            //     var points = pointconvert.cartesians2mercators(_positions_draw);
            //     if (closure)//闭合曲线
            //         points.push(points[0]);

            //     var pointsNew = plotUtil.getBezierPoints(points);
            //     var _positions_show = pointconvert.mercators2cartesians(pointsNew);
            //     return _positions_show;
            // }

            /***/
}),
/* 30 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {
                        scale: 1,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                    };
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "scaleByDistance_near": //跳过扩展其他属性的参数
                        case "scaleByDistance_nearValue":
                        case "scaleByDistance_far":
                        case "scaleByDistance_farValue":
                        case "distanceDisplayCondition_far":
                        case "distanceDisplayCondition_near":
                            break;
                        case "opacity":
                            //透明度
                            entityattr.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Cesium.defaultValue(value, 1.0));
                            break;
                        case "rotation":
                            //旋转角度
                            entityattr.rotation = Cesium.Math.toRadians(value);
                            break;
                        case "scaleByDistance":
                            //是否按视距缩放
                            if (value) {
                                entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(Cesium.defaultValue(style.scaleByDistance_near, 1000)), Number(Cesium.defaultValue(style.scaleByDistance_nearValue, 1.0)), Number(Cesium.defaultValue(style.scaleByDistance_far, 1000000)), Number(Cesium.defaultValue(style.scaleByDistance_farValue, 0.1)));
                            } else {
                                entityattr.scaleByDistance = undefined;
                            }
                            break;
                        case "distanceDisplayCondition":
                            //是否按视距显示
                            if (value) {
                                entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(Cesium.defaultValue(style.distanceDisplayCondition_near, 0)), Number(Cesium.defaultValue(style.distanceDisplayCondition_far, 100000)));
                            } else {
                                entityattr.distanceDisplayCondition = undefined;
                            }
                            break;
                        case "clampToGround":
                            //贴地
                            if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND; else entityattr.heightReference = Cesium.HeightReference.NONE;
                            break;
                        case "heightReference":
                            switch (value) {
                                case "NONE":
                                    entityattr.heightReference = Cesium.HeightReference.NONE;
                                    break;
                                case "CLAMP_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                                    break;
                                case "RELATIVE_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                    break;
                                default:
                                    entityattr.heightReference = value;
                                    break;
                            }
                            break;
                        case "horizontalOrigin":
                            switch (value) {
                                case "CENTER":
                                    entityattr.horizontalOrigin = Cesium.HorizontalOrigin.CENTER;
                                    break;
                                case "LEFT":
                                    entityattr.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
                                    break;
                                case "RIGHT":
                                    entityattr.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
                                    break;
                                default:
                                    entityattr.horizontalOrigin = value;
                                    break;
                            }
                            break;
                        case "verticalOrigin":
                            switch (value) {
                                case "CENTER":
                                    entityattr.verticalOrigin = Cesium.VerticalOrigin.CENTER;
                                    break;
                                case "TOP":
                                    entityattr.verticalOrigin = Cesium.VerticalOrigin.TOP;
                                    break;
                                case "BOTTOM":
                                    entityattr.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
                                    break;
                                default:
                                    entityattr.verticalOrigin = value;
                                    break;
                            }
                            break;
                        case "visibleDepth":
                            if (value) entityattr.disableDepthTestDistance = 0; else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                            break;
                    }
                }

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 31 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "silhouette": //跳过扩展其他属性的参数
                        case "silhouetteColor":
                        case "silhouetteAlpha":
                        case "silhouetteSize":
                        case "fill":
                        case "color":
                        case "opacity":
                            break;
                        case "modelUrl":
                            //模型uri
                            entityattr.uri = value;
                            break;

                        case "clampToGround":
                            //贴地
                            if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND; else entityattr.heightReference = Cesium.HeightReference.NONE;
                            break;
                        case "heightReference":
                            switch (value) {
                                case "NONE":
                                    entityattr.heightReference = Cesium.HeightReference.NONE;
                                    break;
                                case "CLAMP_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                                    break;
                                case "RELATIVE_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                    break;
                                default:
                                    entityattr.heightReference = value;
                                    break;
                            }
                            break;
                    }
                }

                //轮廓
                if (style.silhouette) {
                    entityattr.silhouetteColor = new Cesium.Color.fromCssColorString(style.silhouetteColor || "#FFFFFF").withAlpha(Number(style.silhouetteAlpha || 1.0));
                    entityattr.silhouetteSize = Number(style.silhouetteSize || 1.0);
                } else entityattr.silhouetteSize = 0.0;

                //透明度、颜色
                var opacity = style.hasOwnProperty('opacity') ? Number(style.opacity) : 1;
                if (style.fill) entityattr.color = new Cesium.Color.fromCssColorString(style.color || "#FFFFFF").withAlpha(opacity); else entityattr.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(opacity);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                var position = entity.position;
                if (position && position.getValue) position = position.getValue((0, _util.currentTime)());

                return [position];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 32 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawBase = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            var _MapVClass = __webpack_require__(23);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawBase = exports.DrawBase = _MapVClass.MapVClass.extend({
                type: null,
                dataSource: null,
                initialize: function initialize(opts) {
                    this.viewer = opts.viewer;
                    this.dataSource = opts.dataSource;
                    this.primitives = opts.primitives;

                    if (!this.dataSource) {
                        //没有单独指定Cesium.CustomDataSource时
                        this.dataSource = new Cesium.CustomDataSource();
                        this.viewer.dataSources.add(this.dataSource);
                    }
                    this.tooltip = opts.tooltip || new Tooltip(this.viewer.container);
                },
                fire: function fire(type, data, propagate) {
                    if (this._fire) this._fire(type, data, propagate);
                },
                formatNum: function formatNum(num, digits) {
                    return Util.formatNum(num, digits);
                },
                enableControl: function enableControl(value) {
                    if (this.viewer.mapv.popup) this.viewer.mapv.popup.enable = value;
                    if (this.viewer.mapv.tooltip) this.viewer.mapv.tooltip.enable = value;
                },
                //激活绘制
                activate: function activate(attribute, drawOkCalback) {
                    if (this._enabled) {
                        return this;
                    }
                    this._enabled = true;
                    this.drawOkCalback = drawOkCalback;

                    this.createFeature(attribute);
                    this.entity.inProgress = true;

                    this.setCursor(true);
                    this.enableControl(false);
                    this.bindEvent();

                    this.fire(EventType.DrawStart, { drawtype: this.type, entity: this.entity });

                    return this.entity;
                },
                //释放绘制
                disable: function disable(hasWB) {
                    if (!this._enabled) {
                        return this;
                    }
                    this._enabled = false;

                    this.setCursor(false);
                    this.enableControl(true);

                    if (hasWB && this.entity.inProgress) {
                        //外部释放时，尚未结束的标绘移除。
                        if (this.dataSource && this.dataSource.entities.contains(this.entity)) this.dataSource.entities.remove(this.entity);

                        if (this.primitives && this.primitives.contains(this.entity)) this.primitives.remove(this.entity);
                    } else {
                        this.entity.inProgress = false;
                        this.finish();

                        if (this.drawOkCalback) {
                            this.drawOkCalback(this.entity);
                            delete this.drawOkCalback;
                        }
                        this.fire(EventType.DrawCreated, { drawtype: this.type, entity: this.entity });
                    }

                    this.destroyHandler();
                    this._positions_draw = null;
                    this.entity = null;
                    this.tooltip.setVisible(false);

                    return this;
                },
                createFeature: function createFeature(attribute) { },
                //============= 事件相关 ============= 
                getHandler: function getHandler() {
                    if (!this.handler || this.handler.isDestroyed()) {
                        this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
                    }
                    return this.handler;
                },
                destroyHandler: function destroyHandler() {
                    this.handler && this.handler.destroy();
                    this.handler = undefined;
                },
                setCursor: function setCursor(val) {
                    this.viewer._container.style.cursor = val ? 'crosshair' : '';
                },
                //绑定鼠标事件
                bindEvent: function bindEvent() { },
                //=============  ============= 
                //坐标位置相关
                _positions_draw: null,
                getDrawPosition: function getDrawPosition() {
                    return this._positions_draw;
                },
                //获取编辑对象  
                editClass: null,
                getEditClass: function getEditClass(entity) {
                    if (this.editClass == null) return null;

                    var _edit = new this.editClass(entity, this.viewer, this.dataSource);
                    if (this._minPointNum != null) _edit._minPointNum = this._minPointNum;
                    if (this._maxPointNum != null) _edit._maxPointNum = this._maxPointNum;

                    _edit._fire = this._fire;
                    _edit.tooltip = this.tooltip;

                    return _edit;
                },
                //更新坐标后调用下，更新相关属性，子类使用
                updateAttrForDrawing: function updateAttrForDrawing(isLoad) { },
                //图形绘制结束后调用
                finish: function finish() { },
                //对应的属性控制静态类
                attrClass: null,
                //通用方法
                getCoordinates: function getCoordinates(entity) {
                    return this.attrClass.getCoordinates(entity);
                },
                getPositions: function getPositions(entity) {
                    return this.attrClass.getPositions(entity);
                },
                toGeoJSON: function toGeoJSON(entity) {
                    return this.attrClass.toGeoJSON(entity);
                },
                //属性转entity
                attributeToEntity: function attributeToEntity(attribute, positions) {
                    var entity = this.createFeature(attribute);
                    this._positions_draw = positions;
                    this.updateAttrForDrawing(true);
                    this.finish();
                    return entity;
                },
                //geojson转entity
                jsonToEntity: function jsonToEntity(geojson) {
                    var attribute = geojson.properties;
                    var positions = Util.getPositionByGeoJSON(geojson);
                    return this.attributeToEntity(attribute, positions);
                },
                setDrawPositionByEntity: function setDrawPositionByEntity(entity) {
                    var positions = this.getPositions(entity);
                    this._positions_draw = positions;
                },
                //绑定外部entity到标绘
                bindExtraEntity: function bindExtraEntity(entity, attribute) {
                    this.entity = entity;
                    entity.attribute = attribute;

                    if (attribute.style) this.style2Entity(attribute.style, entity);

                    this.setDrawPositionByEntity(entity);

                    this.updateAttrForDrawing(true);
                    this.finish();
                    return entity;
                }

            });

            /***/
}),
/* 33 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.interPolyline = interPolyline;
            exports.computeSurfaceLine = computeSurfaceLine;
            exports.computeSurfacePoints = computeSurfacePoints;
            exports.getLinkedPointList = getLinkedPointList;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _layer = __webpack_require__(20);

            var _util = __webpack_require__(1);

            var _tileset = __webpack_require__(27);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //路线进行贴地(或贴模型)插值, splitNum为次数 
            function interPolyline(opts) {
                var positions = opts.positions;
                var scene = opts.scene;

                var granularity = (0, _util.getGranularity)(positions, opts.splitNum || 100);
                if (granularity <= 0) granularity = null;

                var flatPositions = Cesium.PolylinePipeline.generateArc({
                    positions: positions,
                    height: opts.height, //未传入时，内部默认为0
                    minDistance: opts.minDistance, //插值间隔(米)，优先级高于granularity
                    granularity: granularity //splitNum分割的个数
                });

                var arr = [];
                for (var i = 0; i < flatPositions.length; i += 3) {
                    var position = Cesium.Cartesian3.unpack(flatPositions, i);
                    if (scene && Cesium.defaultValue(opts.surfaceHeight, true)) {
                        var height = (0, _point.getSurfaceHeight)(scene, position, opts);
                        var car = Cesium.Cartographic.fromCartesian(position);
                        position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
                    }
                    arr.push(position);
                }
                return arr;
            }

            //计算贴地(或贴模型)路线（异步）
            var surfaceLineWork = {
                start: function start(params) {
                    this.params = params;
                    this.viewer = params.viewer;

                    var positions = params.positions;
                    if (positions == null || positions.length == 0) {
                        //无数据
                        this.end(positions);
                        return;
                    }

                    var _has3dtiles = Cesium.defaultValue(params.has3dtiles, Cesium.defined((0, _tileset.pick3DTileset)(this.viewer, positions))); //是否在3ditiles上面
                    var _hasTerrain = (0, _layer.hasTerrain)(this.viewer); //是否有地形

                    if (!_hasTerrain && !_has3dtiles) {
                        //无地形和无模型时，直接返回
                        this.end(positions);
                        return;
                    }

                    //线中间插值
                    var _split = Cesium.defaultValue(params.split, true);
                    if (_split) {
                        positions = interPolyline({
                            scene: this.viewer.scene,
                            positions: positions,
                            height: params.height,
                            minDistance: params.minDistance,
                            splitNum: Cesium.defaultValue(params.splitNum, 100)
                        });
                    }

                    //开始分析
                    this._has3dtiles = _has3dtiles;
                    if (_hasTerrain) {
                        this.clampToTerrain(positions);
                    } else {
                        this.clampTo3DTileset(positions);
                    }
                    return this;
                },
                clampToTerrain: function clampToTerrain(positions) {
                    var ellipsoid = this.viewer.scene.globe.ellipsoid;
                    var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(positions);

                    //用于缺少地形数据时，赋值的高度
                    var tempHeight = Cesium.Cartographic.fromCartesian(positions[0]).height;

                    var that = this;
                    Cesium.when(Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, cartographicArray), function (samples) {
                        var noHeight = false;
                        var offset = that.params.offset || 2; //增高高度，便于可视

                        for (var i = 0; i < samples.length; ++i) {
                            if (samples[i].height == null) {
                                noHeight = true;
                                samples[i].height = tempHeight;
                            } else {
                                samples[i].height = offset + samples[i].height * that.viewer.scene._terrainExaggeration;
                            }
                        }

                        var raisedPositions = ellipsoid.cartographicArrayToCartesianArray(samples);

                        if (that._has3dtiles) {
                            that.clampTo3DTileset(raisedPositions);
                        } else {
                            that.end(raisedPositions, noHeight);
                        }
                    });
                },
                clampTo3DTileset: function clampTo3DTileset(positions) {
                    var that = this;
                    this.viewer.scene.clampToHeightMostDetailed(positions).then(function (clampedCartesians) {
                        that.end(clampedCartesians);
                    });
                },
                end: function end(raisedPositions, noHeight) {
                    if (this.params.calback) this.params.calback(raisedPositions, noHeight); else if (this.positions && this.positions.setValue) this.positions.setValue(raisedPositions);
                }
            };

            //对外接口,求路线的贴地线
            function computeSurfaceLine(params) {
                return surfaceLineWork.start(params);
            }

            //对外接口,求多个点的的贴地新坐标（不插值）
            function computeSurfacePoints(params) {
                params.split = false;
                return surfaceLineWork.start(params);
            }

            /**
             * 计算曲线链路的点集（a点到b点的，空中曲线）
             * @param startPoint 开始节点
             * @param endPoint 结束节点
             * @param angularityFactor 曲率
             * @param numOfSingleLine 点集数量
             * @returns {Array}
             */
            function getLinkedPointList(startPoint, endPoint, angularityFactor, numOfSingleLine) {
                var result = [];

                var startPosition = Cesium.Cartographic.fromCartesian(startPoint);
                var endPosition = Cesium.Cartographic.fromCartesian(endPoint);

                var startLon = startPosition.longitude * 180 / Math.PI;
                var startLat = startPosition.latitude * 180 / Math.PI;
                var endLon = endPosition.longitude * 180 / Math.PI;
                var endLat = endPosition.latitude * 180 / Math.PI;

                var dist = Math.sqrt((startLon - endLon) * (startLon - endLon) + (startLat - endLat) * (startLat - endLat));

                //var dist = Cesium.Cartesian3.distance(startPoint, endPoint);
                var angularity = dist * angularityFactor;

                var startVec = Cesium.Cartesian3.clone(startPoint);
                var endVec = Cesium.Cartesian3.clone(endPoint);

                var startLength = Cesium.Cartesian3.distance(startVec, Cesium.Cartesian3.ZERO);
                var endLength = Cesium.Cartesian3.distance(endVec, Cesium.Cartesian3.ZERO);

                Cesium.Cartesian3.normalize(startVec, startVec);
                Cesium.Cartesian3.normalize(endVec, endVec);

                if (Cesium.Cartesian3.distance(startVec, endVec) == 0) {
                    return result;
                }

                //var cosOmega = Cesium.Cartesian3.dot(startVec, endVec);
                //var omega = Math.acos(cosOmega);

                var omega = Cesium.Cartesian3.angleBetween(startVec, endVec);

                result.push(startPoint);
                for (var i = 1; i < numOfSingleLine - 1; i++) {
                    var t = i * 1.0 / (numOfSingleLine - 1);
                    var invT = 1 - t;

                    var startScalar = Math.sin(invT * omega) / Math.sin(omega);
                    var endScalar = Math.sin(t * omega) / Math.sin(omega);

                    var startScalarVec = Cesium.Cartesian3.multiplyByScalar(startVec, startScalar, new Cesium.Cartesian3());
                    var endScalarVec = Cesium.Cartesian3.multiplyByScalar(endVec, endScalar, new Cesium.Cartesian3());

                    var centerVec = Cesium.Cartesian3.add(startScalarVec, endScalarVec, new Cesium.Cartesian3());

                    var ht = t * Math.PI;
                    var centerLength = startLength * invT + endLength * t + Math.sin(ht) * angularity;
                    centerVec = Cesium.Cartesian3.multiplyByScalar(centerVec, centerLength, centerVec);

                    result.push(centerVec);
                }

                result.push(endPoint);

                return result;
            }

            /***/
}),
/* 34 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ArrowParent = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //箭头的父类 
            var ArrowParent = exports.ArrowParent = function () {
                function ArrowParent() {
                    _classCallCheck(this, ArrowParent);

                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(ArrowParent, [{
                    key: "getArrowHeadPoints",
                    value: function getArrowHeadPoints(points, tailLeft, tailRight) {
                        var len = this.plotUtil.getBaseLength(points);
                        var headHeight = len * this.headHeightFactor;
                        var headPnt = points[points.length - 1];
                        len = this.plotUtil.MathDistance(headPnt, points[points.length - 2]);
                        var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
                        if (headHeight > tailWidth * this.headTailFactor) {
                            headHeight = tailWidth * this.headTailFactor;
                        }
                        var headWidth = headHeight * this.headWidthFactor;
                        var neckWidth = headHeight * this.neckWidthFactor;
                        headHeight = headHeight > len ? len : headHeight;
                        var neckHeight = headHeight * this.neckHeightFactor;
                        var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
                        var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
                        var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
                        var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
                        var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
                        var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
                        return [neckLeft, headLeft, headPnt, headRight, neckRight];
                    }
                }, {
                    key: "getArrowBodyPoints",
                    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
                        var allLen = this.plotUtil.wholeDistance(points);
                        var len = this.plotUtil.getBaseLength(points);
                        var tailWidth = len * tailWidthFactor;
                        var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
                        var widthDif = (tailWidth - neckWidth) / 2;
                        var tempLen = 0,
                            leftBodyPnts = [],
                            rightBodyPnts = [];

                        for (var i = 1; i < points.length - 1; i++) {
                            var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                            tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
                            var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                            var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                            var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
                            leftBodyPnts.push(left);
                            rightBodyPnts.push(right);
                        }
                        return leftBodyPnts.concat(rightBodyPnts);
                    }
                }]);

                return ArrowParent;
            }();

            /***/
}),
/* 35 */
/***/ (function (module, exports) {

            module.exports = __WEBPACK_EXTERNAL_MODULE__35__;

            /***/
}),
/* 36 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.LineFlowMaterial = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _LineFlow = __webpack_require__(80);

            var _LineFlow2 = _interopRequireDefault(_LineFlow);

            var _LineFlow3 = __webpack_require__(81);

            var _LineFlow4 = _interopRequireDefault(_LineFlow3);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var defaultColor = new Cesium.Color(0, 0, 0, 0);
            var defaultBgColor = new Cesium.Color(1, 1, 1);

            //线状 流动效果 材质

            var LineFlowMaterial = exports.LineFlowMaterial = function () {
                //========== 构造方法 ========== 
                function LineFlowMaterial(options) {
                    _classCallCheck(this, LineFlowMaterial);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    this._definitionChanged = new Cesium.Event();
                    this._color = undefined;
                    this._colorSubscription = undefined;

                    this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
                    this.url = Cesium.defaultValue(options.url, undefined); //背景图片颜色
                    if (!this.url) return;

                    this.axisY = Boolean(options.axisY);
                    this.bgUrl = Cesium.defaultValue(options.bgUrl, undefined); //背景图片颜色
                    this.bgColor = Cesium.defaultValue(options.bgColor, defaultBgColor); //背景图片颜色
                    this._duration = options.duration || 1000; //时长

                    var _material = getImageMaterial(this.url, this.bgUrl, options.repeat, Boolean(options.axisY), this.bgColor);

                    this._materialType = _material.type; //材质类型
                    this._materialImage = _material.image; //材质图片
                    this._time = undefined;
                }

                //========== 对外属性 ==========   


                _createClass(LineFlowMaterial, [{
                    key: "getType",


                    //========== 方法 ========== 

                    /**
                     * Gets the {@link Cesium.Material} type at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the type.
                     * @returns {String} The type of material.
                     */
                    value: function getType(time) {
                        return this._materialType;
                    }

                    /**
                     * Gets the value of the property at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the value.
                     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
                     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
                     */

                }, {
                    key: "getValue",
                    value: function getValue(time, result) {
                        if (!Cesium.defined(result)) {
                            result = {};
                        }
                        result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
                        result.image = this._materialImage;
                        if (this._time === undefined) {
                            this._time = new Date().getTime();
                        }
                        result.time = (new Date().getTime() - this._time) / this._duration;
                        return result;
                    }

                    /**
                     * Compares this property to the provided property and returns
                     * <code>true</code> if they are equal, <code>false</code> otherwise.
                     *
                     * @param {Cesium.Property} [other] The other property.
                     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
                     */

                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this === other || //
                            other instanceof LineFlowMaterial && Cesium.Property.equals(this._color, other._color);
                    }
                }, {
                    key: "isConstant",
                    get: function get() {
                        return false;
                    }
                }, {
                    key: "definitionChanged",
                    get: function get() {
                        return this._definitionChanged;
                    }
                }]);

                return LineFlowMaterial;
            }();

            Object.defineProperties(LineFlowMaterial.prototype, {
                /**
                 * Gets or sets the Cesium.Property specifying the {@link Cesium.Color} of the line.
                 * @memberof PolylineGlowMaterialProperty.prototype
                 * @type {Cesium.Property}
                 */
                color: Cesium.createPropertyDescriptor('color')
            });

            //静态方法，处理材质
            var cacheIdx = 0;
            var nameEx = "AnimationLine";
            function getImageMaterial(imgurl, bgUrl, repeat, axisY, bgColor) {
                cacheIdx++;
                var typeName = nameEx + cacheIdx + "Type";
                var imageName = nameEx + cacheIdx + "Image";

                Cesium.Material[typeName] = typeName;
                Cesium.Material[imageName] = imgurl;

                if (bgUrl) {
                    //存在2张url的，用叠加融合的效果
                    Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
                        fabric: {
                            type: Cesium.Material.PolylineArrowLinkType,
                            uniforms: {
                                color: new Cesium.Color(1, 0, 0, 1.0),
                                image: Cesium.Material[imageName],
                                time: 0,
                                repeat: repeat || new Cesium.Cartesian2(1.0, 1.0),
                                axisY: axisY,
                                image2: bgUrl,
                                bgColor: bgColor
                            },
                            source: _LineFlow4.default
                        },
                        translucent: function translucent() {
                            return true;
                        }
                    });
                } else {
                    Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
                        fabric: {
                            type: typeName,
                            uniforms: {
                                color: new Cesium.Color(1, 0, 0, 1.0),
                                image: Cesium.Material[imageName],
                                time: 0,
                                repeat: repeat || new Cesium.Cartesian2(1.0, 1.0),
                                axisY: axisY
                            },
                            source: _LineFlow2.default
                        },
                        translucent: function translucent() {
                            return true;
                        }
                    });
                }

                return {
                    type: Cesium.Material[typeName],
                    image: Cesium.Material[imageName]
                };
            }

            /***/
}),
/* 37 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CustomFeatureGridLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _FeatureGridLayer = __webpack_require__(85);

            var _config2Entity2 = __webpack_require__(28);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //分块加载矢量数据公共类
            var CustomFeatureGridLayer = _FeatureGridLayer.FeatureGridLayer.extend({
                _cacheGrid: {}, //网格缓存,存放矢量对象id集合
                _cacheFeature: {}, //矢量对象缓存,存放矢量对象和其所对应的网格集合 
                _addImageryCache: function _addImageryCache(opts) {
                    this._cacheGrid[opts.key] = { opts: opts, isLoading: true };

                    var that = this;

                    this.getDataForGrid(opts, function (arrdata) {
                        if (that._visible) that._showData(opts, arrdata);
                    });
                },
                getDataForGrid: function getDataForGrid(opts, calback) {
                    //子类可继承, calback为回调方法,calback参数传数据数组

                    //直接使用本类,传参方式
                    if (this.config.getDataForGrid) {
                        this.config.getDataForGrid(opts, calback);
                    }
                },
                checkHasBreak: function checkHasBreak(cacheKey) {
                    if (!this._visible || !this._cacheGrid[cacheKey]) {
                        return true;
                    }
                    return false;
                },
                _showData: function _showData(opts, arrdata) {
                    var cacheKey = opts.key;
                    if (this.checkHasBreak[cacheKey]) {
                        return; //异步请求结束时,如果已经卸载了网格就直接跳出。
                    }

                    var that = this;

                    var arrIds = [];
                    for (var i = 0, len = arrdata.length; i < len; i++) {
                        var attributes = arrdata[i];
                        var id = attributes[this.config.IdName || 'id'];

                        var layer = this._cacheFeature[id];
                        if (layer) {
                            //已存在
                            layer.grid.push(cacheKey);
                            this.updateEntity(layer.entity, attributes);
                        } else {
                            var entity = this.createEntity(opts, attributes, function (entity) {
                                if (that.config.debuggerTileInfo) {
                                    //测试用
                                    entity._temp_id = id;
                                    entity.popup = function (entity) {
                                        return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
                                    };
                                }
                                that._cacheFeature[id] = {
                                    grid: [cacheKey],
                                    entity: entity
                                };
                                if (that.config.onEachEntity) //添加到地图后回调方法
                                    that.config.onEachEntity(entity, that);
                            });
                            if (entity != null) {
                                if (that.config.debuggerTileInfo) {
                                    //测试用
                                    entity._temp_id = id;
                                    entity.popup = function (entity) {
                                        return JSON.stringify(that._cacheFeature[entity._temp_id].grid);
                                    };
                                }
                                that._cacheFeature[id] = {
                                    grid: [cacheKey],
                                    entity: entity
                                };
                                if (that.config.onEachEntity) //添加到地图后回调方法
                                    that.config.onEachEntity(entity, that);
                            }
                        }
                        arrIds.push(id);
                    }

                    this._cacheGrid[cacheKey] = this._cacheGrid[cacheKey] || {};
                    this._cacheGrid[cacheKey].ids = arrIds;
                    this._cacheGrid[cacheKey].isLoading = false;
                },

                createEntity: function createEntity(opts, attributes, calback) {
                    //子类可以继承,根据数据创造entity

                    //直接使用本类,传参方式
                    if (this.config.createEntity) {
                        return this.config.createEntity(opts, attributes, calback);
                    }
                    return null;
                },
                updateEntity: function updateEntity(enetity, attributes) {
                    //子类可以继承,更新entity（动态数据时有用）

                    //直接使用本类,传参方式
                    if (this.config.updateEntity) {
                        this.config.updateEntity(enetity, attributes);
                    }
                },
                removeEntity: function removeEntity(enetity) {
                    //子类可以继承,移除entity

                    //直接使用本类,传参方式
                    if (this.config.removeEntity) {
                        this.config.removeEntity(enetity);
                    } else {
                        this.dataSource.entities.remove(enetity);
                    }
                },
                _removeImageryCache: function _removeImageryCache(opts) {
                    var cacheKey = opts.key;
                    var layers = this._cacheGrid[cacheKey];
                    if (layers) {
                        if (layers.ids) {
                            for (var i = 0; i < layers.ids.length; i++) {
                                var id = layers.ids[i];
                                var layer = this._cacheFeature[id];
                                if (layer) {
                                    layer.grid.remove(cacheKey);
                                    if (layer.grid.length == 0) {
                                        delete this._cacheFeature[id];
                                        this.removeEntity(layer.entity);
                                    }
                                }
                            }
                        }
                        delete this._cacheGrid[cacheKey];
                    }
                },
                _removeAllImageryCache: function _removeAllImageryCache() {

                    if (this.config.removeAllEntity) {
                        this.config.removeAllEntity();
                    } else {
                        this.dataSource.entities.removeAll();
                        this.primitives.removeAll();
                    }

                    this._cacheFeature = {};
                    this._cacheGrid = {};
                },
                //移除 
                removeEx: function removeEx() {
                    if (this.config.removeAllEntity) {
                        this.config.removeAllEntity();
                    } else {
                        this.dataSource.entities.removeAll();
                        this.primitives.removeAll();
                    }

                    this._cacheFeature = {};
                    this._cacheGrid = {};

                    this.viewer.dataSources.remove(this.dataSource);
                    this.viewer.scene.primitives.remove(this.primitives);
                },
                //重新加载数据
                reload: function reload() {
                    var that = this;
                    for (var i in this._cacheGrid) {
                        var item = this._cacheGrid[i];
                        if (item == null || item.opts == null || item.isLoading) continue;

                        var opts = item.opts;
                        this.getDataForGrid(opts, function (arrdata) {
                            that._showData(opts, arrdata);
                        });
                    }
                },

                //设置透明度
                hasOpacity: true,
                _opacity: 1,
                setOpacity: function setOpacity(value) {
                    this._opacity = value;

                    for (var i in this._cacheFeature) {
                        var entity = this._cacheFeature[i].entity;

                        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
                            this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
                            if (entity.polygon.outlineColor) {
                                this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
                            }
                        }

                        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
                            this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
                        }

                        if (entity.billboard) {
                            entity.billboard.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                        }

                        if (entity.model) {
                            entity.model.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                        }

                        if (entity.label) {
                            var _opacity = this._opacity;
                            if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

                            if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
                            if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
                            if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
                        }
                    }
                },
                _updatEntityAlpha: function _updatEntityAlpha(color, opacity) {
                    if (!color) return;
                    var newclr = color.getValue(this.viewer.clock.currentTime);
                    if (!newclr || !newclr.withAlpha) return color;

                    newclr = newclr.withAlpha(opacity);
                    color.setValue(newclr);
                },

                //获取属性
                getEntityAttr: function getEntityAttr(entity) {
                    return (0, _util.getAttrVal)(entity.properties);
                },
                //根据config配置，更新entitys 
                config2Entity: function config2Entity(entity) {
                    return (0, _config2Entity2.config2Entity)([entity], this.config);
                }

            });

            exports.CustomFeatureGridLayer = CustomFeatureGridLayer;

            /***/
}),
/* 38 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "scaleByDistance_near":
                        case "scaleByDistance_nearValue":
                        case "scaleByDistance_far":
                        case "scaleByDistance_farValue":
                        case "distanceDisplayCondition_far":
                        case "distanceDisplayCondition_near":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.color = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "scaleByDistance":
                            //是否按视距缩放
                            if (value) {
                                entityattr.scaleByDistance = new Cesium.NearFarScalar(Number(style.scaleByDistance_near || 1000), Number(style.scaleByDistance_nearValue || 1.0), Number(style.scaleByDistance_far || 1000000), Number(style.scaleByDistance_farValue || 0.1));
                            } else {
                                entityattr.scaleByDistance = undefined;
                            }
                            break;
                        case "distanceDisplayCondition":
                            //是否按视距显示
                            if (value) {
                                entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(style.distanceDisplayCondition_near || 0), Number(style.distanceDisplayCondition_far || 100000));
                            } else {
                                entityattr.distanceDisplayCondition = undefined;
                            }
                            break;

                        case "clampToGround":
                            //贴地
                            if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND; else entityattr.heightReference = Cesium.HeightReference.NONE;
                            break;
                        case "heightReference":
                            switch (value) {
                                case "NONE":
                                    entityattr.heightReference = Cesium.HeightReference.NONE;
                                    break;
                                case "CLAMP_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                                    break;
                                case "RELATIVE_TO_GROUND":
                                    entityattr.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                    break;
                                default:
                                    entityattr.heightReference = value;
                                    break;
                            }
                            break;

                        case "visibleDepth":
                            if (value) entityattr.disableDepthTestDistance = 0; else entityattr.disableDepthTestDistance = Number.POSITIVE_INFINITY; //一直显示，不被地形等遮挡

                            break;
                    }
                }

                //无边框时，需设置宽度为0
                if (!style.outline) entityattr.outlineWidth = 0.0;

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 39 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GeoJsonLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _config2Entity = __webpack_require__(28);

            var _BaseLayer = __webpack_require__(13);

            var _zepto = __webpack_require__(6);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var GeoJsonLayer = _BaseLayer.BaseLayer.extend({
                dataSource: null,
                //添加 
                add: function add() {
                    if (!this.config.reload && this.dataSource) {
                        //this.config.reload可以外部控制每次都重新请求数据
                        this.viewer.dataSources.add(this.dataSource);
                    } else {
                        this.queryData();
                    }
                },
                //移除
                remove: function remove() {
                    this.viewer.dataSources.remove(this.dataSource);
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    if (this.config.extent || this.config.center) {
                        this.viewer.mapv.centerAt(this.config.extent || this.config.center, { duration: duration, isWgs84: true });
                    } else {
                        if (this.dataSource == null) return;
                        this.viewer.flyTo(this.dataSource.entities.values, { duration: duration });
                    }
                },
                clearData: function clearData() {
                    if (this.dataSource) this.dataSource.entities.removeAll();
                },
                setData: function setData(geojson) {
                    //兼容不同命名
                    this.clearData();
                    return this.queryData(geojson);
                },
                getLoadConfig: function getLoadConfig() {
                    var config = (0, _util.getProxyUrl)(this.config);
                    if (config.symbol && config.symbol.styleOptions) {
                        var style = config.symbol.styleOptions;
                        if (Cesium.defined(style.clampToGround)) {
                            config.clampToGround = style.clampToGround;
                        }
                        if (Cesium.defined(style.color)) {
                            var color = new Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
                            config.fill = color;
                        }
                        if (Cesium.defined(style.outlineColor)) {
                            var outlineColor = new Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                            config.stroke = outlineColor;
                        }
                        if (Cesium.defined(style.outlineWidth)) {
                            config.strokeWidth = style.outlineWidth;
                        }
                    }
                    return config;
                },
                queryData: function queryData(geojson) {
                    var that = this;

                    var config = this.getLoadConfig();
                    geojson = geojson || config.url || config.data;
                    if (!geojson) return; //没有需要加载的对象

                    if (config.url) {
                        _zepto.zepto.ajax({
                            type: "get",
                            dataType: "json",
                            url: config.url,
                            timeout: Cesium.defaultValue(config.timeout, 0), //永不超时
                            success: function success(geojson) {
                                var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
                                dataSource.then(function (dataSource) {
                                    that.showResult(dataSource);
                                }).otherwise(function (error) {
                                    that.showError("服务出错", error);
                                });
                            },
                            error: function error(XMLHttpRequest, textStatus, errorThrown) {
                                console.log(config.url + "文件加载失败！");
                            }
                        });
                    } else {
                        var dataSource = Cesium.GeoJsonDataSource.load(geojson, config);
                        dataSource.then(function (dataSource) {
                            that.showResult(dataSource);
                        }).otherwise(function (error) {
                            that.showError("服务出错", error);
                        });
                    }
                },
                showResult: function showResult(dataSource) {
                    var _this = this;

                    if (this.dataSource) {
                        this.viewer.dataSources.remove(this.dataSource);
                    }

                    if (!this._visible) return;

                    this.dataSource = dataSource;
                    this.viewer.dataSources.add(dataSource);

                    //是建筑物单体化时
                    if (this.config.dth) {
                        var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.config.dth);
                        this.config.mouseover = dthEvent.mouseover;
                        this.config.mouseout = dthEvent.mouseout;
                    }

                    if (this.config.flyTo) this.centerAt();

                    if (this.config.calback) {
                        this.config.calback(dataSource);
                    }

                    //根据config配置，更新entitys 
                    this.config.getAttrVal = function (entity) {
                        return _this.getEntityAttr(entity);
                    };
                    var entities = dataSource.entities.values;
                    (0, _config2Entity.config2Entity)(entities, this.config);

                    if (this._opacity != 1) this.setOpacity(this._opacity);
                },

                //设置透明度
                hasOpacity: true,
                _opacity: 1,
                setOpacity: function setOpacity(value) {
                    this._opacity = value;
                    if (this.dataSource == null) return;

                    var entities = this.dataSource.entities.values;

                    for (var i = 0, len = entities.length; i < len; i++) {
                        var entity = entities[i];

                        if (entity.polygon && entity.polygon.material && entity.polygon.material.color) {
                            this._updatEntityAlpha(entity.polygon.material.color, this._opacity);
                            if (entity.polygon.outlineColor) {
                                this._updatEntityAlpha(entity.polygon.outlineColor, this._opacity);
                            }
                        }

                        if (entity.polyline && entity.polyline.material && entity.polyline.material.color) {
                            this._updatEntityAlpha(entity.polyline.material.color, this._opacity);
                        }

                        if (entity.billboard) {
                            entity.billboard.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                        }

                        if (entity.model) {
                            entity.model.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(this._opacity);
                        }

                        if (entity.label) {
                            var _opacity = this._opacity;
                            if (entity.styleOpt && entity.styleOpt.label && entity.styleOpt.label.opacity) _opacity = entity.styleOpt.label.opacity;

                            if (entity.label.fillColor) this._updatEntityAlpha(entity.label.fillColor, _opacity);
                            if (entity.label.outlineColor) this._updatEntityAlpha(entity.label.outlineColor, _opacity);
                            if (entity.label.backgroundColor) this._updatEntityAlpha(entity.label.backgroundColor, _opacity);
                        }
                    }
                },
                _updatEntityAlpha: function _updatEntityAlpha(color, opacity) {
                    if (!color) return;
                    var newclr = color.getValue(this.viewer.clock.currentTime);
                    if (!newclr || !newclr.withAlpha) return color;

                    newclr = newclr.withAlpha(opacity);
                    color.setValue(newclr);
                },

                //获取属性
                getEntityAttr: function getEntityAttr(entity) {
                    return (0, _util.getAttrVal)(entity.properties);
                }

            });

            exports.GeoJsonLayer = GeoJsonLayer;

            /***/
}),
/* 40 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;
            exports.getOutlinePositions = getOutlinePositions;
            exports.getOutlineCoordinates = getOutlineCoordinates;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {
                        fill: true
                    };
                }
                //贴地时，剔除高度相关属性
                if (style.clampToGround) {
                    if (style.hasOwnProperty('height')) delete style.height;
                    if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];

                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "color":
                        case "animation":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                            break;
                        case "rotation":
                            //旋转角度
                            entityattr.rotation = Cesium.Math.toRadians(value);
                            if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
                            break;
                        case "stRotation":
                            entityattr.stRotation = Cesium.Math.toRadians(value);
                            break;
                        case "height":
                            entityattr.height = Number(value);
                            if (style.extrudedHeight) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
                            break;
                        case "extrudedHeight":
                            entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
                            break;
                        case "radius":
                            //半径（圆）
                            entityattr.semiMinorAxis = Number(value);
                            entityattr.semiMajorAxis = Number(value);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            //获取entity对应的 边界 的坐标
            function getOutlinePositions(entity, noAdd, count) {
                var time = (0, _util.currentTime)();

                //获取圆（或椭圆）边线上的坐标点数组
                var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                    position: entity.position.getValue(time),
                    semiMajorAxis: entity.ellipse.semiMajorAxis.getValue(time), //长半轴
                    semiMinorAxis: entity.ellipse.semiMinorAxis.getValue(time), //短半轴
                    rotation: entity.ellipse.rotation.getValue(time),
                    count: Cesium.defaultValue(count, 90) //共返回360个点
                });

                if (!noAdd) outerPositions.push(outerPositions[0]);

                return outerPositions;
            }

            //获取entity对应的 边界 的坐标（geojson规范的格式）
            function getOutlineCoordinates(entity, noAdd, count) {
                var positions = getOutlinePositions(entity, noAdd, count);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            /***/
}),
/* 41 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawBillboard = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(24);

            var _Attr = __webpack_require__(30);

            var attr = _interopRequireWildcard(_Attr);

            var _Attr2 = __webpack_require__(16);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawBillboard = exports.DrawBillboard = _Draw.DrawPoint.extend({
                type: 'billboard',
                //对应的属性控制静态类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        show: false,
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        billboard: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    if (attribute.style && attribute.style.label) {
                        //同时加文字
                        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
                    }

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    this.updateAttrForDrawing();
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    this.updateImg(style, entity);
                    if (style && style.label) {
                        //同时加文字
                        (0, _Attr2.style2Entity)(style.label, entity.label);
                    }
                    return attr.style2Entity(style, entity.billboard);
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    this.updateImg(this.entity.attribute.style, this.entity);
                },
                //更新图标，子类用
                updateImg: function updateImg(style, entity) { }

            });

            /***/
}),
/* 42 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesBase = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PolygonTextureVS = __webpack_require__(134);

            var _PolygonTextureVS2 = _interopRequireDefault(_PolygonTextureVS);

            var _PolygonTextureFS = __webpack_require__(135);

            var _PolygonTextureFS2 = _interopRequireDefault(_PolygonTextureFS);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            // 模型分析（裁剪、压平、淹没） 基础类
            //原理：利用绘制的点数组，先计算其外包矩形，然后根据点创建一个polygonGeometry，然后利用此geometry创建指令，绘制出polygon纹理，
            //源码里会根据此纹理判断模型顶点是否在polygon纹理中，如果在就进行后续操作


            //多处压平思考：创建多个polygon纹理有点不大合理，一张FBO里多个polygon纹理，可能会导致压平闪烁（因为到着色器里，增大了顶点和polygon纹理的比对误差）
            //多处压平思路之一张FBO里多个polygon纹理：就是想办法在我创建的FBO帧缓存里绘制多少polygon纹理，创建polygon数组，每次绘制都是往这里添加polygon，
            //遍历polygon，依次创建指令绘制到fbo里
            var TilesBase = exports.TilesBase = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function TilesBase(options) {
                    _classCallCheck(this, TilesBase);

                    options = options || {};
                    this.viewer = options.viewer;
                    this.tileset = options.tileset;
                    this.tileset.mapvEditor = this.tileset.mapvEditor || {};
                    this.tileset.mapvEditor.enable = true;
                    this.positions = options.positions;
                    this._b3dmOffset = options.b3dmOffset || new Cesium.Cartesian2();
                    if (this.tileset && this.tileset._config.editOffset) {
                        this.b3dmOffset = new Cesium.Cartesian2(this.tileset._config.editOffset.x, this.tileset._config.editOffset.y);
                    }
                    if (this.positions) {
                        this._preparePos(this.positions);
                    }
                    if (this.localPosArr && !(options.floodAll === true)) {
                        this._prepareWorks();
                    }
                }

                //========== 对外属性 ==========  
                //编辑对象


                _createClass(TilesBase, [{
                    key: "setPositions",


                    //========== 方法 ========== 


                    value: function setPositions(posArr) {
                        if (!posArr || posArr.length == 0) return;
                        this.positions = posArr;
                        this._preparePos(this.positions);
                        if (this.localPosArr) {
                            this._prepareWorks();
                            this.activeEdit();
                        }
                    }

                    //输入模型上方向轴向，目前使用实验室的工具，好像会把模型转成Z向上的，所以该功能已遗弃，未被使用

                }, {
                    key: "setUpAxis",
                    value: function setUpAxis(val) {
                        if (val == "X") {
                            this.base_height = this.flatRect[0];
                            return;
                        }
                        if (val == "Y") {
                            this.base_height = this.flatRect[1];
                            return;
                        }
                        if (val == "Z") {
                            this.base_height = this.flatRect[2];
                            return;
                        }
                        this.base_height = this.flatRect[2];
                    }
                }, {
                    key: "_prepareWorks",
                    value: function _prepareWorks() {
                        //准备工作
                        this._createTexture();
                        this._createCommand();
                    }
                }, {
                    key: "_createTexture",
                    value: function _createTexture() {
                        //创建FBO以及清除指令
                        var context = this.viewer.scene.context;
                        var tt = new Cesium.Texture({
                            context: context,
                            width: 4096,
                            height: 4096,
                            pixelFormat: Cesium.PixelFormat.RGBA,
                            pixelDatatype: Cesium.PixelDatatype.FLOAT,
                            sampler: new Cesium.Sampler({
                                wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                                magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                            })
                        });

                        var depthStencilTexture = new Cesium.Texture({
                            context: context,
                            width: 4096,
                            height: 4096,
                            pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
                        });

                        this.fbo = new Cesium.Framebuffer({
                            context: context,
                            colorTextures: [tt],
                            depthStencilTexture: depthStencilTexture,
                            destroyAttachments: false
                        });

                        this._fboClearCommand = new Cesium.ClearCommand({
                            color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                            framebuffer: this.fbo
                        });
                    }
                }, {
                    key: "_createCamera",
                    value: function _createCamera() {
                        //创建相机
                        return {
                            viewMatrix: Cesium.Matrix4.IDENTITY,
                            inverseViewMatrix: Cesium.Matrix4.IDENTITY,
                            frustum: new Cesium.OrthographicOffCenterFrustum(),
                            positionCartographic: new Cesium.Cartographic(),
                            positionWC: new Cesium.Cartesian3(),
                            directionWC: Cesium.Cartesian3.UNIT_Z,
                            upWC: Cesium.Cartesian3.UNIT_Y,
                            rightWC: Cesium.Cartesian3.UNIT_X,
                            viewProjectionMatrix: Cesium.Matrix4.IDENTITY
                        };
                    }
                }, {
                    key: "_createPolygonGeometry",
                    value: function _createPolygonGeometry() {
                        //创建geometry
                        var flattenPolygon = new Cesium.PolygonGeometry({
                            polygonHierarchy: new Cesium.PolygonHierarchy(this.localPosArr),
                            perPositionHeight: true
                        });
                        return Cesium.PolygonGeometry.createGeometry(flattenPolygon);
                    }
                }, {
                    key: "_createCommand",
                    value: function _createCommand() {
                        //创建指令
                        var context = this.viewer.scene.context;
                        var ppp = this._createPolygonGeometry();
                        var _camera = this._createCamera();
                        var sp = Cesium.ShaderProgram.fromCache({
                            context: context,
                            vertexShaderSource: _PolygonTextureVS2.default,
                            fragmentShaderSource: _PolygonTextureFS2.default,
                            attributeLocations: {
                                position: 0
                            }
                        });
                        var vao = Cesium.VertexArray.fromGeometry({
                            context: context,
                            geometry: ppp,
                            attributeLocations: sp._attributeLocations,
                            bufferUsage: Cesium.BufferUsage.STATIC_DRAW,
                            interleave: true
                        });

                        var rs = new Cesium.RenderState();
                        rs.depthTest.enabled = false;
                        rs.depthRange.near = -1000000.0;
                        rs.depthRange.far = 1000000.0;

                        var bg = Cesium.BoundingRectangle.fromPoints(this.localPosArr, new Cesium.BoundingRectangle());
                        _camera.frustum.left = bg.x;
                        _camera.frustum.top = bg.y + bg.height;
                        _camera.frustum.right = bg.x + bg.width;
                        _camera.frustum.bottom = bg.y;

                        this._camera = _camera;

                        var _myPorjection = Cesium.Matrix4.computeOrthographicOffCenter(_camera.frustum.left, _camera.frustum.right, _camera.frustum.bottom, _camera.frustum.top, _camera.frustum.near, _camera.frustum.far, new Cesium.Matrix4());

                        this.polygonBounds = new Cesium.Cartesian4(_camera.frustum.left, _camera.frustum.bottom, _camera.frustum.right, _camera.frustum.top);

                        this.drawCommand = new Cesium.DrawCommand({
                            boundingVolume: ppp.boundingVolume,
                            primitiveType: Cesium.PrimitiveType.TRIANGLES,
                            vertexArray: vao,
                            shaderProgram: sp,
                            renderState: rs,
                            pass: Cesium.Pass.CESIUM_3D_TILE,
                            uniformMap: {
                                myPorjection: function myPorjection() {
                                    return _myPorjection;
                                }
                            }
                        });
                    }

                    //重置编辑对象

                }, {
                    key: "clear",
                    value: function clear() {
                        if (this._tileset && this.tileset.mapvEditor) {
                            this.tileset.mapvEditor.IsYaPing = [false, false, false, false]; //[是否开启编辑，是否开启压平，是否开启裁剪，是否开启淹没]
                            this.tileset.mapvEditor.editVar = [false, false, false, false]; //[是否开启裁剪外部，是否开启淹没全局，]

                            this.tileset.mapvEditor.b3dmOffset = undefined;
                            this.tileset.mapvEditor.floodColor = [0.0, 0.0, 0.0, 0.5]; //[淹没颜色的r(0-1之间)，淹没颜色的g，淹没颜色的b，淹没混合系数（建议取值范围0.3-0.7）]
                            this.tileset.mapvEditor.floodVar = [0, 0, 0, 0]; //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
                            this.tileset.mapvEditor.heightVar = [0, 0]; //基础压平高度，调整压平高度值
                            this.tileset.mapvEditor.enable = false;
                        }
                    }
                }, {
                    key: "deActiveEdit",
                    value: function deActiveEdit() {
                        //激活
                        this.tileset.mapvEditor.IsYaPing[0] = false;
                    }
                }, {
                    key: "update",
                    value: function update(frameState) {
                        //更新
                        if (this.drawed) return; //如果已经绘制过纹理，则退出，无需再绘制
                        this.drawed = true;
                        var context = frameState.context;
                        var width = 4096;
                        var height = 4096;
                        if (!this._passState) {
                            this._passState = new Cesium.PassState(context);
                        }
                        this._passState.framebuffer = this.fbo;
                        this._passState.viewport = new Cesium.BoundingRectangle(0, 0, width, height);
                        var us = context.uniformState;
                        us.updateCamera(this._camera);
                        us.updatePass(this.drawCommand.pass);
                        this.drawCommand.framebuffer = this.fbo;
                        this.drawCommand.execute(context, this._passState);
                    }

                    //预处理顶点

                }, {
                    key: "_preparePos",
                    value: function _preparePos(positions) {
                        if (!positions || positions.length == 0) return;
                        var localPos = [];
                        var minHeight = 99999;
                        var minLocalPos;
                        for (var i = 0; i < positions.length; i++) {
                            var cart = Cesium.Cartographic.fromCartesian(positions[i]);
                            var height = cart.height;
                            var currLocalPos = Cesium.Matrix4.multiplyByPoint(this.tileInverTransform, positions[i], new Cesium.Cartesian3());
                            if (this.tileset._config.offset && this.tileset._config.offset.z) {
                                currLocalPos.z -= this.tileset._config.offset.z;
                            }
                            if (this.tileset._config.editOffset && this.tileset._config.editOffset.z) {
                                currLocalPos.z += this.tileset._config.editOffset.z;
                            }
                            localPos.push(currLocalPos);
                            if (height < minHeight) {
                                minHeight = height;
                                minLocalPos = currLocalPos;
                            }
                        }
                        this.minHeight = minHeight;
                        this.minLocalPos = minLocalPos;
                        this.localPosArr = localPos;
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.clear();

                        delete this._tileset;
                        delete this.tileInverTransform;
                        delete this.drawCommand;
                        delete this._passState;
                        delete this.polygonBounds;
                        delete this._fboClearCommand;
                        delete this.fbo;
                        delete this.localPosArr;
                        delete this.minHeight;
                        delete this.minLocalPos;
                        delete this.positions;
                        delete this._b3dmOffset;
                        delete this._camera;
                        delete this._external;
                        delete this._passState;
                        delete this.drawed;
                    }
                }, {
                    key: "tileset",
                    get: function get() {
                        return this._tileset;
                    },
                    set: function set(val) {
                        this._tileset = val;
                        var inverseMat = new Cesium.Matrix4();
                        Cesium.Matrix4.fromArray(val._root.transform, 0, inverseMat);
                        Cesium.Matrix4.inverse(inverseMat, inverseMat);
                        this.tileInverTransform = inverseMat;
                        if (this.tileset._config.editOffset) {
                            this._b3dmOffset = new Cesium.Cartesian2(this.tileset._config.editOffset.x, this.tileset._config.editOffset.y);
                        }
                    }

                    //偏移量

                }, {
                    key: "b3dmOffset",
                    get: function get() {
                        return this._b3dmOffset;
                    },
                    set: function set(val) {
                        if (!val) return;
                        this._b3dmOffset.x = val.x || 0;
                        this._b3dmOffset.y = val.y || 0;

                        this.tileset.mapvEditor.b3dmOffset = this.b3dmOffset;
                    }
                }]);

                return TilesBase;
            }();

            /***/
}),
/* 43 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            //当前版本  2020年1月1日 - 至今
            exports.version = "5.5.0";
            //发布时间
            exports.update = "2020-5-23 14:18:18";

            /***/
}),
/* 44 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.init = init;
            exports.getDefWindowOptions = getDefWindowOptions;
            exports.activate = activate;
            exports.getWidget = getWidget;
            exports.getClass = getClass;
            exports.isActivate = isActivate;
            exports.disable = disable;
            exports.disableAll = disableAll;
            exports.disableGroup = disableGroup;
            exports.eachWidget = eachWidget;
            exports.bindClass = bindClass;
            exports.removeDebugeBar = removeDebugeBar;
            exports.getCacheVersion = getCacheVersion;
            exports.getBasePath = getBasePath;

            var _zepto = __webpack_require__(6);

            var _loader = __webpack_require__(45);

            var _util = __webpack_require__(1);

            //widget模块公共处理类，勿轻易修改


            var basePath = ""; //widgets目录统一前缀，如果widgets目录不在当前页面的同级目录，在其他处时可以传入basePath参数，参数值为：widgets目录相对于当前页面的路径
            var defoptions;
            var cacheVersion;
            var isdebuger;

            var thismap;
            var widgetsdata = [];

            var removeKeys = ["_class"];

            //初始化插件
            function init(map, widgetcfg, _basePath) {
                thismap = map;
                widgetcfg = widgetcfg || {};
                basePath = _basePath || "";

                widgetsdata = [];
                defoptions = widgetcfg.defaultOptions || { "windowOptions": { "position": "rt", "maxmin": false, "resize": true }, "autoDisable": true, "disableOther": true };

                cacheVersion = widgetcfg.version;
                if (cacheVersion == "time") cacheVersion = new Date().getTime();

                //将自启动的加入
                var arrtemp = widgetcfg.widgetsAtStart;
                if (arrtemp && arrtemp.length > 0) {
                    for (var i = 0; i < arrtemp.length; i++) {
                        var item = arrtemp[i];
                        if (!item.hasOwnProperty("uri") || item.uri == "") {
                            console.log('widget未配置uri：' + JSON.stringify(item));
                            continue;
                        }
                        if (item.hasOwnProperty("visible") && !item.visible) continue;

                        item.autoDisable = false;
                        item.openAtStart = true;
                        item._nodebug = true;

                        bindDefOptions(item);

                        item._firstConfigBak = (0, _util.clone)(item, removeKeys);
                        widgetsdata.push(item);
                    }
                }

                //显示测试栏
                //为了方便测试，所有widget会在页面下侧生成一排按钮，每个按钮对应一个widget，单击后激活对应widget
                isdebuger = widgetcfg["debugger"];
                if (isdebuger) {
                    var inhtml = '<div id="widget-testbar" class="mapv3d-widgetbar animation-slide-bottom no-print-view" > ' + '     <div style="height: 30px; line-height:30px;"><b style="color: #4db3ff;">widget测试栏</b>&nbsp;&nbsp;<button  id="widget-testbar-remove"  type="button" class="btn btn-link btn-xs">关闭</button> </div>' + '     <button id="widget-testbar-disableAll" type="button" class="btn btn-info" ><i class="fa fa-globe"></i>漫游</button>' + '</div>';
                    (0, _zepto.zepto)("body").append(inhtml);

                    (0, _zepto.zepto)("#widget-testbar-remove").click(function (e) {
                        removeDebugeBar();
                    });
                    (0, _zepto.zepto)("#widget-testbar-disableAll").click(function (e) {
                        disableAll();
                    });
                }

                //将配置的加入
                arrtemp = widgetcfg.widgets;
                if (arrtemp && arrtemp.length > 0) {
                    for (var i = 0; i < arrtemp.length; i++) {
                        var item = arrtemp[i];
                        if (item.type == "group") {
                            var inhtml = ' <div class="btn-group dropup">  <button type="button" class="btn btn-primary dropdown-toggle" data-toggle="dropdown" aria-expanded="false"><i class="fa fa-align-justify"></i>' + item.name + ' <span class="caret"></span></button> <ul class="dropdown-menu">';
                            for (var j = 0; j < item.children.length; j++) {
                                var childItem = item.children[j];
                                if (!childItem.hasOwnProperty("uri") || childItem.uri == "") {
                                    console.log('widget未配置uri：' + JSON.stringify(childItem));
                                    continue;
                                }

                                inhtml += ' <li data-widget="' + childItem.uri + '" class="widget-btn" ><a href="#"><i class="fa fa-star"></i>' + childItem.name + '</a></li>';

                                bindDefOptions(childItem);
                                childItem._firstConfigBak = (0, _util.clone)(childItem, removeKeys);
                                widgetsdata.push(childItem); //将配置的加入
                            }
                            inhtml += "</ul></div>";

                            if (isdebuger && !item._nodebug) {
                                (0, _zepto.zepto)("#widget-testbar").append(inhtml);
                            }
                        } else {
                            if (!item.hasOwnProperty("uri") || item.uri == "") {
                                console.log('widget未配置uri：' + JSON.stringify(item));
                                continue;
                            }

                            //显示测试栏 
                            if (isdebuger && !item._nodebug) {
                                var inhtml = '<button type="button" class="btn btn-primary widget-btn" data-widget="' + item.uri + '"  > <i class="fa fa-globe"></i>' + item.name + ' </button>';
                                (0, _zepto.zepto)("#widget-testbar").append(inhtml);
                            }

                            bindDefOptions(item);
                            item._firstConfigBak = (0, _util.clone)(item, removeKeys);
                            widgetsdata.push(item); //将配置的加入
                        }
                    }

                    if (isdebuger) {
                        (0, _zepto.zepto)("#widget-testbar .widget-btn").each(function () {
                            (0, _zepto.zepto)(this).click(function (e) {
                                var uri = (0, _zepto.zepto)(this).attr('data-widget');
                                if (uri == null || uri == "") return;

                                if (isActivate(uri)) {
                                    disable(uri);
                                } else {
                                    activate(uri);
                                }
                            });
                        });
                    }
                }

                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];

                    if (item.openAtStart || item.createAtStart) {
                        _arrLoadWidget.push(item);
                    }
                }

                (0, _zepto.zepto)(window).resize(function () {
                    for (var i = 0; i < widgetsdata.length; i++) {
                        var item = widgetsdata[i];
                        if (item._class) {
                            item._class.indexResize(); //BaseWidget: indexResize
                        }
                    }
                });

                if (isdebuger) {
                    var hash = getLocationParam();
                    if (hash) {
                        activate(hash);
                    }
                }

                loadWidgetJs();
            }

            function getDefWindowOptions() {
                return (0, _util.clone)(defoptions.windowOptions, removeKeys);
            }

            function getLocationParam() {
                var param = window.location.toString();
                if (param.indexOf("#") === -1) {
                    return "";
                }
                param = param.split("#");
                if (param && param.length > 0) {
                    return param[1];
                }
            }

            function bindDefOptions(item) {
                //赋默认值至options（跳过已存在设置值） 
                if (defoptions) {
                    for (var aa in defoptions) {
                        if (aa == "windowOptions") {
                            //for (var jj in defoptions['windowOptions']) {
                            //    if (!item['windowOptions'].hasOwnProperty(jj)) {
                            //        item['windowOptions'][jj] = defoptions['windowOptions'][jj];
                            //    }
                            //}
                        } else if (!item.hasOwnProperty(aa)) {
                            item[aa] = defoptions[aa];
                        }
                    }
                }

                //赋值内部使用属性 
                item.path = getFilePath(basePath + item.uri);
                item.name = item.name || item.label; //兼容name和label命名
            }

            //激活指定模块
            function activate(item, noDisableOther) {

                if (thismap == null && item.viewer) {
                    init(item.viewer);
                }

                //参数是字符串id或uri时
                if (typeof item === 'string') {
                    item = { uri: item };

                    if (noDisableOther != null) item.disableOther = !noDisableOther; //是否释放其他已激活的插件 
                } else {
                    if (item.uri == null) {
                        console.error('activate激活widget时需要uri参数！');
                    }
                }

                var thisItem;
                for (var i = 0; i < widgetsdata.length; i++) {
                    var othitem = widgetsdata[i];
                    if (item.uri == othitem.uri || othitem.id && item.uri == othitem.id) {
                        thisItem = othitem;
                        if (thisItem.isloading) return thisItem; //激活了正在loading的widget 防止快速双击了菜单

                        //赋值  
                        for (var aa in item) {
                            if (aa == "uri") continue;
                            thisItem[aa] = item[aa];
                        }
                        break;
                    }
                }

                if (thisItem == null) {
                    bindDefOptions(item);
                    thisItem = item;
                    //非config中配置的，外部传入，首次激活 
                    if (!item._firstConfigBak) item._firstConfigBak = (0, _util.clone)(item, removeKeys);
                    widgetsdata.push(item);
                }

                if (isdebuger) {
                    console.log('开始激活widget：' + thisItem.uri);
                    window.location.hash = "#" + thisItem.uri;
                }

                //兼容之前历史版本的错误命名时的属性名称
                if (thisItem.hasOwnProperty("disableOhter") && !thisItem.hasOwnProperty("disableOther")) thisItem.disableOther = thisItem.disableOhter;

                //释放其他已激活的插件 
                if (thisItem.disableOther) {
                    disableAll(thisItem.uri, thisItem.group);
                } else {
                    disableGroup(thisItem.group, thisItem.uri);
                }

                //激活本插件
                if (thisItem._class) {
                    if (thisItem._class.isActivate) {
                        //已激活时
                        if (thisItem._class.update) {
                            //刷新
                            thisItem._class.update();
                        } else {
                            //重启
                            thisItem._class.disableBase();
                            var timetemp = setInterval(function () {
                                if (thisItem._class.isActivate) return;
                                thisItem._class.activateBase();
                                clearInterval(timetemp);
                            }, 200);
                        }
                    } else {
                        thisItem._class.activateBase(); // BaseWidget: activateBase
                    }
                } else {
                    for (var i = 0; i < _arrLoadWidget.length; i++) {
                        if (_arrLoadWidget[i].uri == thisItem.uri) //如果已在加载列表中的直接跳出
                            return _arrLoadWidget[i];
                    }
                    _arrLoadWidget.push(thisItem);

                    if (_arrLoadWidget.length == 1) {
                        loadWidgetJs();
                    }
                }
                return thisItem;
            }

            function getWidget(id) {
                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];

                    if (id == item.uri || id == item.id) {
                        return item;
                    }
                }
            }

            function getClass(id) {
                var item = getWidget(id);
                if (item) return item._class; else return null;
            }

            function isActivate(id) {
                var _class = getClass(id);
                if (_class == null) return false;
                return _class.isActivate;
            }

            function disable(id) {
                if (id == null) return;
                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];

                    if (item._class && (id == item.uri || id == item.id)) {
                        item._class.disableBase();
                        break;
                    }
                }
            }

            //释放所有widget
            function disableAll(nodisable, group) {
                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];

                    if (group && item.group == group) {
                        //同组别的全部释放
                    } else {
                        if (nodisable !== true && !item.autoDisable) continue;
                    }

                    //指定不释放的跳过
                    if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;

                    if (item._class) {
                        item._class.disableBase(); ////BaseWidget: disableBase
                    }
                }
            }

            //释放同组widget
            function disableGroup(group, nodisable) {
                if (group == null) return;

                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];
                    if (item.group == group) {
                        //指定不释放的跳过
                        if (nodisable && (nodisable == item.uri || nodisable == item.id)) continue;
                        if (item._class) {
                            item._class.disableBase(); ////BaseWidget: disableBase
                        }
                    }
                }
            }

            function eachWidget(calback) {
                for (var i = 0; i < widgetsdata.length; i++) {
                    var item = widgetsdata[i];
                    calback(item);
                }
            }

            var _arrLoadWidget = [];
            var loadItem;
            var isloading;
            function loadWidgetJs() {
                if (_arrLoadWidget.length == 0) return;

                if (isloading) {
                    setTimeout(loadWidgetJs, 500);
                    return;
                }
                isloading = true;

                loadItem = _arrLoadWidget[0];
                loadItem.isloading = true;
                var _uri = loadItem.uri;
                if (cacheVersion) {
                    if (_uri.indexOf('?') == -1) _uri += "?time=" + cacheVersion; else _uri += "&time=" + cacheVersion;
                }

                if (window.NProgress) {
                    NProgress.start();
                }

                if (isdebuger) console.log('开始加载js：' + basePath + _uri);

                _loader.Loader.async([basePath + _uri], function () {
                    isloading = false;
                    loadItem.isloading = false;
                    if (isdebuger) console.log('完成js加载：' + basePath + _uri);

                    if (window.NProgress) {
                        NProgress.done(true);
                    }

                    _arrLoadWidget.shift();
                    loadWidgetJs();
                });
            }

            function bindClass(_class) {
                if (loadItem == null) {
                    var _jspath = getThisJSPath();
                    for (var i = 0; i < widgetsdata.length; i++) {
                        var item = widgetsdata[i];
                        if (_jspath.endsWith(item.uri)) {
                            item.isloading = false;
                            item._class = new _class(item, thismap);
                            item._class.activateBase(); // BaseWidget: activateBase
                            return item._class;
                        }
                    }
                } else {
                    loadItem.isloading = false;
                    loadItem._class = new _class(loadItem, thismap);
                    loadItem._class.activateBase(); // BaseWidget: activateBase
                    return loadItem._class;
                }
            }

            function getThisJSPath() {
                var jsPath;
                var js = document.scripts;
                for (var i = js.length - 1; i >= 0; i--) {
                    jsPath = js[i].src;
                    if (jsPath == null || jsPath == "") continue;
                    if (jsPath.indexOf("widgets") == -1) continue;
                    //jsPath = jsPath.substring(0, jsPath.lastIndexOf("/") + 1);
                    return jsPath;
                }
                return "";
            }

            //获取路径
            function getFilePath(file) {
                var pos = file.lastIndexOf("/");
                return file.substring(0, pos + 1);
            }

            function removeDebugeBar() {
                (0, _zepto.zepto)("#widget-testbar").remove();
            }

            function getCacheVersion() {
                return cacheVersion;
            }

            function getBasePath() {
                return basePath;
            }

            /***/
}),
/* 45 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });

            // cssExpr 用于判断资源是否是css
            var cssExpr = new RegExp('\\.css');
            var nHead = document.head || document.getElementsByTagName('head')[0];
            // `onload` 在WebKit < 535.23， Firefox < 9.0 不被支持
            var isOldWebKit = +navigator.userAgent.replace(/.*(?:AppleWebKit|AndroidWebKit)\/?(\d+).*/i, '$1') < 536;

            // 判断对应的node节点是否已经载入完成
            function isReady(node) {
                return node.readyState === 'complete' || node.readyState === 'loaded';
            }

            // loadCss 用于载入css资源
            function loadCss(url, setting, callback) {
                var node = document.createElement('link');

                node.rel = 'stylesheet';
                addOnload(node, callback, 'css');
                node.async = true;
                node.href = url;

                nHead.appendChild(node);
            }

            // loadJs 用于载入js资源
            function loadJs(url, setting, callback) {
                var node = document.createElement('script');

                node.charset = 'utf-8';
                addOnload(node, callback, 'js');
                node.async = !setting.sync;
                node.src = url;

                nHead.appendChild(node);
            }

            // 在老的webkit中，因不支持load事件，这里用轮询sheet来保证
            function pollCss(node, callback) {
                var isLoaded;

                if (node.sheet) {
                    isLoaded = true;
                }

                setTimeout(function () {
                    if (isLoaded) {
                        // 在这里callback 是为了让样式有足够的时间渲染
                        callback();
                    } else {
                        pollCss(node, callback);
                    }
                }, 20);
            }

            // 用于给指定的节点绑定onload回调
            // 监听元素载入完成事件
            function addOnload(node, callback, type) {
                var supportOnload = 'onload' in node;
                var isCSS = type === 'css';

                // 对老的webkit和老的firefox的兼容
                if (isCSS && (isOldWebKit || !supportOnload)) {
                    setTimeout(function () {
                        pollCss(node, callback);
                    }, 1);
                    return;
                }

                if (supportOnload) {
                    node.onload = onload;
                    node.onerror = function () {
                        node.onerror = null;
                        //window._cdnFallback(node);
                        if (type == "css") console.error("该css文件不存在：" + node.href); else console.error("该js文件不存在：" + node.src);
                        onload();
                    };
                } else {
                    node.onreadystatechange = function () {
                        if (isReady(node)) {
                            onload();
                        }
                    };
                }

                function onload() {

                    // 执行一次后清除，防止重复执行
                    node.onload = node.onreadystatechange = null;

                    node = null;

                    callback();
                }
            }

            // 资源下载入口，根绝文件类型的不同，调用loadCss或者loadJs
            function loadItem(url, list, setting, callback) {
                // 如果加载的url为空，就直接成功返回
                if (!url) {
                    setTimeout(function () {
                        onFinishLoading();
                    });
                    return;
                }

                if (cssExpr.test(url)) {
                    loadCss(url, setting, onFinishLoading);
                } else {
                    loadJs(url, setting, onFinishLoading);
                }

                // 每次资源下载完成后，检验是否结束整个list下载过程
                // 若已经完成所有下载，执行回调函数
                function onFinishLoading() {
                    var urlIndex = list.indexOf(url);
                    if (urlIndex > -1) {
                        list.splice(urlIndex, 1);
                    }

                    if (list.length === 0) {
                        callback();
                    }
                }
            }

            function doInit(list, setting, callback) {
                var cb = function cb() {
                    callback && callback();
                };

                list = Array.prototype.slice.call(list || []);

                if (list.length === 0) {
                    cb();
                    return;
                }

                for (var i = 0, len = list.length; i < len; i++) {
                    loadItem(list[i], list, setting, cb);
                }
            }

            // 判断当前页面是否加载完
            // 加载完，立刻执行下载
            // 未加载完，等待页面load事件以后再进行下载
            function ready(node, callback) {
                if (isReady(node)) {
                    callback();
                } else {
                    // 1500ms 以后，直接开始下载资源文件，不再等待load事件
                    var timeLeft = 1500;
                    var isExecute = false;
                    window.addEventListener('load', function () {
                        if (!isExecute) {
                            callback();
                            isExecute = true;
                        }
                    });

                    setTimeout(function () {
                        if (!isExecute) {
                            callback();
                            isExecute = true;
                        }
                    }, timeLeft);
                }
            }

            // 暴露出去的Loader
            // 提供async, sync两个函数
            // async 用作异步下载执行用，不阻塞页面渲染
            // sync  用作异步下载，顺序执行，保证下载的js按照数组顺序执行
            var Loader = {
                async: function async(list, callback) {

                    ready(document, function () {
                        doInit(list, {}, callback);
                    });
                },

                sync: function sync(list, callback) {

                    ready(document, function () {
                        doInit(list, {
                            sync: true
                        }, callback);
                    });
                }
            };

            //window.Loader = Loader;

            exports.Loader = Loader;

            /***/
}),
/* 46 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ViewerEx = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _Draw = __webpack_require__(4);

            var _BaseLayer = __webpack_require__(13);

            var _KeyboardRoam = __webpack_require__(69);

            var _Popup = __webpack_require__(110);

            var _Tooltip = __webpack_require__(111);

            var _ContextMenu = __webpack_require__(112);

            var _Location = __webpack_require__(113);

            var _MouseZoomStyle = __webpack_require__(114);

            var _util2 = __webpack_require__(1);

            var _util = _interopRequireWildcard(_util2);

            var _point = __webpack_require__(2);

            var point = _interopRequireWildcard(_point);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _layer2 = __webpack_require__(20);

            var _layer = _interopRequireWildcard(_layer2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //一些默认值的修改【by LYW】 
            Cesium.Camera.DEFAULT_VIEW_RECTANGLE = Cesium.Rectangle.fromDegrees(89.5, 20.4, 110.4, 61.2); //更改默认视域
            Cesium.BingMapsApi.defaultKey = 'AtkX3zhnRe5fyGuLU30uZw8r3sxdBDnpQly7KfFTCB2rGlDgXBG3yr-qEiQEicEc';
            Cesium.MapboxApi.defaultAccessToken = 'pk.eyJ1IjoibXV5YW8xOTg3IiwiYSI6ImNpcm9ueHd6cjAwNzZoa20xazY1aWlubjIifQ.5tLtC5j1rh8Eqjlyrq3OaA';

            //Viewer扩展

            var ViewerEx = exports.ViewerEx = function () {
                //========== 构造方法 ========== 
                function ViewerEx(viewer, config) {
                    _classCallCheck(this, ViewerEx);

                    this.viewer = viewer;
                    this.config = Cesium.defaultValue(config, {});

                    this.viewer.mapv = this; //要记录下，内部用

                    this._isFlyAnimation = false;
                    this.crs = Cesium.defaultValue(this.config.crs, '3857'); //坐标系 


                    //优化viewer默认参数相关的
                    this._optimization();
                    //根据参数进行设置相关的
                    this._initForOpts();
                    //绑定添加相关控件
                    this._addControls();
                    //处理图层
                    this._initLayers();
                }
                //========== 对外属性 ==========   

                //键盘漫游


                _createClass(ViewerEx, [{
                    key: '_optimization',


                    //========== 方法 ========== 

                    //优化viewer默认参数相关的
                    value: function _optimization() {
                        var that = this;
                        var viewer = this.viewer;

                        //二三维切换不用动画
                        if (this.viewer.sceneModePicker) this.viewer.sceneModePicker.viewModel.duration = 0.0;

                        //解决Cesium显示画面模糊的问题 https://zhuanlan.zhihu.com/p/41794242 【1.63已修复，1.66又出现了】
                        this.viewer._cesiumWidget._supportsImageRenderingPixelated = Cesium.FeatureDetection.supportsImageRenderingPixelated();
                        this.viewer._cesiumWidget._forceResize = true;
                        if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {
                            var _dpr = window.devicePixelRatio;
                            // 适度降低分辨率
                            while (_dpr >= 2.0) {
                                _dpr /= 2.0;
                            }
                            this.viewer.resolutionScale = _dpr;
                        }
                    }
                    //根据参数进行设置相关的

                }, {
                    key: '_initForOpts',
                    value: function _initForOpts() {
                        var that = this;
                        this.viewer.cesiumWidget.creditContainer.style.display = "none"; //去cesium logo

                        //默认定位地点相关设置，默认home键和初始化镜头视角  
                        if (this.viewer.homeButton) {
                            this.viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (commandInfo) {
                                that.centerAt();
                                commandInfo.cancel = true;
                            });
                        }
                        this.centerAt(null, { duration: 0 });

                        //地球一些属性设置
                        var scene = this.viewer.scene;
                        scene.globe.baseColor = new Cesium.Color.fromCssColorString(this.config.baseColor || "#546a53"); //地表背景色

                        if (this.config.backgroundColor) scene.backgroundColor = new Cesium.Color.fromCssColorString(this.config.backgroundColor); //空间背景色


                        if (this.config.style) {
                            //深度监测
                            scene.globe.depthTestAgainstTerrain = this.config.style.testTerrain;

                            //光照渲染（阳光照射区域高亮）
                            scene.globe.enableLighting = this.config.style.lighting;

                            //大气渲染
                            scene.skyAtmosphere.show = this.config.style.atmosphere;
                            scene.globe.showGroundAtmosphere = this.config.style.atmosphere;

                            //雾化效果
                            scene.fog.enabled = this.config.style.fog;

                            //设置无地球模式 （单模型是可以设置为false）
                            scene.globe.show = Cesium.defaultValue(this.config.style.globe, true);
                            scene.moon.show = Cesium.defaultValue(this.config.style.moon, scene.globe.show);
                            scene.sun.show = Cesium.defaultValue(this.config.style.sun, scene.globe.show);
                            scene.skyBox.show = Cesium.defaultValue(this.config.style.skyBox, scene.globe.show);
                        }

                        //限制缩放级别
                        scene.screenSpaceCameraController.maximumZoomDistance = Cesium.defaultValue(this.config.maxzoom, 20000000); //变焦时相机位置的最大值（以米为单位） 
                        scene.screenSpaceCameraController.minimumZoomDistance = Cesium.defaultValue(this.config.minzoom, 1); //变焦时相机位置的最小量级（以米为单位）。默认为1.0。


                        scene.screenSpaceCameraController._zoomFactor = 2; //鼠标滚轮放大的步长参数 
                        scene.screenSpaceCameraController.minimumCollisionTerrainHeight = 15000000; //低于此高度时绕鼠标键绕圈，大于时绕视图中心点绕圈。
                    }
                    //绑定添加相关控件

                }, {
                    key: '_addControls',
                    value: function _addControls() {
                        var that = this;

                        //绑定popup 
                        this._popup = new _Popup.Popup(this.viewer, {
                            popupEventType: this.config.popupEventType
                            // onLeftClick: function (event) {
                            // }
                        });

                        //绑定tooltip 
                        this._tooltip = new _Tooltip.Tooltip(this.viewer, {
                            onMouseMove: function onMouseMove(event) {
                                if (that._location) {
                                    that._location.updateData(event);
                                }
                            }
                        });

                        //绑定键盘漫游 
                        this._keyboardRoam = new _KeyboardRoam.KeyboardRoam(this.viewer);

                        //绑定右键菜单 
                        if (this.config.contextmenu) {
                            this._contextmenu = new _ContextMenu.ContextMenu(this.viewer);

                            this.contextmenuItems = this.defaultContextmenuItems;
                            this._contextmenu.resetDefault = function () {
                                //右键菜单还原为默认的
                                that.contextmenuItems = that.defaultContextmenuItems;
                            };
                        }

                        //导航工具栏控件
                        if (this.config.navigation) {
                            this._addNavigationWidget(this.config.navigation);
                        }

                        //鼠标提示控件
                        if (this.config.location) {
                            this.config.location.bindEvent = false;
                            this._location = new _Location.Location(this.viewer, this.config.location);
                        }

                        //鼠标滚轮缩放美化样式
                        if (this.config.mouseZoom && _util.isPCBroswer()) {
                            this._mouseZoomStyle = new _MouseZoomStyle.MouseZoomStyle(this.viewer, this.config.mouseZoom);
                        }
                    }
                    //没有id的图层，进行id赋值处理

                }, {
                    key: 'getNextId',
                    value: function getNextId() {
                        while (this.arrIdx.indexOf(this._tempIdx) != -1) {
                            this._tempIdx++;
                        }
                        this.arrIdx.push(this._tempIdx);
                        return this._tempIdx;
                    }
                    //添加内部封装的BaseLayer图层到OperationalLayer进行图层控制

                }, {
                    key: 'addOperationalLayer',
                    value: function addOperationalLayer(item) {
                        var layer;
                        if (item instanceof _BaseLayer.BaseLayer) {
                            layer = item;
                            item = layer.config;
                        } else {
                            var _visible = item.visible;
                            delete item.visible;

                            layer = new _BaseLayer.BaseLayer(item, viewer);
                            layer._visible = _visible;

                            if (!item.type) //外部通过bindToLayerControl添加的
                                item.type = "base";
                        }

                        if (!item.name) item.name = "未命名";
                        if (!item.id) item.id = this.getNextId();
                        if (!item.pid) item.pid = -1;

                        item.hasLayer = true;

                        this.config.operationallayers.push(item);
                        this.arrOperationallayers.push(layer);
                        this.layers[item.id] = layer;

                        return layer;
                    }
                }, {
                    key: 'removeOperationalLayer',
                    value: function removeOperationalLayer(id) {
                        for (var i = 0; i < this.config.operationallayers.length; i++) {
                            var item = this.config.operationallayers[i];
                            if (item.id == id) {
                                this.config.operationallayers.splice(i, 1);
                                break;
                            }
                        }
                        for (var i = 0; i < this.arrOperationallayers.length; i++) {
                            var item = this.arrOperationallayers[i];
                            if (item.config.id == id) {
                                this.arrOperationallayers.splice(i, 1);
                                break;
                            }
                        }

                        delete this.layers[id];
                    }
                    //处理图层

                }, {
                    key: '_initLayers',
                    value: function _initLayers() {
                        this.config.basemaps = this.config.basemaps || [];
                        this.config.operationallayers = this.config.operationallayers || [];

                        var basemapsCfg = this.config.basemaps;
                        var operationallayersCfg = this.config.operationallayers;

                        var layersCfg = []; //计算order

                        //记录所有id，方便计算nextid
                        this._tempIdx = 1;
                        this.arrIdx = [];
                        for (var i = 0; i < basemapsCfg.length; i++) {
                            var item = basemapsCfg[i];

                            if (item.id) this.arrIdx.push(item.id);
                        }
                        for (var i = 0; i < operationallayersCfg.length; i++) {
                            var item = operationallayersCfg[i];
                            if (item.id) this.arrIdx.push(item.id);
                        }

                        var objLayers = {}; //图层对象
                        var arrBasemaps = []; //底图数组
                        var arrOperationallayers = []; //可叠加图层  

                        //底图处理
                        if (!this.config.baseLayerPicker) {
                            //不能取消，如果取消，使用baseLayerPicker时无法切换了
                            if (basemapsCfg && basemapsCfg.length > 0) {
                                for (var i = 0; i < basemapsCfg.length; i++) {
                                    var item = basemapsCfg[i];
                                    if (!item.name) item.name = "未命名";
                                    if (!item.id) item.id = this.getNextId();
                                    if (!item.pid) item.pid = -1;

                                    if (item.visible && item.crs) this.crs = item.crs;

                                    var layer = _layer.createLayer(item, this.viewer, this.config.serverURL);
                                    if (layer) {
                                        item.hasLayer = true;
                                        objLayers[item.id] = layer;
                                        arrBasemaps.push(layer);
                                    }

                                    layersCfg.push(item);
                                    if (item.type == "group" && item.layers) {
                                        for (var idx = 0; idx < item.layers.length; idx++) {
                                            var childitem = item.layers[idx];
                                            childitem.pid = item.id;
                                            childitem.id = this.getNextId();
                                            layersCfg.push(childitem);
                                        }
                                    }
                                }
                            }
                        }
                        this.arrBasemaps = arrBasemaps;

                        //可叠加图层  
                        if (operationallayersCfg && operationallayersCfg.length > 0) {
                            for (var i = 0; i < operationallayersCfg.length; i++) {
                                var item = operationallayersCfg[i];
                                if (!item.name) item.name = "未命名";
                                if (!item.id) item.id = this.getNextId();
                                if (!item.pid) item.pid = -1;

                                var layer = _layer.createLayer(item, this.viewer, this.config.serverURL);
                                if (layer) {
                                    item.hasLayer = true;
                                    arrOperationallayers.push(layer);
                                    objLayers[item.id] = layer;
                                }

                                layersCfg.push(item);
                                if (item.type == "group" && item.layers) {
                                    for (var idx = 0; idx < item.layers.length; idx++) {
                                        var childitem = item.layers[idx];
                                        childitem.pid = item.id;
                                        childitem.id = this.getNextId();
                                        layersCfg.push(childitem);
                                    }
                                }
                            }
                        }
                        this.arrOperationallayers = arrOperationallayers;
                        this.layers = objLayers;

                        //计算 顺序字段,
                        for (var i = 0; i < layersCfg.length; i++) {
                            var item = layersCfg[i];

                            //计算层次顺序
                            var order = Number(item.order);
                            if (isNaN(order)) order = i;
                            item.order = order;

                            //图层的处理
                            if (objLayers[item.id] != null) {
                                objLayers[item.id].setZIndex(order);
                            }
                        }
                    }
                }, {
                    key: 'getConfig',
                    value: function getConfig() {
                        return _util.clone(this.config, ["_layer", "_layers", "_parent"]);
                    }

                    //point的方法兼容到viewer.mapv直接用

                }, {
                    key: 'getCenter',
                    value: function getCenter(isToWgs) {
                        return point.getCenter(this.viewer, isToWgs);
                    }
                }, {
                    key: 'getExtent',
                    value: function getExtent(opts) {
                        return point.getExtent(this.viewer, opts);
                    }
                }, {
                    key: 'getCameraView',
                    value: function getCameraView(isToWgs) {
                        return point.getCameraView(this.viewer, isToWgs);
                    }
                }, {
                    key: 'getSurfaceHeight',
                    value: function getSurfaceHeight(position, opts) {
                        return point.getSurfaceHeight(this.viewer.scene, position, opts);
                    }

                    //视角飞行定位到entiy处

                }, {
                    key: 'flyTo',
                    value: function flyTo(entity, opts) {
                        if (!entity) return;

                        opts = opts || {};
                        opts.scale = Cesium.defaultValue(opts.scale, 0.5);

                        if (_util.isArray(entity)) {
                            if (entity.length == 0) return;

                            if (entity.length == 1) {
                                this.flyTo(entity[0], opts);
                            } else {
                                //entity是数组
                                var extent = point.getExtent(entity, opts);
                                if (extent.xmin == extent.xmax || extent.ymin == extent.ymax) {
                                    //说明是单个的点数据（也有可能重合的多个点）
                                    this.flyTo(entity[0], opts);
                                } else if (extent.xmax - extent.xmin > 200) {
                                    //跨了180度线时
                                    this.viewer.flyTo(entity[0], opts);
                                } else {
                                    //是矩形区域时
                                    this.centerAt(extent, opts);
                                }
                            }
                        } else {
                            //点状数据时
                            if (entity.billboard || entity.point || entity.label || entity.model) {
                                var position = entity.position.getValue(_util.currentTime());
                                this.centerPoint(position, opts);
                            }
                            //圆数据时
                            else if (entity.ellipse) {
                                var radius1 = entity.ellipse.semiMajorAxis.getValue(_util.currentTime());
                                var radius2 = entity.ellipse.semiMinorAxis.getValue(_util.currentTime());

                                opts.radius = Math.max(radius1, radius2) * 3 * (1 + opts.scale);

                                var position = entity.position.getValue(_util.currentTime());
                                this.centerPoint(position, opts);
                            } else {
                                var extent = point.getExtent(entity, opts);
                                if (extent.xmin == extent.xmax || extent.ymin == extent.ymax) {
                                    //说明是单个的点数据（也有可能重合的多个点）
                                    var position = { x: extent.xmin, y: extent.ymin };
                                    this.centerPoint(position, opts);
                                } else if (extent.xmax - extent.xmin > 200) {
                                    //跨了180度线时
                                    this.viewer.flyTo(entity, opts);
                                } else {
                                    //是矩形区域时
                                    this.centerAt(extent, opts);
                                }
                            }
                        }
                    }

                    //键盘漫游，兼容历史方法

                }, {
                    key: 'keyboard',
                    value: function keyboard(isbind, speedRatio) {
                        if (isbind) this._keyboardRoam.bind(speedRatio); else this._keyboardRoam.unbind();
                    }
                }, {
                    key: 'keyboardAuto',
                    value: function keyboardAuto() {
                        return this._keyboardRoam.enable = !this._keyboardRoam.enable;
                    }

                    //获取指定图层 keyname默认为名称

                }, {
                    key: 'getLayer',
                    value: function getLayer(key, keyname) {
                        if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {
                            //直接传入config的object对象时
                            if (Cesium.defined(key.id)) return this.layers[key.id];
                        } else {
                            if (keyname == null) {
                                if (_util.isNumber(key)) keyname = "id"; else keyname = "name";
                            }

                            var layersCfg = this.arrBasemaps;
                            if (layersCfg && layersCfg.length > 0) {
                                for (var i = 0; i < layersCfg.length; i++) {
                                    var item = layersCfg[i];
                                    if (item == null || item.config[keyname] != key) continue;
                                    return item;
                                }
                            }

                            layersCfg = this.arrOperationallayers;
                            if (layersCfg && layersCfg.length > 0) {
                                for (var i = 0; i < layersCfg.length; i++) {
                                    var item = layersCfg[i];
                                    if (item == null || item.config[keyname] != key) continue;
                                    return item;
                                }
                            }
                        }

                        return null;
                    }
                    //根据config配置的id或name属性，更新显示指定的地图底图

                }, {
                    key: 'changeBasemap',
                    value: function changeBasemap(idorname) {
                        var layersCfg = this.arrBasemaps;
                        if (layersCfg.length == 0) {
                            console.log("baseLayerPicker为true时，无法changeBasemap外部切换底图，请关闭baseLayerPicker。");
                            return;
                        }

                        for (var i = 0; i < layersCfg.length; i++) {
                            var item = layersCfg[i];
                            if (item.config.type == "group" && item.config.layers == null) continue;

                            if (idorname == item.config.name || idorname == item.config.id) {
                                item.setVisible(true);
                                this.crs = item.config.crs; //坐标系 
                            } else {
                                item.setVisible(false);
                            }
                        }
                    }
                    //是否有地形数据

                }, {
                    key: 'hasTerrain',
                    value: function hasTerrain() {
                        if (this.terrainProvider == null) return false;
                        return _layer.hasTerrain(this.viewer);
                    }
                    //更新地形，参数传入是否显示地形

                }, {
                    key: 'updateTerrainProvider',
                    value: function updateTerrainProvider(isStkTerrain) {
                        if (isStkTerrain) {
                            if (this.terrainProvider == null) {
                                var cfg = this.config.terrain;
                                if (cfg && cfg.url) {
                                    if (this.config.serverURL) {
                                        cfg.url = cfg.url.replace('$serverURL$', this.config.serverURL);
                                    }
                                    cfg.url = cfg.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
                                }
                                this.terrainProvider = _layer.getTerrainProvider(cfg);
                            }
                            this.viewer.terrainProvider = this.terrainProvider;
                        } else {
                            this.viewer.terrainProvider = _layer.getEllipsoidTerrain();
                        }
                    }

                    //获取当前地图坐标系，值为gcj时表示是国测局偏移坐标

                }, {
                    key: 'getCrs',
                    value: function getCrs() {
                        return this.crs;
                    }
                    //在不同坐标系情况下，转换“目标坐标值”至“地图坐标系”一致的坐标

                }, {
                    key: 'point2map',
                    value: function point2map(point) {
                        switch (this.crs) {
                            case "gcj":
                                var point_clone = _util.clone(point);

                                var newpoint = pointconvert.wgs2gcj([point_clone.x, point_clone.y]);
                                point_clone.x = newpoint[0];
                                point_clone.y = newpoint[1];
                                return point_clone;
                                break;
                            case "bd":
                            case "baidu":
                                var point_clone = _util.clone(point);

                                var newpoint = pointconvert.wgs2bd([point_clone.x, point_clone.y]);
                                point_clone.x = newpoint[0];
                                point_clone.y = newpoint[1];
                                return point_clone;
                                break;
                            default:
                                return point;
                                break;
                        }
                    }
                    //在不同坐标系情况下 ，获取地图上的坐标后，转为wgs标准坐标系坐标值

                }, {
                    key: 'point2wgs',
                    value: function point2wgs(point) {
                        switch (this.crs) {
                            case "gcj":
                                var point_clone = _util.clone(point);
                                var newpoint = pointconvert.gcj2wgs([point_clone.x, point_clone.y]);
                                point_clone.x = newpoint[0];
                                point_clone.y = newpoint[1];
                                return point_clone;
                                break;
                            case "bd":
                            case "baidu":
                                var point_clone = _util.clone(point);
                                var newpoint = pointconvert.bd2wgs([point_clone.x, point_clone.y]);
                                point_clone.x = newpoint[0];
                                point_clone.y = newpoint[1];
                                return point_clone;
                                break;
                            default:
                                return point;
                                break;
                        }
                    }

                    //定位到 多个区域  顺序播放

                }, {
                    key: 'centerAtArr',
                    value: function centerAtArr(arr, enfun) {
                        this.cancelCenterAt();

                        this.arrCenterTemp = arr;
                        this._isCenterAtArr = true;
                        this._centerAtArrItem(0, enfun);
                    }
                }, {
                    key: '_centerAtArrItem',
                    value: function _centerAtArrItem(i, enfun) {
                        var that = this;
                        if (!this._isCenterAtArr || i < 0 || i >= this.arrCenterTemp.length) {
                            this._isCenterAtArr = false;
                            //console.log('centerAtArr视角切换全部结束');
                            if (enfun) enfun();
                            return;
                        }
                        var centeropt = this.arrCenterTemp[i];

                        //console.log('centerAtArr开始视角切换，第' + i + '点');
                        if (centeropt.onStart) centeropt.onStart();

                        this.centerAt(centeropt, {
                            duration: centeropt.duration,
                            complete: function complete() {
                                if (centeropt.onEnd) centeropt.onEnd();

                                var stopTime = Cesium.defaultValue(centeropt.stop, 1);
                                //console.log('centerAtArr第' + i + '点切换结束，将在此停留' + stopTime + '秒');

                                setTimeout(function () {
                                    that._centerAtArrItem(++i, enfun);
                                }, stopTime * 1000);
                            },
                            cancle: function cancle() {
                                this._isCenterAtArr = false;
                                if (enfun) enfun();
                            }
                        });
                    }
                }, {
                    key: 'cancelCenterAt',
                    value: function cancelCenterAt() {
                        this._isCenterAtArr = false;

                        this.viewer.camera.cancelFlight(); //取消飞行

                        // this.viewer.camera.flyTo({
                        //     destination: this.viewer.camera.position,
                        //     orientation: {
                        //         heading: this.viewer.camera.heading,
                        //         pitch: this.viewer.camera.pitch,
                        //         roll: this.viewer.camera.roll,
                        //     },
                        //     duration: 0,
                        // });
                    }

                    //地球定位至指定区域 ，options支持viewer.camera.flyTo所有参数

                }, {
                    key: 'centerAt',
                    value: function centerAt(centeropt, options) {
                        if (options == null) options = {}; else if (_util.isNumber(options)) options = { duration: options }; //兼容旧版本


                        if (centeropt == null) {
                            //让镜头飞行（动画）到配置默认区域 
                            options.isWgs84 = true;
                            centeropt = this.config.extent || this.config.center || { "y": 17.196575, "x": 114.184276, "z": 9377198, "heading": 0, "pitch": -80, "roll": 0 };
                        }

                        var optsClone = {};
                        for (var key in options) {
                            optsClone[key] = options[key];
                        }

                        if (centeropt.xmin && centeropt.xmax && centeropt.ymin && centeropt.ymax) {
                            //使用extent配置，相机可视范围
                            var xmin = centeropt.xmin;
                            var xmax = centeropt.xmax;
                            var ymin = centeropt.ymin;
                            var ymax = centeropt.ymax;

                            if (optsClone.isWgs84) {
                                //坐标转换为wgs
                                var pt1 = this.point2map({ x: xmin, y: ymin });
                                xmin = pt1.x;
                                ymin = pt1.y;

                                var pt2 = this.point2map({ x: xmax, y: ymax });
                                xmax = pt2.x;
                                ymax = pt2.y;
                            }

                            //绑定范围
                            optsClone.destination = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);

                            this.viewer.camera.flyTo(optsClone);
                        } else {
                            //存在hpr，为相机定位的方式 
                            if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

                            var height = Cesium.defaultValue(optsClone.minz, 2500);
                            if (this.viewer.camera.positionCartographic.height < height) height = this.viewer.camera.positionCartographic.height;
                            if (centeropt.z != null && centeropt.z != 0) height = centeropt.z;

                            optsClone.destination = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, height); //经度、纬度、高度 
                            optsClone.orientation = {
                                heading: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.heading, 0)), //绕垂直于地心的轴旋转
                                pitch: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.pitch, -90)), //绕纬度线旋转
                                roll: Cesium.Math.toRadians(Cesium.defaultValue(centeropt.roll, 0)) //绕经度线旋转
                            };
                            this.viewer.camera.flyTo(optsClone);
                        }
                    }
                    //定位至目标点， options支持viewer.camera.flyToBoundingSphere所有参数

                }, {
                    key: 'centerPoint',
                    value: function centerPoint(centeropt, options) {

                        if (options == null) options = {};

                        var optsClone = {};
                        for (var key in options) {
                            optsClone[key] = options[key];
                        }

                        //目标点位置 
                        if (optsClone.isWgs84) centeropt = this.point2map(centeropt);

                        var position;
                        if (centeropt instanceof Cesium.Cartesian3) position = centeropt; else position = Cesium.Cartesian3.fromDegrees(centeropt.x, centeropt.y, Cesium.defaultValue(centeropt.z, 0)); //经度、纬度、高度  
                        var radius = Cesium.defaultValue(options.radius, 1000);

                        optsClone.offset = {
                            heading: Cesium.Math.toRadians(Cesium.defaultValue(options.heading, 0)),
                            pitch: Cesium.Math.toRadians(Cesium.defaultValue(options.pitch, -90)),
                            range: radius
                        };
                        //duration
                        this.viewer.camera.flyToBoundingSphere(new Cesium.BoundingSphere(position, 0), optsClone);
                    }

                    //是否在调用了openFlyAnimation正在进行飞行动画

                }, {
                    key: 'isFlyAnimation',
                    value: function isFlyAnimation() {
                        return this._isFlyAnimation;
                    }
                    //开场动画，动画播放地球飞行定位指指定区域（默认为config.josn中配置的视域）

                }, {
                    key: 'openFlyAnimation',
                    value: function openFlyAnimation(endfun, centeropt) {
                        var that = this;
                        var viewer = this.viewer;
                        var view = centeropt || point.getCameraView(viewer); //默认为原始视角

                        this._isFlyAnimation = true;
                        viewer.camera.setView({
                            destination: Cesium.Cartesian3.fromDegrees(-85.16, 13.71, 23000000.0)
                        });
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, 23000000.0),
                            duration: 2,
                            easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                            complete: function complete() {
                                var z = Cesium.defaultValue(view.z, 90000);
                                if (z < 200000 && view.pitch != -90) {
                                    z = z * 1.2 + 8000;
                                    viewer.camera.flyTo({
                                        destination: Cesium.Cartesian3.fromDegrees(view.x, view.y, z),
                                        complete: function complete() {
                                            that.centerAt(view, {
                                                duration: 2,
                                                complete: function complete() {
                                                    that._isFlyAnimation = false;
                                                    if (endfun) endfun();
                                                }
                                            });
                                        }
                                    });
                                } else {
                                    that.centerAt(view, {
                                        complete: function complete() {
                                            that._isFlyAnimation = false;
                                            if (endfun) endfun();
                                        }
                                    });
                                }
                            }
                        });
                    }
                    //旋转地球 

                }, {
                    key: 'rotateAnimation',
                    value: function rotateAnimation(endfun, duration) {
                        var viewer = this.viewer;

                        var first = point.getCameraView(viewer); //默认为原始视角
                        var duration3 = duration / 3;

                        //动画 1/3
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromDegrees(first.x + 120, first.y, first.z),
                            orientation: {
                                heading: Cesium.Math.toRadians(first.heading),
                                pitch: Cesium.Math.toRadians(first.pitch),
                                roll: Cesium.Math.toRadians(first.roll)
                            },
                            duration: duration3,
                            easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                            complete: function complete() {

                                //动画 2/3
                                viewer.camera.flyTo({
                                    destination: Cesium.Cartesian3.fromDegrees(first.x + 240, first.y, first.z),
                                    orientation: {
                                        heading: Cesium.Math.toRadians(first.heading),
                                        pitch: Cesium.Math.toRadians(first.pitch),
                                        roll: Cesium.Math.toRadians(first.roll)
                                    },
                                    duration: duration3,
                                    easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                                    complete: function complete() {

                                        //动画 3/3
                                        viewer.camera.flyTo({
                                            destination: Cesium.Cartesian3.fromDegrees(first.x, first.y, first.z),
                                            orientation: {
                                                heading: Cesium.Math.toRadians(first.heading),
                                                pitch: Cesium.Math.toRadians(first.pitch),
                                                roll: Cesium.Math.toRadians(first.roll)
                                            },
                                            duration: duration3,
                                            easingFunction: Cesium.EasingFunction.LINEAR_NONE,
                                            complete: function complete() {
                                                if (endfun) endfun();
                                            }
                                        });
                                        //动画3/3 end 
                                    }
                                });
                                //动画2/3 end
                            }
                        });
                        //动画1/3 end
                    }

                    //添加“导航”控件

                }, {
                    key: '_addNavigationWidget',
                    value: function _addNavigationWidget(item) {
                        if (Cesium.viewerCesiumNavigationMixin) {
                            //兼容v1版本
                            this.viewer.extend(Cesium.viewerCesiumNavigationMixin, {
                                defaultResetView: Cesium.Rectangle.fromDegrees(110, 20, 120, 30),
                                enableZoomControls: false
                            });
                        }

                        if (Cesium.CesiumNavigation) {
                            //当前版本
                            var options = {};
                            // 用于在使用重置导航重置地图视图时设置默认视图控制。接受的值是Cesium.Cartographic 和 Cesium.Rectangle.
                            options.defaultResetView = Cesium.Rectangle.fromDegrees(110, 20, 120, 30);
                            // 用于启用或禁用罗盘。true是启用罗盘，false是禁用罗盘。默认值为true。如果将选项设置为false，则罗盘将不会添加到地图中。
                            options.enableCompass = true;
                            // 用于启用或禁用缩放控件。true是启用，false是禁用。默认值为true。如果将选项设置为false，则缩放控件将不会添加到地图中。
                            options.enableZoomControls = false;
                            // 用于启用或禁用距离图例。true是启用，false是禁用。默认值为true。如果将选项设置为false，距离图例将不会添加到地图中。
                            options.enableDistanceLegend = true;
                            // 用于启用或禁用指南针外环。true是启用，false是禁用。默认值为true。如果将选项设置为false，则该环将可见但无效。
                            options.enableCompassOuterRing = true;

                            Cesium.CesiumNavigation(this.viewer, options);
                        }

                        //比例尺
                        (0, _zepto.zepto)(".distance-legend").css({
                            "left": "-10px",
                            "bottom": "-1px",
                            "border": "none",
                            "background": "rgba(0, 0, 0, 0)"
                        });

                        if (item.legend) {
                            var css = item.legend;
                            //插件的默认值：right: 25px; bottom: 30px;
                            if (Cesium.defined(css.top) && css.top != "auto") {
                                css.bottom = "auto";
                            }
                            if (Cesium.defined(css.left) && css.left != "auto") {
                                css.right = "auto";
                            }

                            (0, _zepto.zepto)(".distance-legend").css(css);
                        } else {
                            (0, _zepto.zepto)(".distance-legend").remove();
                        }

                        //导航球
                        if (item.compass) {
                            var css = item.compass;
                            //插件的默认值： top: 100px; right: 0; 
                            if (Cesium.defined(css.bottom) && css.bottom != "auto") {
                                css.top = "auto";
                            }
                            if (Cesium.defined(css.left) && css.left != "auto") {
                                css.right = "auto";
                            }
                            (0, _zepto.zepto)(".compass").css(css);
                        } else {
                            (0, _zepto.zepto)(".compass").remove();
                        }

                        //zepto(".navigation-controls").css({
                        //    "right": "5px",
                        //    "bottom": "30px",
                        //    "top": "auto"
                        //});
                        (0, _zepto.zepto)(".navigation-controls").remove();
                    }
                    //导出场景图片，截图

                }, {
                    key: 'expImage',
                    value: function expImage(opts) {
                        opts = opts || {};
                        opts.download = Cesium.defaultValue(opts.download, true);
                        opts.type = Cesium.defaultValue(opts.type, "image/jpeg");

                        var width, height;
                        var viewer = this.viewer;

                        viewer.render();
                        var imgdata = viewer.canvas.toDataURL(opts.type, opts.encoderOptions);

                        if (Cesium.defined(opts.width) || Cesium.defined(opts.height)) {
                            //指定了高或宽度后，图片压缩处理
                            var image = new Image();
                            image.onload = function () {
                                //图片压缩处理

                                if (Cesium.defined(opts.width)) {
                                    width = opts.width;
                                    height = opts.height || Math.round(width * viewer.canvas.height / viewer.canvas.width);
                                } else {
                                    height = opts.height;
                                    width = Math.round(height * viewer.canvas.width / viewer.canvas.height);
                                }

                                var canvas, ctx;
                                canvas = document.createElement('canvas');
                                canvas.width = width;
                                canvas.height = height;
                                ctx = canvas.getContext("2d");
                                ctx.drawImage(image, 0, 0, width, height);
                                var imgdataNew = canvas.toDataURL(opts.type, opts.encoderOptions);

                                if (!opts.filename) {
                                    opts.filename = "场景出图_" + width + "x" + height;
                                }
                                if (opts.download) _util.downloadBase64Image(opts.filename, imgdataNew);
                                if (opts.calback) opts.calback(imgdataNew, { width: width, height: height });
                            };
                            image.src = imgdata;
                        } else {
                            //高清原图
                            height = viewer.canvas.height, width = viewer.canvas.width;

                            if (!opts.filename) {
                                opts.filename = "场景出图_" + width + "x" + height;
                            }
                            if (opts.download) _util.downloadBase64Image(opts.filename, imgdata);
                            if (opts.calback) opts.calback(imgdata, { width: width, height: height });
                        }
                    }

                    //销毁资源

                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this._tooltip.destroy();
                        this._popup.destroy();

                        if (this._keyboardRoam) {
                            this._keyboardRoam.destroy();
                            this._keyboardRoam = null;
                        }

                        if (this._contextmenu) {
                            this._contextmenu.destroy();
                            this._contextmenu = null;
                        }

                        if (this._location) {
                            this._location.destroy();
                            this._location = null;
                        }
                        if (this._mouseZoomStyle) {
                            this._mouseZoomStyle.destroy();
                            this._mouseZoomStyle = null;
                        }
                    }
                }, {
                    key: 'keyboardRoam',
                    get: function get() {
                        return this._keyboardRoam;
                    }
                }, {
                    key: 'contextmenu',
                    get: function get() {
                        return this._contextmenu;
                    }
                }, {
                    key: 'location',
                    get: function get() {
                        return this._location;
                    }
                }, {
                    key: 'popup',
                    get: function get() {
                        return this._popup;
                    }
                }, {
                    key: 'tooltip',
                    get: function get() {
                        return this._tooltip;
                    }

                    //右键菜单 

                }, {
                    key: 'contextmenuItems',
                    get: function get() {
                        return this._contextmenuItems;
                    },
                    set: function set(val) {
                        this._contextmenuItems = val;
                    }
                }, {
                    key: 'defaultContextmenuItems',
                    get: function get() {
                        return this.config.contextmenuItems || (0, _ContextMenu.getDefaultContextMenu)(this.viewer);
                    }

                    //默认绑定的draw控件

                }, {
                    key: 'draw',
                    get: function get() {
                        if (this._drawControl == null) {
                            this._drawControl = new _Draw.Draw(this.viewer, {
                                hasEdit: false
                            });
                        }
                        return this._drawControl;
                    }
                }]);

                return ViewerEx;
            }();

            /***/
}),
/* 47 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CircleWaveMaterial = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CircleWave = __webpack_require__(82);

            var _CircleWave2 = _interopRequireDefault(_CircleWave);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var defaultColor = new Cesium.Color(0, 0, 0, 0);
            var count = 2;
            var gradient = 0.1;

            //圆形 单个扩散效果 材质 

            var CircleWaveMaterial = exports.CircleWaveMaterial = function () {
                //========== 构造方法 ========== 
                function CircleWaveMaterial(options) {
                    _classCallCheck(this, CircleWaveMaterial);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    this._definitionChanged = new Cesium.Event();
                    this._color = undefined;
                    this._colorSubscription = undefined;

                    this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
                    this._duration = Cesium.defaultValue(options.duration, 1000); //时长
                    this._count = Cesium.defaultValue(options.count, count); //圆圈个数
                    if (this._count <= 0) this._count = 1;

                    this._gradient = Cesium.defaultValue(options.gradient, gradient); //透明度的幂方（0-1）,0表示无虚化效果，1表示虚化成均匀渐变
                    if (this._gradient < 0) this._gradient = 0;
                    if (this._gradient > 1) this._gradient = 1;

                    this._time = undefined;
                }

                //========== 对外属性 ==========  


                _createClass(CircleWaveMaterial, [{
                    key: "getType",


                    //========== 方法 ========== 
                    /**
                     * Gets the {@link Cesium.Material} type at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the type.
                     * @returns {String} The type of material.
                     */
                    value: function getType(time) {
                        return Cesium.Material.CircleWaveMaterialType;
                    }

                    /**
                     * Gets the value of the property at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the value.
                     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
                     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
                     */

                }, {
                    key: "getValue",
                    value: function getValue(time, result) {
                        if (!Cesium.defined(result)) {
                            result = {};
                        }
                        result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);

                        if (this._time === undefined) {
                            this._time = new Date().getTime();
                        }
                        result.time = (new Date().getTime() - this._time) / this._duration;
                        result.count = this._count;
                        result.gradient = 1 + 10 * (1 - this._gradient);
                        return result;
                    }

                    /**
                     * Compares this property to the provided property and returns
                     * <code>true</code> if they are equal, <code>false</code> otherwise.
                     *
                     * @param { Cesium.Property} [other] The other property.
                     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
                     */

                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this === other || //
                            other instanceof CircleWaveMaterial && Cesium.Property.equals(this._color, other._color);
                    }
                }, {
                    key: "isConstant",
                    get: function get() {
                        return false;
                    }
                }, {
                    key: "definitionChanged",
                    get: function get() {
                        return this._definitionChanged;
                    }
                }]);

                return CircleWaveMaterial;
            }();

            Object.defineProperties(CircleWaveMaterial.prototype, {
                /**
                 * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
                 * @memberof PolylineGlowMaterialProperty.prototype
                 * @type { Cesium.Property}
                 */
                color: Cesium.createPropertyDescriptor('color')
            });

            //静态方法，处理材质
            Cesium.Material.CircleWaveMaterialType = 'CircleWaveMaterial'; /**  渐变的气泡 */
            Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleWaveMaterialType, {
                fabric: {
                    type: Cesium.Material.CircleWaveMaterialType,
                    uniforms: {
                        color: new Cesium.Color(1, 0, 0, 1.0),
                        time: 1,
                        count: count,
                        gradient: gradient
                    },
                    source: _CircleWave2.default
                },
                translucent: function translucent() {
                    return true;
                }
            });

            /***/
}),
/* 48 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TileLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _BaseLayer = __webpack_require__(13);

            var _layer = __webpack_require__(20);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var TileLayer = _BaseLayer.BaseLayer.extend({
                layer: null,
                //添加 
                add: function add() {
                    if (this.layer != null) {
                        this.remove();
                    }
                    this.addEx();
                    var imageryProvider = this.createImageryProvider(this.config);
                    if (!Cesium.defined(imageryProvider)) return;

                    var options = this.config;

                    var imageryOpt = {
                        show: true, alpha: this._opacity
                    };
                    if (Cesium.defined(options.rectangle) && Cesium.defined(options.rectangle.xmin) && Cesium.defined(options.rectangle.xmax) && Cesium.defined(options.rectangle.ymin) && Cesium.defined(options.rectangle.ymax)) {
                        var xmin = options.rectangle.xmin;
                        var xmax = options.rectangle.xmax;
                        var ymin = options.rectangle.ymin;
                        var ymax = options.rectangle.ymax;
                        var rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
                        this.rectangle = rectangle;
                        imageryOpt.rectangle = rectangle;
                    }
                    if (Cesium.defined(options.brightness)) imageryOpt.brightness = options.brightness;
                    if (Cesium.defined(options.contrast)) imageryOpt.contrast = options.contrast;
                    if (Cesium.defined(options.hue)) imageryOpt.hue = options.hue;
                    if (Cesium.defined(options.saturation)) imageryOpt.saturation = options.saturation;
                    if (Cesium.defined(options.gamma)) imageryOpt.gamma = options.gamma;
                    if (Cesium.defined(options.maximumAnisotropy)) imageryOpt.maximumAnisotropy = options.maximumAnisotropy;
                    if (Cesium.defined(options.minimumTerrainLevel)) imageryOpt.minimumTerrainLevel = options.minimumTerrainLevel;
                    if (Cesium.defined(options.maximumTerrainLevel)) imageryOpt.maximumTerrainLevel = options.maximumTerrainLevel;

                    this.layer = new Cesium.ImageryLayer(imageryProvider, imageryOpt);
                    this.layer.config = this.config;

                    this.viewer.imageryLayers.add(this.layer);

                    this.setZIndex(this.config.order);
                },
                //方便外部继承覆盖该方法
                createImageryProvider: function createImageryProvider(config) {
                    return (0, _layer.createImageryProvider)(config); //调用layer.js
                },
                addEx: function addEx() {
                    //子类使用

                },
                //移除
                remove: function remove() {
                    if (this.layer == null) return;

                    this.removeEx();
                    this.viewer.imageryLayers.remove(this.layer, true);
                    this.layer = null;
                },
                removeEx: function removeEx() {
                    //子类使用

                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    if (this.layer == null) return;

                    if (this.config.extent || this.config.center) {
                        this.viewer.mapv.centerAt(this.config.extent || this.config.center, { duration: duration, isWgs84: true });
                    } else if (Cesium.defined(this.rectangle)) {
                        this.viewer.camera.flyTo({
                            destination: this.rectangle,
                            duration: duration
                        });
                    } else {
                        var rectangle = this.layer.imageryProvider.rectangle; //arcgis图层等，读取配置信息
                        if (Cesium.defined(rectangle) && rectangle != Cesium.Rectangle.MAX_VALUE && rectangle.west > 0 && rectangle.south > 0 && rectangle.east > 0 && rectangle.north > 0) {
                            this.viewer.camera.flyTo({
                                destination: rectangle,
                                duration: duration
                            });
                        }
                    }
                },
                //设置透明度
                hasOpacity: true,
                _opacity: 1,
                setOpacity: function setOpacity(value) {
                    this._opacity = value;
                    if (this.layer == null) return;

                    this.layer.alpha = value;
                },
                //设置叠加顺序
                hasZIndex: true,
                setZIndex: function setZIndex(order) {
                    if (this.layer == null || order == null) return;

                    //先移动到最顶层
                    this.viewer.imageryLayers.raiseToTop(this.layer);

                    var layers = this.viewer.imageryLayers._layers;
                    for (var i = layers.length - 1; i >= 0; i--) {
                        if (layers[i] == this.layer) continue;
                        var _temp = layers[i].config;
                        if (_temp && _temp.order) {
                            if (order < _temp.order) {
                                this.viewer.imageryLayers.lower(this.layer);
                            }
                        }
                    }
                }

            });

            exports.TileLayer = TileLayer;

            /***/
}),
/* 49 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            //平面
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "dimensionsY":
                        case "plane_distance":
                        case "distanceDisplayCondition_far":
                        case "distanceDisplayCondition_near":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "dimensionsX":
                            //平面的长宽
                            var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                            var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                            entityattr.dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
                            break;
                        case "plane_normal":
                            //平面的方向及距离
                            var plane_normal;
                            switch (value) {
                                case "x":
                                    plane_normal = Cesium.Cartesian3.UNIT_X;
                                    break;
                                case "y":
                                    plane_normal = Cesium.Cartesian3.UNIT_Y;
                                    break;
                                default:
                                    plane_normal = Cesium.Cartesian3.UNIT_Z;
                                    break;
                            }
                            var plane_distance = Cesium.defaultValue(style.plane_distance, 0.0);
                            entityattr.plane = new Cesium.Plane(plane_normal, plane_distance);
                            break;

                        case "distanceDisplayCondition":
                            //是否按视距显示
                            if (value) {
                                entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(style.distanceDisplayCondition_near || 0), Number(style.distanceDisplayCondition_far || 100000));
                            } else {
                                entityattr.distanceDisplayCondition = undefined;
                            }
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 50 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            //盒子
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "dimensionsY":
                        case "dimensionsZ":
                        case "distanceDisplayCondition_far":
                        case "distanceDisplayCondition_near":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "dimensionsX":
                            //盒子的长宽高
                            var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                            var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                            var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
                            entityattr.dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);
                            break;
                        case "distanceDisplayCondition":
                            //是否按视距显示
                            if (value) {
                                entityattr.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(Number(style.distanceDisplayCondition_near || 0), Number(style.distanceDisplayCondition_far || 100000));
                            } else {
                                entityattr.distanceDisplayCondition = undefined;
                            }
                            break;
                        case "clampToGround":
                            //贴地
                            if (value) entityattr.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND; else entityattr.heightReference = Cesium.HeightReference.NONE;
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 51 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {};
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "radius":
                        case "shape":

                        case "grid_lineCount":
                        case "grid_lineThickness":
                        case "grid_cellAlpha":
                        case "checkerboard_repeat":
                        case "checkerboard_oddcolor":
                        case "stripe_oddcolor":
                        case "stripe_repeat":
                        case "animationDuration":
                        case "animationImage":
                        case "animationRepeatX":
                        case "animationRepeatY":
                        case "animationAxisY":
                        case "animationGradient":
                        case "animationCount":
                        case "randomColor":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                    }
                }

                //材质优先
                if (style.material) entityattr.material = style.material;

                //管道样式 
                style.radius = style.radius || 10;
                switch (style.shape) {
                    default:
                    case "pipeline":
                        entityattr.shape = getCorridorShape1(style.radius); //（厚度固定为半径的1/3）
                        break;
                    case "circle":
                        entityattr.shape = getCorridorShape2(style.radius);
                        break;
                    case "star":
                        entityattr.shape = getCorridorShape3(style.radius);
                        break;
                }

                return entityattr;
            }

            //管道形状1【内空管道】 radius整个管道的外半径 
            function getCorridorShape1(radius) {
                var hd = radius / 3;
                var startAngle = 0;
                var endAngle = 360;

                var pss = [];
                for (var i = startAngle; i <= endAngle; i++) {
                    var radians = Cesium.Math.toRadians(i);
                    pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
                }
                for (var i = endAngle; i >= startAngle; i--) {
                    var radians = Cesium.Math.toRadians(i);
                    pss.push(new Cesium.Cartesian2((radius - hd) * Math.cos(radians), (radius - hd) * Math.sin(radians)));
                }
                return pss;
            }

            //管道形状2【圆柱体】 radius整个管道的外半径 
            function getCorridorShape2(radius) {
                var startAngle = 0;
                var endAngle = 360;

                var pss = [];
                for (var i = startAngle; i <= endAngle; i++) {
                    var radians = Cesium.Math.toRadians(i);
                    pss.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
                }
                return pss;
            }

            //管道形状3【星状】 radius整个管道的外半径 ,arms星角的个数（默认6个角）
            function getCorridorShape3(radius, arms) {
                var arms = arms || 6;
                var angle = Math.PI / arms;
                var length = 2 * arms;
                var pss = new Array(length);
                for (var i = 0; i < length; i++) {
                    var r = i % 2 === 0 ? radius : radius / 3;
                    pss[i] = new Cesium.Cartesian2(Math.cos(i * angle) * r, Math.sin(i * angle) * r);
                }
                return pss;
            }

            //获取entity的坐标
            function getPositions(entity) {
                if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw; //取绑定的数据

                return entity.polylineVolume.positions.getValue((0, _util.currentTime)());
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "LineString",
                        coordinates: coordinates
                    }
                };
            }

            /***/
}),
/* 52 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (!entityattr) {
                    entityattr = {
                        fill: true
                    };
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "color": //填充颜色
                        case "materialType":

                        case "grid_lineCount":
                        case "grid_lineThickness":
                        case "grid_cellAlpha":
                        case "checkerboard_repeat":
                        case "checkerboard_oddcolor":
                        case "stripe_oddcolor":
                        case "stripe_repeat":
                        case "animationDuration":
                        case "animationImage":
                        case "animationRepeatX":
                        case "animationRepeatY":
                        case "animationAxisY":
                        case "animationGradient":
                        case "animationCount":
                        case "randomColor":

                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return entity.wall.positions.getValue((0, _util.currentTime)());
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "LineString",
                        coordinates: coordinates
                    }
                };
            }

            /***/
}),
/* 53 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值
                    entityattr = {
                        fill: true
                    };
                }

                //贴地时，剔除高度相关属性
                if (style.clampToGround) {
                    if (style.hasOwnProperty('height')) delete style.height;
                    if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "cornerType":
                            switch (value) {
                                case "BEVELED":
                                    entityattr.cornerType = Cesium.CornerType.BEVELED;
                                    break;
                                case "MITERED":
                                    entityattr.cornerType = Cesium.CornerType.MITERED;
                                    break;
                                case "ROUNDED":
                                    entityattr.cornerType = Cesium.CornerType.ROUNDED;
                                    break;
                                default:
                                    entityattr.cornerType = value;
                                    break;
                            }
                            break;

                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return entity.corridor.positions.getValue((0, _util.currentTime)());
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "LineString",
                        coordinates: coordinates
                    }
                };
            }

            /***/
}),
/* 54 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {
                        fill: true,
                        topRadius: 0
                    };
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];

                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "color":
                        case "animation":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "radius":
                            //半径（圆）
                            entityattr.topRadius = Number(value);
                            entityattr.bottomRadius = Number(value);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                var positon = entity.position.getValue((0, _util.currentTime)());

                if (entity._positions_draw && entity._positions_draw.length > 0) positon = entity._positions_draw[0];

                return [positon];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 55 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;
            exports.getOutlinePositions = getOutlinePositions;
            exports.getOutlineCoordinates = getOutlineCoordinates;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {};
                }

                //贴地时，剔除高度相关属性
                if (style.clampToGround) {
                    if (style.hasOwnProperty('height')) delete style.height;
                    if (style.hasOwnProperty('extrudedHeight')) delete style.extrudedHeight;
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":

                        case "grid_lineCount":
                        case "grid_lineThickness":
                        case "grid_cellAlpha":
                        case "checkerboard_repeat":
                        case "checkerboard_oddcolor":
                        case "stripe_oddcolor":
                        case "stripe_repeat":
                        case "animationDuration":
                        case "animationImage":
                        case "animationRepeatX":
                        case "animationRepeatY":
                        case "animationAxisY":
                        case "animationGradient":
                        case "animationCount":
                        case "randomColor":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "height":
                            entityattr.height = Number(value);
                            if (style.extrudedHeight) entityattr.extrudedHeight = Number(style.extrudedHeight) + Number(value);
                            break;
                        case "extrudedHeight":
                            entityattr.extrudedHeight = Number(entityattr.height || style.height || 0) + Number(value);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "image":
                            //填充图片
                            entityattr.material = new Cesium.ImageMaterialProperty({
                                image: style.image,
                                color: new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(Number(style.opacity || 1.0))
                            });
                            break;
                        case "rotation":
                            //旋转角度 
                            entityattr.rotation = Cesium.Math.toRadians(value);
                            if (!style.stRotation) entityattr.stRotation = Cesium.Math.toRadians(value);
                            break;
                        case "stRotation":
                            entityattr.stRotation = Cesium.Math.toRadians(value);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                if (!entity.rectangle) return null;

                if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw;

                var time = (0, _util.currentTime)();
                var re = entity.rectangle.coordinates.getValue(time); //Rectangle
                var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

                var pt1 = Cesium.Cartesian3.fromRadians(re.west, re.south, height);
                var pt2 = Cesium.Cartesian3.fromRadians(re.east, re.north, height);
                return [pt1, pt2];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);

                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: {
                        type: "MultiPoint",
                        coordinates: coordinates
                    }
                };
            }

            //获取entity对应的 边界 的坐标
            function getOutlinePositions(entity, noAdd) {
                if (!entity.rectangle) return null;

                var time = (0, _util.currentTime)();
                var re = entity.rectangle.coordinates.getValue(time); //Rectangle
                if (!re) return null;
                var height = entity.rectangle.height ? entity.rectangle.height.getValue(time) : 0;

                var pt1 = Cesium.Cartesian3.fromRadians(re.west, re.south, height);
                var pt2 = Cesium.Cartesian3.fromRadians(re.east, re.south, height);
                var pt3 = Cesium.Cartesian3.fromRadians(re.east, re.north, height);
                var pt4 = Cesium.Cartesian3.fromRadians(re.west, re.north, height);

                var arr = [pt1, pt2, pt3, pt4];
                if (!noAdd) arr.push(pt1);

                return arr;
            }

            //获取entity对应的 边界 的坐标（geojson规范的格式）
            function getOutlineCoordinates(entity, noAdd) {
                var positions = getOutlinePositions(entity, noAdd);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            /***/
}),
/* 56 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.style2Entity = style2Entity;
            exports.getPositions = getPositions;
            exports.getCoordinates = getCoordinates;
            exports.toGeoJSON = toGeoJSON;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _globe = __webpack_require__(15);

            var globe = _interopRequireWildcard(_globe);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //属性赋值到entity
            //椭球体
            function style2Entity(style, entityattr) {
                style = style || {};

                if (entityattr == null) {
                    //默认值 
                    entityattr = {
                        fill: true
                    };
                }

                //Style赋值值Entity
                for (var key in style) {
                    var value = style[key];
                    switch (key) {
                        default:
                            //直接赋值
                            entityattr[key] = value;
                            break;
                        case "opacity": //跳过扩展其他属性的参数
                        case "outlineOpacity":
                        case "widthRadii":
                        case "heightRadii":
                            break;
                        case "outlineColor":
                            //边框颜色
                            entityattr.outlineColor = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(style.outlineOpacity || style.opacity || 1.0);
                            break;
                        case "color":
                            //填充颜色
                            entityattr.material = new Cesium.Color.fromCssColorString(value || "#FFFF00").withAlpha(Number(style.opacity || 1.0));
                            break;
                        case "extentRadii":
                            //球体长宽高半径
                            var extentRadii = style.extentRadii || 100;
                            var widthRadii = style.widthRadii || 100;
                            var heightRadii = style.heightRadii || 100;
                            entityattr.radii = new Cesium.Cartesian3(extentRadii, widthRadii, heightRadii);
                            break;
                    }
                }

                //设置填充材质
                globe.setFillMaterial(entityattr, style);

                return entityattr;
            }

            //获取entity的坐标
            function getPositions(entity) {
                return [entity.position.getValue((0, _util.currentTime)())];
            }

            //获取entity的坐标（geojson规范的格式）
            function getCoordinates(entity) {
                var positions = getPositions(entity);
                var coordinates = pointconvert.cartesians2lonlats(positions);
                return coordinates;
            }

            //entity转geojson
            function toGeoJSON(entity) {
                var coordinates = getCoordinates(entity);
                return {
                    type: "Feature",
                    properties: entity.attribute || {},
                    geometry: { type: "Point", coordinates: coordinates[0] }
                };
            }

            /***/
}),
/* 57 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPoint = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPoint = exports.EditPoint = _Edit.EditBase.extend({
                //外部更新位置
                setPositions: function setPositions(position) {
                    if (util.isArray(position) && position.length == 1) {
                        position = position[0];
                    }
                    this.entity.position.setValue(position);
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    this.entity.draw_tooltip = _Tooltip.message.dragger.def;
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        dragger: this.entity,
                        onDrag: function onDrag(dragger, newPosition) {
                            that.entity.position.setValue(newPosition);
                        }
                    });
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity.draw_tooltip = null;
                }

            });

            /***/
}),
/* 58 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditCurve = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Edit = __webpack_require__(22);

            var _Attr = __webpack_require__(29);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditCurve = exports.EditCurve = _Edit.EditPolyline.extend({
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;
                    this._positions_show = this.entity._positions_show || this.getGraphic().positions.getValue(this.viewer.clock.currentTime);
                },
                //坐标位置相关  
                updateAttrForEditing: function updateAttrForEditing() {
                    if (this._positions_draw == null || this._positions_draw.length < 3) {
                        this._positions_show = this._positions_draw;
                        return;
                    }

                    this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
                    this.entity._positions_show = this._positions_show;
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_show = this._positions_show;
                    this.entity._positions_draw = this._positions_draw;
                }

            });

            /***/
}),
/* 59 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPolylineVolume = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Edit = __webpack_require__(22);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPolylineVolume = exports.EditPolylineVolume = _Edit.EditPolyline.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.polylineVolume;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;
                }

            });

            /***/
}),
/* 60 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditCorridor = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(22);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditCorridor = exports.EditCorridor = _Edit.EditPolyline.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.corridor;
                },
                //继承父类，根据属性更新坐标
                updatePositionsHeightByAttr: function updatePositionsHeightByAttr(position) {
                    if (this.getGraphic().height != undefined) {
                        var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                        position = (0, _point.setPositionsHeight)(position, newHeight);
                    }
                    return position;
                }

            });

            /***/
}),
/* 61 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPolygon = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(19);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(25);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPolygon = exports.DrawPolygon = _Draw.DrawPolyline.extend({
                type: 'polygon',
                //坐标位置相关
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 9999, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditPolygon,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
                    if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

                    if (attribute.config) {
                        //允许外部传入
                        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
                    } else {
                        this._minPointNum = this._minPointNum_def;
                        this._maxPointNum = this._maxPointNum_def;
                    }

                    var that = this;
                    var addattr = {
                        polygon: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    addattr.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                        var positions = that.getDrawPosition();
                        return new Cesium.PolygonHierarchy(positions);
                    }, false);

                    //线：绘制时前2点时 + 边线宽度大于1时
                    addattr.polyline = {
                        clampToGround: attribute.style.clampToGround,
                        show: false
                    };

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象

                    this.bindOutline(this.entity); //边线


                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.polygon);
                },
                bindOutline: function bindOutline(entity) {
                    //是否显示：绘制时前2点时 或 边线宽度大于1时
                    entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                        var arr = attr.getPositions(entity, true);
                        if (arr && arr.length < 3) return true;

                        return entity.polygon.outline && entity.polygon.outline.getValue(time) && entity.polygon.outlineWidth && entity.polygon.outlineWidth.getValue(time) > 1;
                    }, false);

                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        if (!entity.polyline.show.getValue(time)) return null;

                        var arr = attr.getPositions(entity, true);
                        if (arr && arr.length < 3) return arr;

                        return arr.concat([arr[0]]);
                    }, false);
                    entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                        var arr = attr.getPositions(entity, true);
                        if (arr && arr.length < 3) return 2;

                        return entity.polygon.outlineWidth;
                    }, false);

                    entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        var arr = attr.getPositions(entity, true);
                        if (arr && arr.length < 3) {
                            if (entity.polygon.material.color) return entity.polygon.material.color.getValue(time); else return Cesium.Color.YELLOW;
                        }
                        return entity.polygon.outlineColor.getValue(time);
                    }, false));
                },
                updateAttrForDrawing: function updateAttrForDrawing() {

                    var style = this.entity.attribute.style;
                    if (style.extrudedHeight) {
                        //存在extrudedHeight高度设置时
                        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                        this.entity.polygon.extrudedHeight = maxHight + Number(style.extrudedHeight);
                    }
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.polygon.hierarchy = new Cesium.CallbackProperty(function (time) {
                        var positions = entity._positions_draw;
                        return new Cesium.PolygonHierarchy(positions);
                    }, false);
                }

            });

            /***/
}),
/* 62 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditRectangle = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(25);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditRectangle = exports.EditRectangle = _Edit.EditPolygon.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.rectangle;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_draw = this._positions_draw;
                },
                isClampToGround: function isClampToGround() {
                    return this.entity.attribute.style.clampToGround;
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var clampToGround = this.isClampToGround();
                    var positions = this.getPosition();

                    for (var i = 0, len = positions.length; i < len; i++) {
                        var position = positions[i];

                        if (this.getGraphic().height != undefined) {
                            var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                        }

                        if (clampToGround) {
                            //贴地时求贴模型和贴地的高度
                            position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
                        }

                        //各顶点
                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: position,
                            //clampToGround: clampToGround,
                            onDrag: function onDrag(dragger, position) {
                                var time = that.viewer.clock.currentTime;
                                if (that.getGraphic().height != undefined) {
                                    var newHeight = that.getGraphic().height.getValue(time);
                                    position = (0, _point.setPositionsHeight)(position, newHeight);
                                    dragger.position = position;
                                }

                                positions[dragger.index] = position;

                                //============高度调整拖拽点处理=============
                                if (that.heightDraggers && that.heightDraggers.length > 0) {
                                    var extrudedHeight = that.getGraphic().extrudedHeight.getValue(time);
                                    that.heightDraggers[dragger.index].position = (0, _point.setPositionsHeight)(position, extrudedHeight);
                                }

                                //============整体平移移动点处理============= 
                                positionMove = (0, _point.centerOfMass)(positions);
                                if (that.getGraphic().height != undefined) {
                                    var newHeight = that.getGraphic().height.getValue(time);
                                    positionMove = (0, _point.setPositionsHeight)(positionMove, newHeight);
                                }
                                if (clampToGround) {
                                    //贴地时求贴模型和贴地的高度
                                    positionMove = (0, _point.setPositionSurfaceHeight)(that.viewer, positionMove);
                                }
                                draggerMove.position = positionMove;
                            }
                        });
                        dragger.index = i;
                        this.draggers.push(dragger);
                    }

                    //整体平移移动点 
                    var positionMove = (0, _point.centerOfMass)(positions);
                    if (this.getGraphic().height != undefined) {
                        var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                        positionMove = (0, _point.setPositionsHeight)(positionMove, newHeight);
                    }
                    if (clampToGround) {
                        //贴地时求贴模型和贴地的高度
                        positionMove = (0, _point.setPositionSurfaceHeight)(this.viewer, positionMove);
                    }
                    var draggerMove = draggerCtl.createDragger(this.dataSource, {
                        position: positionMove,
                        type: draggerCtl.PointType.MoveAll,
                        tooltip: _Tooltip.message.dragger.moveAll,
                        onDrag: function onDrag(dragger, position) {
                            // dragger.position = position;

                            //记录差值 
                            var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                            positionMove = position;

                            positions.forEach(function (pos, index, arr) {
                                var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                                positions[index] = newPos;
                            });

                            //=====全部更新========== 
                            that.updateDraggers();
                        }
                    });
                    this.draggers.push(draggerMove);

                    //创建高程拖拽点
                    if (this.getGraphic().extrudedHeight) this.bindHeightDraggers();
                }

            });

            /***/
}),
/* 63 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditCircle = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(25);

            var _point = __webpack_require__(2);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditCircle = exports.EditCircle = _Edit.EditPolygon.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.ellipse;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;
                    this.finish();
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_draw = this._positions_draw;
                },
                isClampToGround: function isClampToGround() {
                    return this.entity.attribute.style.clampToGround;
                },
                getPosition: function getPosition() {
                    //加上高度
                    if (this.getGraphic().height != undefined) {
                        var newHeight = this.getGraphic().height.getValue(this.viewer.clock.currentTime);
                        for (var i = 0, len = this._positions_draw.length; i < len; i++) {
                            this._positions_draw[i] = (0, _point.setPositionsHeight)(this._positions_draw[i], newHeight);
                        }
                    }
                    return this._positions_draw;
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var clampToGround = this.isClampToGround();
                    var positions = this.getPosition();

                    var style = this.entity.attribute.style;

                    //中心点
                    var position = positions[0];
                    if (clampToGround) {
                        //贴地时求贴模型和贴地的高度
                        position = (0, _point.setPositionSurfaceHeight)(this.viewer, position);
                        positions[0] = position;
                    }

                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position,
                        onDrag: function onDrag(dragger, position) {
                            //记录差值
                            var diff = Cesium.Cartesian3.subtract(position, positions[dragger.index], new Cesium.Cartesian3());

                            positions[dragger.index] = position;

                            //============高度处理=============
                            if (!style.clampToGround) {
                                var height = that.formatNum(Cesium.Cartographic.fromCartesian(position).height, 2);
                                that.getGraphic().height = height;
                                style.height = height;
                            }

                            var time = that.viewer.clock.currentTime;

                            //============半径同步处理=============
                            var newPos = Cesium.Cartesian3.add(dragger.majorDragger.position.getValue(time), diff, new Cesium.Cartesian3());
                            dragger.majorDragger.position = newPos;

                            if (dragger.minorDragger) {
                                var newPos = Cesium.Cartesian3.add(dragger.minorDragger.position.getValue(time), diff, new Cesium.Cartesian3());
                                dragger.minorDragger.position = newPos;
                            }

                            //============高度调整拖拽点处理=============
                            if (that.entity.attribute.style.extrudedHeight != undefined) that.updateDraggers();
                        }
                    });
                    dragger.index = 0;
                    this.draggers.push(dragger);

                    var time = this.viewer.clock.currentTime;

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: this.getGraphic().semiMajorAxis.getValue(time), //长半轴
                        semiMinorAxis: this.getGraphic().semiMinorAxis.getValue(time), //短半轴
                        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                    });

                    //长半轴上的坐标点
                    var majorPos = outerPositions[1];
                    if (clampToGround) {
                        //贴地时求贴模型和贴地的高度
                        majorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, majorPos);
                    }
                    positions[1] = majorPos;
                    var majorDragger = draggerCtl.createDragger(this.dataSource, {
                        position: majorPos,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius,
                        //clampToGround: clampToGround,
                        onDrag: function onDrag(dragger, position) {
                            if (that.getGraphic().height != undefined) {
                                var newHeight = that.getGraphic().height.getValue(time);
                                position = (0, _point.setPositionsHeight)(position, newHeight);
                                dragger.position = position;
                            }
                            positions[dragger.index] = position;

                            var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                            that.getGraphic().semiMajorAxis = radius;

                            if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
                                //椭圆
                                style.semiMajorAxis = radius;
                            } else {
                                //圆
                                that.getGraphic().semiMinorAxis = radius;
                                style.radius = radius;
                            }

                            // if (that.entity.attribute.style.extrudedHeight != undefined)
                            that.updateDraggers();
                        }
                    });
                    majorDragger.index = 1;
                    dragger.majorDragger = majorDragger;
                    this.draggers.push(majorDragger);

                    //短半轴上的坐标点
                    if (this._maxPointNum == 3) {
                        //椭圆
                        //短半轴上的坐标点 
                        var minorPos = outerPositions[0];
                        if (clampToGround) {
                            //贴地时求贴模型和贴地的高度
                            minorPos = (0, _point.setPositionSurfaceHeight)(this.viewer, minorPos);
                        }
                        positions[2] = minorPos;
                        var minorDragger = draggerCtl.createDragger(this.dataSource, {
                            position: minorPos,
                            type: draggerCtl.PointType.EditAttr,
                            tooltip: _Tooltip.message.dragger.editRadius,
                            //clampToGround: clampToGround,
                            onDrag: function onDrag(dragger, position) {
                                if (that.getGraphic().height != undefined) {
                                    var newHeight = that.getGraphic().height.getValue(time);
                                    position = (0, _point.setPositionsHeight)(position, newHeight);
                                    dragger.position = position;
                                }
                                positions[dragger.index] = position;

                                var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                                that.getGraphic().semiMinorAxis = radius;

                                if (that._maxPointNum == 3 || !Cesium.defined(style.radius)) {
                                    //椭圆
                                    style.semiMinorAxis = radius;
                                } else {
                                    //圆
                                    that.getGraphic().semiMajorAxis = radius;
                                    style.radius = radius;
                                }

                                // if (that.entity.attribute.style.extrudedHeight != undefined)
                                that.updateDraggers();
                            }
                        });
                        minorDragger.index = 2;
                        dragger.minorDragger = minorDragger;
                        this.draggers.push(minorDragger);
                    }

                    //创建高度拖拽点
                    if (this.getGraphic().extrudedHeight) {
                        var _pos = this._maxPointNum == 3 ? [positions[1], positions[2]] : [positions[1]];
                        this.bindHeightDraggers(_pos);
                    }
                }

            });

            /***/
}),
/* 64 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditEllipsoid = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _point = __webpack_require__(2);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditEllipsoid = exports.EditEllipsoid = _Edit.EditBase.extend({
                //图形编辑结束后调用
                finish: function finish() { },
                updateRadii: function updateRadii(style) {
                    var radii = new Cesium.Cartesian3(Number(style.extentRadii), Number(style.widthRadii), Number(style.heightRadii));
                    this.entity.ellipsoid.radii.setValue(radii);
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var style = this.entity.attribute.style;

                    //位置中心点
                    var position = this.entity._positions_draw[0];
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position,
                        onDrag: function onDrag(dragger, position) {
                            that.entity._positions_draw[0] = position;

                            that.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //顶部的 高半径 编辑点
                    var position = this.entity.position.getValue(this.viewer.clock.currentTime);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: (0, _point.addPositionsHeight)(position, style.heightRadii),
                        type: draggerCtl.PointType.MoveHeight,
                        tooltip: _Tooltip.message.dragger.editRadius,
                        onDrag: function onDrag(dragger, position) {
                            var positionZXD = that.entity._positions_draw[0];
                            var length = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.heightRadii = length; //高半径

                            that.updateRadii(style);
                            that.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: Number(style.extentRadii),
                        semiMinorAxis: Number(style.widthRadii),
                        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                    });

                    //长半轴上的坐标点
                    var majorPos = outerPositions[0];
                    var majorDragger = draggerCtl.createDragger(this.dataSource, {
                        position: majorPos,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius,
                        onDrag: function onDrag(dragger, position) {
                            var positionZXD = that.entity._positions_draw[0];
                            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;

                            var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.widthRadii = radius; //长半轴

                            that.updateRadii(style);
                            that.updateDraggers();
                        }
                    });
                    dragger.majorDragger = majorDragger;
                    this.draggers.push(majorDragger);

                    //短半轴上的坐标点  
                    var minorPos = outerPositions[1];
                    var minorDragger = draggerCtl.createDragger(this.dataSource, {
                        position: minorPos,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius,
                        onDrag: function onDrag(dragger, position) {
                            var positionZXD = that.entity._positions_draw[0];
                            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;

                            var radius = that.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.extentRadii = radius; //短半轴

                            that.updateRadii(style);
                            that.updateDraggers();
                        }
                    });
                    dragger.minorDragger = minorDragger;
                    this.draggers.push(minorDragger);
                }

            });

            /***/
}),
/* 65 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditWall = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(22);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditWall = exports.EditWall = _Edit.EditPolyline.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.wall;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    var that = this;

                    var time = this.viewer.clock.currentTime;

                    this._positions_draw = this.entity._positions_draw || this.getGraphic().positions.getValue(time);
                    this._minimumHeights = this.entity._minimumHeights || this.getGraphic().minimumHeights.getValue(time);
                    this._maximumHeights = this.entity._maximumHeights || this.getGraphic().maximumHeights.getValue(time);
                },
                _maximumHeights: null,
                _minimumHeights: null,
                //坐标位置相关  
                updateAttrForEditing: function updateAttrForEditing() {
                    var style = this.entity.attribute.style;
                    var position = this.getPosition();
                    var len = position.length;

                    this._maximumHeights = new Array(len);
                    this._minimumHeights = new Array(len);

                    for (var i = 0; i < len; i++) {
                        var height = Cesium.Cartographic.fromCartesian(position[i]).height;
                        this._minimumHeights[i] = height;
                        this._maximumHeights[i] = height + Number(style.extrudedHeight);
                    }

                    //同步更新
                    this.entity._maximumHeights = this._maximumHeights;
                    this.entity._minimumHeights = this._minimumHeights;
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_draw = this._positions_draw;
                    this.entity._maximumHeights = this._maximumHeights;
                    this.entity._minimumHeights = this._minimumHeights;
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var clampToGround = this.isClampToGround();

                    var positions = this.getPosition();
                    var style = this.entity.attribute.style;
                    var hasMidPoint = positions.length < this._maxPointNum; //是否有新增点

                    for (var i = 0, len = positions.length; i < len; i++) {
                        var loc = positions[i];

                        //各顶点
                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: loc,
                            clampToGround: clampToGround,
                            onDrag: function onDrag(dragger, position) {
                                positions[dragger.index] = position;

                                //============高度调整拖拽点处理=============
                                if (that.heightDraggers && that.heightDraggers.length > 0) {
                                    that.heightDraggers[dragger.index].position = (0, _point.addPositionsHeight)(position, style.extrudedHeight);
                                }

                                //============新增点拖拽点处理=============
                                if (hasMidPoint) {
                                    if (dragger.index > 0) {
                                        //与前一个点之间的中点 
                                        that.draggers[dragger.index * 2 - 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index - 1], new Cesium.Cartesian3());
                                    }
                                    if (dragger.index < positions.length - 1) {
                                        //与后一个点之间的中点 
                                        that.draggers[dragger.index * 2 + 1].position = Cesium.Cartesian3.midpoint(position, positions[dragger.index + 1], new Cesium.Cartesian3());
                                    }
                                }

                                //============整体平移移动点处理============= 
                                positionMove = (0, _point.centerOfMass)(positions);
                                draggerMove.position = positionMove;
                            }
                        });
                        dragger.index = i;
                        this.draggers.push(dragger);

                        //中间点，拖动后新增点
                        if (hasMidPoint) {
                            var nextIndex = i + 1;
                            if (nextIndex < len) {
                                var midpoint = Cesium.Cartesian3.midpoint(loc, positions[nextIndex], new Cesium.Cartesian3());
                                var draggerMid = draggerCtl.createDragger(this.dataSource, {
                                    position: midpoint,
                                    type: draggerCtl.PointType.AddMidPoint,
                                    tooltip: _Tooltip.message.dragger.addMidPoint,
                                    clampToGround: clampToGround,
                                    onDragStart: function onDragStart(dragger, position) {
                                        positions.splice(dragger.index, 0, position); //插入点 
                                        that.updateAttrForEditing();
                                    },
                                    onDrag: function onDrag(dragger, position) {
                                        positions[dragger.index] = position;
                                    },
                                    onDragEnd: function onDragEnd(dragger, position) {
                                        that.updateDraggers();
                                    }
                                });
                                draggerMid.index = nextIndex;
                                this.draggers.push(draggerMid);
                            }
                        }
                    }

                    //整体平移移动点 
                    var positionMove = (0, _point.centerOfMass)(positions);
                    var draggerMove = draggerCtl.createDragger(this.dataSource, {
                        position: positionMove,
                        type: draggerCtl.PointType.MoveAll,
                        tooltip: _Tooltip.message.dragger.moveAll,
                        clampToGround: clampToGround,
                        onDrag: function onDrag(dragger, position) {
                            // dragger.position = position;

                            //记录差值 
                            var diff = Cesium.Cartesian3.subtract(position, positionMove, new Cesium.Cartesian3());
                            positionMove = position;

                            positions.forEach(function (pos, index, arr) {
                                var newPos = Cesium.Cartesian3.add(pos, diff, new Cesium.Cartesian3());
                                positions[index] = newPos;
                            });

                            //=====全部更新========== 
                            that.updateDraggers();
                        }
                    });
                    this.draggers.push(draggerMove);

                    //创建高程拖拽点
                    this.bindHeightDraggers();
                },
                //高度调整拖拽点
                heightDraggers: null,
                bindHeightDraggers: function bindHeightDraggers() {
                    var that = this;

                    this.heightDraggers = [];

                    var positions = this.getPosition();
                    var style = this.entity.attribute.style;
                    var extrudedHeight = Number(style.extrudedHeight);

                    for (var i = 0, len = positions.length; i < len; i++) {
                        var loc = (0, _point.addPositionsHeight)(positions[i], extrudedHeight);

                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: loc,
                            type: draggerCtl.PointType.MoveHeight,
                            tooltip: _Tooltip.message.dragger.moveHeight,
                            onDrag: function onDrag(dragger, position) {
                                var thisHeight = Cesium.Cartographic.fromCartesian(position).height;
                                style.extrudedHeight = that.formatNum(thisHeight - that._minimumHeights[dragger.index], 2);

                                for (var i = 0; i < positions.length; i++) {
                                    if (i == dragger.index) continue;
                                    that.heightDraggers[i].position = (0, _point.addPositionsHeight)(positions[i], style.extrudedHeight);
                                }
                                that.updateAttrForEditing();
                            }
                        });
                        dragger.index = i;

                        this.draggers.push(dragger);
                        this.heightDraggers.push(dragger);
                    }
                }

            });

            /***/
}),
/* 66 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPlane = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _point = __webpack_require__(2);

            var _matrix = __webpack_require__(17);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPlane = exports.EditPlane = _Edit.EditBase.extend({
                //图形编辑结束后调用
                finish: function finish() { },
                updatePlane: function updatePlane(style) {
                    var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                    var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                    var dimensions = new Cesium.Cartesian2(dimensionsX, dimensionsY);
                    this.entity.plane.dimensions.setValue(dimensions);
                },
                bindDraggers: function bindDraggers() {
                    var _this = this;

                    var style = this.entity.attribute.style;

                    //位置中心点
                    var positionZXD = this.entity._positions_draw;
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: positionZXD,
                        onDrag: function onDrag(dragger, position) {
                            _this.entity._positions_draw = position;
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //平面的x长度调整
                    var offest = { x: 0, y: 0, z: 0 };
                    switch (style.plane_normal) {
                        case "x":
                            offest.y = style.dimensionsX / 2;
                            break;
                        default:
                            offest.x = style.dimensionsX / 2;
                            break;
                    }
                    var position1 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position1,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '长度(X方向)'),
                        onDrag: function onDrag(dragger, position) {
                            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;

                            var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.dimensionsX = radius * 2;

                            _this.updatePlane(style);
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //平面的y宽度调整
                    if (style.plane_normal == "z") {
                        var offest = { x: 0, y: style.dimensionsY / 2, z: 0 };
                        var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);

                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: position2,
                            type: draggerCtl.PointType.EditAttr,
                            tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                            onDrag: function onDrag(dragger, position) {
                                var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                                position = (0, _point.setPositionsHeight)(position, newHeight);
                                dragger.position = position;

                                var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                                style.dimensionsY = radius * 2;

                                _this.updatePlane(style);
                                _this.updateDraggers();
                            }
                        });
                        this.draggers.push(dragger);
                    } else {
                        var offest = { x: 0, y: 0, z: 0 };
                        switch (style.plane_normal) {
                            case "x":
                            case "y":
                                offest.z = style.dimensionsY / 2;
                                break;
                            default:
                                offest.y = style.dimensionsY / 2;
                                break;
                        }
                        //顶部的 高半径 编辑点
                        var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);

                        var dragger = draggerCtl.createDragger(this.dataSource, {
                            position: position2,
                            type: draggerCtl.PointType.MoveHeight,
                            tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                            onDrag: function onDrag(dragger, position) {
                                var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                                style.dimensionsY = radius * 2;

                                _this.updatePlane(style);
                                _this.updateDraggers();
                            }
                        });
                        this.draggers.push(dragger);
                    }
                }

            });

            /***/
}),
/* 67 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditBox = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _point = __webpack_require__(2);

            var _matrix = __webpack_require__(17);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditBox = exports.EditBox = _Edit.EditBase.extend({
                //图形编辑结束后调用
                finish: function finish() { },
                updateBox: function updateBox(style) {
                    var dimensionsX = Cesium.defaultValue(style.dimensionsX, 100.0);
                    var dimensionsY = Cesium.defaultValue(style.dimensionsY, 100.0);
                    var dimensionsZ = Cesium.defaultValue(style.dimensionsZ, 100.0);
                    var dimensions = new Cesium.Cartesian3(dimensionsX, dimensionsY, dimensionsZ);

                    this.entity.box.dimensions.setValue(dimensions);
                },
                bindDraggers: function bindDraggers() {
                    var _this = this;

                    var that = this;

                    var style = this.entity.attribute.style;

                    //位置中心点
                    var positionZXD = this.entity._positions_draw;
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: positionZXD,
                        onDrag: function onDrag(dragger, position) {
                            _this.entity._positions_draw = position;
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //x长度调整
                    var offest = { x: style.dimensionsX / 2, y: 0, z: 0 };
                    var position1 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position1,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '长度(X方向)'),
                        onDrag: function onDrag(dragger, position) {
                            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;

                            var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.dimensionsX = radius * 2;

                            _this.updateBox(style);
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //y宽度调整
                    var offest = { x: 0, y: style.dimensionsY / 2, z: 0 };
                    var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position2,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '宽度(Y方向)'),
                        onDrag: function onDrag(dragger, position) {
                            var newHeight = Cesium.Cartographic.fromCartesian(positionZXD).height;
                            position = (0, _point.setPositionsHeight)(position, newHeight);
                            dragger.position = position;

                            var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.dimensionsY = radius * 2;

                            _this.updateBox(style);
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);

                    //z高度调整
                    var offest = { x: 0, y: 0, z: style.dimensionsZ / 2 };
                    var position2 = (0, _matrix.getPositionTranslation)(positionZXD, offest);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position2,
                        type: draggerCtl.PointType.MoveHeight,
                        tooltip: _Tooltip.message.dragger.editRadius.replace('半径', '高度(Z方向)'),
                        onDrag: function onDrag(dragger, position) {
                            var radius = _this.formatNum(Cesium.Cartesian3.distance(positionZXD, position), 2);
                            style.dimensionsZ = radius * 2;

                            _this.updateBox(style);
                            _this.updateDraggers();
                        }
                    });
                    this.draggers.push(dragger);
                }

            });

            /***/
}),
/* 68 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditPModel = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(21);

            var _Attr = __webpack_require__(40);

            var circleAttr = _interopRequireWildcard(_Attr);

            var _point = __webpack_require__(2);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditPModel = exports.EditPModel = _Edit.EditBase.extend({
                //外部更新位置
                setPositions: function setPositions(position) {
                    if (util.isArray(position) && position.length == 1) {
                        position = position[0];
                    }
                    this.entity.position = position;
                    this.entity.modelMatrix = this.getModelMatrix();
                },
                getModelMatrix: function getModelMatrix(position) {
                    var cfg = this.entity.attribute.style;

                    var hpRoll = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(cfg.heading || 0), Cesium.Math.toRadians(cfg.pitch || 0), Cesium.Math.toRadians(cfg.roll || 0));
                    var fixedFrameTransform = Cesium.Transforms.eastNorthUpToFixedFrame;

                    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position || this.entity.position, hpRoll, this.viewer.scene.globe.ellipsoid, fixedFrameTransform);

                    // Cesium.Matrix4.multiplyByUniformScale(modelMatrix, Cesium.defaultValue(cfg.scale, 1), modelMatrix);
                    return modelMatrix;
                },
                bindDraggers: function bindDraggers() {
                    if (!this.entity.ready) {
                        var that = this;
                        this.entity.readyPromise.then(function (model) {
                            that.bindDraggers();
                        });
                        return;
                    }

                    var that = this;

                    this.entity.draw_tooltip = _Tooltip.message.dragger.def;

                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        dragger: this.entity,
                        onDrag: function onDrag(dragger, newPosition) {
                            that.entity.position = newPosition;
                            that.entity.modelMatrix = that.getModelMatrix(newPosition);

                            that.updateDraggers();
                        }
                    });

                    var style = this.entity.attribute.style;

                    var position = this.entity.position;
                    var height = Cesium.Cartographic.fromCartesian(position).height;
                    var radius = this.entity.boundingSphere.radius;

                    //辅助显示：创建角度调整底部圆
                    this.entityAngle = this.dataSource.entities.add({
                        name: '角度调整底部圆',
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.entity.position;
                        }, false),
                        ellipse: circleAttr.style2Entity({
                            "fill": false,
                            "outline": true,
                            "outlineColor": "#ffff00",
                            "outlineOpacity": 0.8,
                            "radius": radius,
                            "height": height
                        })
                    });

                    //创建角度调整 拖拽点
                    var majorPos = this.getHeadingPosition();
                    var majorDragger = draggerCtl.createDragger(this.dataSource, {
                        position: majorPos,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editHeading,
                        onDrag: function onDrag(dragger, position) {
                            var heading = that.getHeading(that.entity.position, position);
                            style.heading = that.formatNum(heading, 1);
                            //console.log(heading);

                            that.entity.modelMatrix = that.getModelMatrix();
                            dragger.position = that.getHeadingPosition();
                        }
                    });
                    this.draggers.push(majorDragger);

                    //辅助显示：外接包围盒子
                    //this.entityBox = this.dataSource.entities.add({
                    //    name: '外接包围盒子',
                    //    position: new Cesium.CallbackProperty(time => {
                    //        return that.entity.position;
                    //    }, false),
                    //    box: {
                    //        dimensions: new Cesium.Cartesian3(radius, radius, radius),
                    //        fill: false,
                    //        outline: true,
                    //        outlineColor: Cesium.Color.YELLOW
                    //    }
                    //});

                    //缩放控制点 
                    var position_scale = (0, _point.addPositionsHeight)(position, radius);
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position_scale,
                        type: draggerCtl.PointType.MoveHeight,
                        tooltip: _Tooltip.message.dragger.editScale,
                        onDrag: function onDrag(dragger, positionNew) {
                            var radiusNew = Cesium.Cartesian3.distance(positionNew, position);

                            var radiusOld = dragger.radius / style.scale;
                            var scaleNew = radiusNew / radiusOld;

                            dragger.radius = radiusNew;
                            style.scale = that.formatNum(scaleNew, 2);

                            that.entity.scale = style.scale;
                            // that.entity.modelMatrix = that.getModelMatrix();
                            that.updateDraggers();
                        }
                    });
                    dragger.radius = radius;
                    this.draggers.push(dragger);

                    //this.entityBox = this.dataSource.entities.add({
                    //    name: '缩放控制点连接线',
                    //    polyline: {
                    //        positions: [
                    //            position,
                    //            position_scale
                    //        ],
                    //        width: 1,
                    //        material: Cesium.Color.YELLOW
                    //    }
                    //});

                },
                destroyDraggers: function destroyDraggers() {
                    _Edit.EditBase.prototype.destroyDraggers.call(this);

                    if (this.entityAngle) {
                        this.dataSource.entities.remove(this.entityAngle);
                        delete this.entityAngle;
                    }
                    if (this.entityBox) {
                        this.dataSource.entities.remove(this.entityBox);
                        delete this.entityBox;
                    }
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity.draw_tooltip = null;
                },
                getHeadingPosition: function getHeadingPosition() {
                    //创建角度调整底部圆  
                    var position = this.entity.position;
                    var radius = this.entity.boundingSphere.radius;
                    var angle = -Number(this.entity.attribute.style.heading || 0);

                    var rotpos = new Cesium.Cartesian3(radius, 0.0, 0.0);

                    var mat = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                    var rotationX = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(angle)));
                    Cesium.Matrix4.multiply(mat, rotationX, mat);

                    mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());
                    rotpos = Cesium.Matrix3.multiplyByVector(mat, rotpos, rotpos);
                    rotpos = Cesium.Cartesian3.add(position, rotpos, rotpos);
                    return rotpos;
                },
                //获取点相对于中心点的地面角度
                getHeading: function getHeading(positionCenter, positionNew) {

                    //获取该位置的默认矩阵 
                    var mat = Cesium.Transforms.eastNorthUpToFixedFrame(positionCenter);
                    mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());

                    var xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
                    var yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
                    var zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());

                    //计算该位置 和  positionCenter 的 角度值
                    var dir = Cesium.Cartesian3.subtract(positionNew, positionCenter, new Cesium.Cartesian3());
                    //z crosss (dirx cross z) 得到在 xy平面的向量
                    dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
                    dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
                    dir = Cesium.Cartesian3.normalize(dir, dir);

                    var heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

                    var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
                    if (ay > Math.PI * 0.5) {
                        heading = 2 * Math.PI - heading;
                    }

                    return -Cesium.Math.toDegrees(heading);
                }

            });

            /***/
}),
/* 69 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.KeyboardRoam = exports.KeyboardType = exports.maxPitch = exports.minPitch = exports.rotateStep = exports.dirStep = exports.speedRatio = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var speedRatio = exports.speedRatio = 50; //平移步长，值越大步长越小。
            var dirStep = exports.dirStep = 5; //相机原地旋转步长，值越大步长越小。
            var rotateStep = exports.rotateStep = 1.0; //相机围绕目标点旋转速率，0.3 - 2.0
            var minPitch = exports.minPitch = 0.1; //最小仰角  0 - 1
            var maxPitch = exports.maxPitch = 0.95; //最大仰角  0 - 1


            var KeyboardType = exports.KeyboardType = {
                ENLARGE: 0,
                NARROW: 1,
                LEFT_ROTATE: 2,
                RIGHT_ROTATE: 3,
                TOP_ROTATE: 4,
                BOTTOM_ROTATE: 5

                //快捷键，键盘漫游
            };
            var KeyboardRoam = exports.KeyboardRoam = function () {
                //========== 构造方法 ========== 
                function KeyboardRoam(viewer, options) {
                    _classCallCheck(this, KeyboardRoam);

                    this.viewer = viewer;

                    this.flags = {
                        moveForward: false,
                        moveBackward: false,
                        moveUp: false,
                        moveDown: false,
                        moveLeft: false,
                        moveRight: false
                    };

                    var canvas = viewer.scene.canvas;
                    canvas.setAttribute('tabindex', '0'); // needed to put focus on the canvas
                    canvas.onclick = function () {
                        canvas.focus();
                    };

                    var that = this;
                    document.addEventListener('keydown', function (e) {
                        if (!that._enable) return;

                        var flagName = that.getFlagForKeyCode(e.keyCode);
                        if (typeof flagName !== 'undefined') {
                            that.flags[flagName] = true;
                        }
                    }, false);
                    document.addEventListener('keyup', function (e) {
                        if (!that._enable) return;

                        var flagName = that.getFlagForKeyCode(e.keyCode);
                        if (typeof flagName !== 'undefined') {
                            that.flags[flagName] = false;
                        }
                    }, false);

                    //绑定的事件
                    this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                    this.handler.setInputAction(function (delta) {
                        //在漫游中滚轮滚动可以加速减速
                        if (!that._enable) return;

                        // if (delta > 0) {
                        //     exports.speedRatio = speedRatio = speedRatio * 0.9;
                        //     exports.rotateStep = rotateStep = rotateStep * 1.1;
                        //     exports.dirStep = dirStep = dirStep * 0.9;
                        // } else {
                        //     exports.speedRatio = speedRatio = speedRatio * 1.1;
                        //     exports.rotateStep = rotateStep = rotateStep * 0.9;
                        //     exports.dirStep = dirStep = dirStep * 1.1;
                        // }
                    }, Cesium.ScreenSpaceEventType.WHEEL);

                    this._enable = false;
                }

                //========== 对外属性 ==========  

                //是否禁用


                _createClass(KeyboardRoam, [{
                    key: 'bind',


                    //========== 方法 ==========  

                    value: function bind(opts) {
                        if (this._enable) return;
                        this._enable = true;

                        if (Cesium.defined(opts)) {
                            //支持绑定方法内重新赋值参数 
                            exports.speedRatio = speedRatio = opts.speedRatio || speedRatio;
                            exports.dirStep = dirStep = opts.dirStep || dirStep;
                            exports.rotateStep = rotateStep = opts.rotateStep || rotateStep;
                            exports.minPitch = minPitch = opts.minPitch || minPitch;
                            exports.maxPitch = maxPitch = opts.maxPitch || maxPitch;
                        }

                        this.viewer.clock.onTick.addEventListener(this.cameraFunc, this);
                    }
                }, {
                    key: 'unbind',
                    value: function unbind() {
                        if (!this._enable) return;
                        this._enable = false;

                        this.viewer.clock.onTick.removeEventListener(this.cameraFunc, this);
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.unbind();
                        this.handler.destroy();
                    }

                    //=================相关事件回调方法======================   

                }, {
                    key: 'getFlagForKeyCode',
                    value: function getFlagForKeyCode(keyCode) {
                        switch (keyCode) {
                            //平移
                            case 'W'.charCodeAt(0):
                                //向前平移镜头，不改变相机朝向
                                return 'moveForward';
                            case 'S'.charCodeAt(0):
                                //向后平移镜头，不改变相机朝向
                                return 'moveBackward';
                            case 'D'.charCodeAt(0):
                                //向右平移镜头，不改变相机朝向
                                return 'moveRight';
                            case 'A'.charCodeAt(0):
                                //向左平移镜头，不改变相机朝向
                                return 'moveLeft';
                            case 'Q'.charCodeAt(0):
                                //向上平移镜头，不改变相机朝向
                                return 'moveUp';
                            case 'E'.charCodeAt(0):
                                //向下平移镜头，不改变相机朝向
                                return 'moveDown';

                            //相对于相机本身
                            case 38:
                                //方向键上键
                                this.rotateCamera(KeyboardType.TOP_ROTATE); //相机原地上旋转
                                break;
                            case 37:
                                //方向键左键
                                this.rotateCamera(KeyboardType.LEFT_ROTATE); //相机原地左旋转
                                break;
                            case 39:
                                //方向键右键
                                this.rotateCamera(KeyboardType.RIGHT_ROTATE); //相机原地右旋转
                                break;
                            case 40:
                                //方向键下键
                                this.rotateCamera(KeyboardType.BOTTOM_ROTATE); //相机原地下旋转
                                break;

                            //相对于屏幕中心点
                            case 'I'.charCodeAt(0):
                            case 104:
                                //数字键盘8
                                this.moveCamera(KeyboardType.ENLARGE); //向屏幕中心靠近
                                break;
                            case 'K'.charCodeAt(0):
                            case 101:
                                //数字键盘5
                                this.moveCamera(KeyboardType.NARROW); //向屏幕中心远离
                                break;
                            case 'J'.charCodeAt(0):
                            case 100:
                                //数字键盘4
                                this.moveCamera(KeyboardType.LEFT_ROTATE); //围绕屏幕中心左旋转
                                break;
                            case 'L'.charCodeAt(0):
                            case 102:
                                //数字键盘6
                                this.moveCamera(KeyboardType.RIGHT_ROTATE); //围绕屏幕中心右旋转
                                break;
                            case 'U'.charCodeAt(0):
                            case 103:
                                //数字键盘7
                                this.moveCamera(KeyboardType.TOP_ROTATE); //围绕屏幕中心上旋转
                                break;
                            case 'O'.charCodeAt(0):
                            case 105:
                                //数字键盘9
                                this.moveCamera(KeyboardType.BOTTOM_ROTATE); //围绕屏幕中心下旋转
                                break;

                            default:
                                break;
                        }
                        return undefined;
                    }

                    //=================平移======================

                }, {
                    key: 'startMoveForward',
                    value: function startMoveForward() {
                        this.flags['moveForward'] = true;
                    }
                }, {
                    key: 'stopMoveForward',
                    value: function stopMoveForward() {
                        this.flags['moveForward'] = false;
                    }
                }, {
                    key: 'startMoveBackward',
                    value: function startMoveBackward() {
                        this.flags['moveBackward'] = true;
                    }
                }, {
                    key: 'stopMoveBackward',
                    value: function stopMoveBackward() {
                        this.flags['moveBackward'] = false;
                    }
                }, {
                    key: 'startMoveRight',
                    value: function startMoveRight() {
                        this.flags['moveRight'] = true;
                    }
                }, {
                    key: 'stopMoveRight',
                    value: function stopMoveRight() {
                        this.flags['moveRight'] = false;
                    }
                }, {
                    key: 'startMoveLeft',
                    value: function startMoveLeft() {
                        this.flags['moveLeft'] = true;
                    }
                }, {
                    key: 'stopMoveLeft',
                    value: function stopMoveLeft() {
                        this.flags['moveLeft'] = false;
                    }
                }, {
                    key: 'moveForward',
                    value: function moveForward(distance) {
                        //和模型的相机移动不太一样  不是沿着相机目标方向，而是默认向上方向 和 向右 方向的插值方向
                        var camera = this.viewer.camera;
                        var direction = camera.direction;
                        //获得此位置默认的向上方向  
                        var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

                        // right = direction * up  
                        var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());

                        direction = Cesium.Cartesian3.cross(up, right, new Cesium.Cartesian3());

                        direction = Cesium.Cartesian3.normalize(direction, direction);
                        direction = Cesium.Cartesian3.multiplyByScalar(direction, distance, direction);

                        camera.position = Cesium.Cartesian3.add(camera.position, direction, camera.position);
                    }
                }, {
                    key: 'cameraFunc',
                    value: function cameraFunc(clock) {
                        var camera = this.viewer.camera;

                        // Change movement speed based on the distance of the camera to the surface of the ellipsoid.
                        var cameraHeight = this.viewer.scene.globe.ellipsoid.cartesianToCartographic(camera.position).height;
                        var moveRate = cameraHeight / speedRatio;
                        
                        if (this.flags.moveForward) {
                            this.moveForward(moveRate);
                        }
                        if (this.flags.moveBackward) {
                            this.moveForward(-moveRate);
                        }
                        if (this.flags.moveUp) {
                            camera.moveUp(moveRate);
                        }
                        if (this.flags.moveDown) {
                            camera.moveDown(moveRate);
                        }
                        if (this.flags.moveLeft) {
                            camera.moveLeft(moveRate);
                        }
                        if (this.flags.moveRight) {
                            camera.moveRight(moveRate);
                        }
                    }
                }, {
                    key: 'resetCameraPos',


                    //=================相对于屏幕或相机====================== 
                    value: function resetCameraPos(newCamera) {
                        if (!newCamera) return;
                        this.viewer.scene.camera.position = newCamera.position;
                        this.viewer.scene.camera.direction = newCamera.direction;
                        this.viewer.scene.camera.right = newCamera.right;
                        this.viewer.scene.camera.up = newCamera.up;
                    }
                }, {
                    key: 'limitAngle',
                    value: function limitAngle(up, position, type) {
                        var dotNum = Cesium.Cartesian3.dot(up, Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3()));
                        if (type == 'up' && dotNum < minPitch) return false;
                        if (type == 'down' && dotNum > maxPitch) return false;
                        return true;
                    }
                }, {
                    key: 'computedNewPos',
                    value: function computedNewPos(camera, dir, rotate) {
                        // var step = rotateStep;
                        var oldpos = camera.position;
                        var winCenter = (0, _point.getCenter)(this.viewer);
                        if (!winCenter) return;
                        var center = Cesium.Cartesian3.fromDegrees(winCenter.x, winCenter.y, winCenter.z);
                        if (!center) return;
                        var oldDis = Cesium.Cartesian3.distance(center, oldpos);
                        var step = oldDis / 100;
                        step = rotate ? step * rotateStep : step;
                        var newCamera = {};
                        var ray = new Cesium.Ray(oldpos, dir);
                        newCamera.position = Cesium.Ray.getPoint(ray, step);

                        // var cheight = Cesium.Cartographic.fromCartesian(newCamera.position).height;
                        // if (cheight < 500)   return;

                        newCamera.direction = camera.direction;
                        newCamera.right = camera.right;
                        newCamera.up = camera.up;
                        if (rotate) {
                            var newDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(newCamera.position, center, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                            ray = new Cesium.Ray(center, newDir);
                            newCamera.position = Cesium.Ray.getPoint(ray, oldDis);
                            newCamera.direction = Cesium.Cartesian3.negate(newDir, new Cesium.Cartesian3());
                            // newCamera.up = camera.up;
                            newCamera.up = Cesium.Cartesian3.normalize(newCamera.position, new Cesium.Cartesian3());
                            newCamera.right = Cesium.Cartesian3.cross(newCamera.direction, newCamera.up, new Cesium.Cartesian3());
                        }
                        return newCamera;
                    }
                }, {
                    key: 'moveCamera',
                    value: function moveCamera(type) {
                        var camera = this.viewer.scene.camera;
                        var newCamera;
                        switch (type) {
                            case KeyboardType.ENLARGE:
                                newCamera = this.computedNewPos(camera, camera.direction);
                                break;
                            case KeyboardType.NARROW:
                                newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.direction, new Cesium.Cartesian3()));
                                break;
                            case KeyboardType.LEFT_ROTATE:
                                newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.right, new Cesium.Cartesian3()), true);
                                break;
                            case KeyboardType.RIGHT_ROTATE:
                                newCamera = this.computedNewPos(camera, camera.right, true);
                                break;
                            case KeyboardType.TOP_ROTATE:
                                var able = this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), 'up');
                                if (!able) return;
                                newCamera = this.computedNewPos(camera, Cesium.clone(camera.up), true);
                                break;
                            case KeyboardType.BOTTOM_ROTATE:
                                var able = this.limitAngle(Cesium.clone(camera.up), Cesium.clone(camera.position), 'down');
                                if (!able) return;
                                newCamera = this.computedNewPos(camera, Cesium.Cartesian3.negate(camera.up, new Cesium.Cartesian3()), true);
                                break;
                        }
                        if (!newCamera) return;
                        this.resetCameraPos(newCamera);
                    }
                }, {
                    key: 'rotateCamera',
                    value: function rotateCamera(type) {
                        var winPos = [0, 0];
                        var width = this.viewer.scene.canvas.clientWidth;
                        var height = this.viewer.scene.canvas.clientHeight;
                        var step = (width + height) / dirStep;
                        switch (type) {
                            case KeyboardType.LEFT_ROTATE:
                                winPos = [-step * width / height, 0];
                                break;
                            case KeyboardType.RIGHT_ROTATE:
                                winPos = [step * width / height, 0];
                                break;
                            case KeyboardType.TOP_ROTATE:
                                winPos = [0, step];
                                break;
                            case KeyboardType.BOTTOM_ROTATE:
                                winPos = [0, -step];
                                break;
                            default:
                                return;
                        }
                        var x = winPos[0] / width;
                        var y = winPos[1] / height; 
                        //这计算了，分别向右 和 向上移动的
                        var lookFactor = 0.01;
                        var camera = this.viewer.camera;
                        camera.lookRight(x * lookFactor);
                        camera.lookUp(y * lookFactor);

                        //获得direction 方向
                        var direction = camera.direction;
                        //获得此位置默认的向上方向  
                        var up = Cesium.Cartesian3.normalize(camera.position, new Cesium.Cartesian3());

                        // right = direction * up  
                        var right = Cesium.Cartesian3.cross(direction, up, new Cesium.Cartesian3());
                        // up = right * direction
                        up = Cesium.Cartesian3.cross(right, direction, new Cesium.Cartesian3());

                        camera.up = up;
                        camera.right = right;
                    }
                }, {
                    key: 'enable',
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        if (value) this.bind(); else this.unbind();
                    }
                }]);

                return KeyboardRoam;
            }();

            /***/
}),
/* 70 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CustomPlaneGeometry = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var CustomPlaneGeometry = exports.CustomPlaneGeometry = function () {
                function CustomPlaneGeometry(options) {
                    _classCallCheck(this, CustomPlaneGeometry);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    var vertexFormat = new Cesium.VertexFormat({
                        'st': true,
                        'position': true,
                        'bitangent': false,
                        'normal': false,
                        'color': false,
                        'tangent': false
                    });
                    this._pos_arr = Cesium.clone(options.pos_arr);
                    this._vertexFormat = vertexFormat;
                    var Rect = new Cesium.BoundingRectangle();
                    this._SERectangle = Cesium.BoundingRectangle.fromPoints(this._pos_arr, Rect);
                    this._workerName = 'createCustomPlaneGeometry';
                }

                /**
                 * Computes the geometric representation of a plane, including its vertices, and a bounding sphere.
                 *
                 * @param {CustomPlaneGeometry} CustomPlaneGeometry A description of the plane.
                 * @returns {Geometry|undefined} The computed vertices and indices.
                 */


                _createClass(CustomPlaneGeometry, [{
                    key: 'createGeometry',
                    value: function createGeometry(geometry) {
                        var vertexFormat = geometry._vertexFormat;
                        var SERectangle = geometry._SERectangle;
                        var pos_arr = geometry._pos_arr;
                        var attributes = new Cesium.GeometryAttributes();
                        var indices;
                        var positions;
                        var poslen = pos_arr.length;
                        if (Cesium.defined(vertexFormat.position)) {
                            // 4 corner points.  Duplicated 3 times each for each incident edge/face.
                            positions = new Float64Array(poslen * 3);

                            for (var i = 0; i < poslen; i++) {
                                positions[i % poslen * 3 + 0] = pos_arr[i].x;
                                positions[i % poslen * 3 + 1] = pos_arr[i].y;
                                positions[i % poslen * 3 + 2] = pos_arr[i].z;
                            }

                            attributes.position = new Cesium.GeometryAttribute({
                                componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                                componentsPerAttribute: 3,
                                values: positions
                            });

                            if (Cesium.defined(vertexFormat.st)) {
                                var texCoords = new Float32Array(poslen * 2);
                                var oX = SERectangle.x - SERectangle.width;
                                var oY = SERectangle.y - SERectangle.height;
                                var oX = SERectangle.x;
                                var oY = SERectangle.y;
                                for (var i = 0; i < poslen; i++) {
                                    texCoords[i * 2 + 0] = Math.abs((positions[i * 3 + 0] - oX) / SERectangle.width);
                                    texCoords[i * 2 + 1] = Math.abs((positions[i * 3 + 1] - oY) / SERectangle.height);
                                }
                                attributes.st = new Cesium.GeometryAttribute({
                                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                                    componentsPerAttribute: 2,
                                    values: texCoords
                                });
                            }

                            indices = new Uint16Array((poslen - 2) * 3);

                            for (var i = 1; i < poslen - 1; i++) {
                                indices[(i - 1) * 3 + 0] = 0;
                                indices[(i - 1) * 3 + 1] = i;
                                indices[(i - 1) * 3 + 2] = i + 1;
                            }
                        }

                        return new Cesium.Geometry({
                            attributes: attributes,
                            indices: indices,
                            primitiveType: Cesium.PrimitiveType.TRIANGLE_FAN,
                            boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, Math.sqrt(2.0))
                        });
                    }
                }]);

                return CustomPlaneGeometry;
            }();

            /***/
}),
/* 71 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.WellNoBottom = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var diffScratch = new Cesium.Cartesian3();

            var WellNoBottom = exports.WellNoBottom = function () {
                function WellNoBottom(options) {
                    _classCallCheck(this, WellNoBottom);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    var min = options.minimumArr;
                    var max = options.maximumArr;
                    Cesium.Check.defined('dingmian', max);
                    Cesium.Check.defined('dimianmian', min);

                    Cesium.Check.typeOf.number.greaterThanOrEquals('dingmian.length', max.length, 3);
                    Cesium.Check.typeOf.number.greaterThanOrEquals('dimian.length', min.length, 3);

                    var vertexFormat = new Cesium.VertexFormat({
                        'st': true,
                        'position': true,
                        'bitangent': false,
                        'normal': false,
                        'color': false,
                        'tangent': false
                    });

                    this._minimumArr = Cesium.clone(min);
                    this._maximumArr = Cesium.clone(max);
                    this._vertexFormat = vertexFormat;
                    this._workerName = 'createWellNoBottom';
                }

                _createClass(WellNoBottom, [{
                    key: 'createGeometry',
                    value: function createGeometry(WellNoBottom, that) {
                        var min = WellNoBottom._minimumArr;
                        var max = WellNoBottom._maximumArr;
                        var vertexFormat = WellNoBottom._vertexFormat;

                        var attributes = new Cesium.GeometryAttributes();
                        var indices;
                        var positions;
                        if (Cesium.defined(vertexFormat.position) && Cesium.defined(vertexFormat.st)) {
                            if (Cesium.defined(vertexFormat.position)) {
                                // 8 corner points.  Duplicated 3 times each for each incident edge/face.
                                positions = new Float64Array(max.length * 4 * 3);

                                for (var i = 0; i < max.length; i++) {
                                    if (i == max.length - 1) {
                                        positions[i * 12 + 0] = max[i].x;
                                        positions[i * 12 + 1] = max[i].y;
                                        positions[i * 12 + 2] = max[i].z;

                                        positions[i * 12 + 3] = min[i].x;
                                        positions[i * 12 + 4] = min[i].y;
                                        positions[i * 12 + 5] = min[i].z;

                                        positions[i * 12 + 9] = min[0].x;
                                        positions[i * 12 + 10] = min[0].y;
                                        positions[i * 12 + 11] = min[0].z;

                                        positions[i * 12 + 6] = max[0].x;
                                        positions[i * 12 + 7] = max[0].y;
                                        positions[i * 12 + 8] = max[0].z;

                                        // positions.push(max[i].x,max[i].y,max[i].z);
                                        // positions.push(min[i].x,min[i].y,min[i].z);
                                        // positions.push(min[0].x,min[0].y,min[0].z);
                                        // positions.push(max[0].x,max[0].y,max[0].z);
                                    } else {
                                        positions[i * 12 + 0] = max[i].x;
                                        positions[i * 12 + 1] = max[i].y;
                                        positions[i * 12 + 2] = max[i].z;

                                        positions[i * 12 + 3] = min[i].x;
                                        positions[i * 12 + 4] = min[i].y;
                                        positions[i * 12 + 5] = min[i].z;

                                        positions[i * 12 + 9] = min[i + 1].x;
                                        positions[i * 12 + 10] = min[i + 1].y;
                                        positions[i * 12 + 11] = min[i + 1].z;

                                        positions[i * 12 + 6] = max[i + 1].x;
                                        positions[i * 12 + 7] = max[i + 1].y;
                                        positions[i * 12 + 8] = max[i + 1].z;

                                        // positions.push(max[i].x,max[i].y,max[i].z);
                                        // positions.push(min[i].x,min[i].y,min[i].z);
                                        // positions.push(min[i+1].x,min[i+1].y,min[i+1].z);
                                        // positions.push(max[i+1].x,max[i+1].y,max[i+1].z);
                                    }
                                }

                                attributes.position = new Cesium.GeometryAttribute({
                                    componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                                    componentsPerAttribute: 3,
                                    values: positions
                                });
                            }

                            var top_heights = that.top_heights;
                            var maxHeight = that.maxHeight || 0;
                            var splitNum = that.splitNum;

                            if (Cesium.defined(vertexFormat.st)) {
                                var texCoords = new Float32Array(max.length * 4 * 2);
                                var maxLen = max.length;
                                for (var i = 0; i < max.length; i++) {
                                    var currX = i / maxLen;
                                    var currMaxHeight = top_heights && top_heights[i] || 0;
                                    var currY = (currMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);
                                    var nextIndex = i + 1;
                                    // if (i == max.length - 1) {
                                    //     nextIndex = 0;
                                    // }
                                    var nextMaxHeight = top_heights && top_heights[nextIndex] || 0;
                                    var nextX = nextIndex / maxLen;
                                    var nextY = (nextMaxHeight - that.targetHeight) / (maxHeight - that.targetHeight);

                                    texCoords[i * 8 + 0] = currX;
                                    texCoords[i * 8 + 1] = currY - 0.0;
                                    texCoords[i * 8 + 2] = currX;
                                    texCoords[i * 8 + 3] = currY - currY;
                                    texCoords[i * 8 + 4] = nextX;
                                    texCoords[i * 8 + 5] = nextY - 0.0;
                                    texCoords[i * 8 + 6] = nextX;
                                    texCoords[i * 8 + 7] = nextY - nextY;

                                    // texCoords[i*8 + 0]  = 0.0;
                                    // texCoords[i*8 + 1]  = 0.0;
                                    // texCoords[i*8 + 2]  = 0.0;
                                    // texCoords[i*8 + 3]  = 1.0;
                                    // texCoords[i*8 + 4]  = 1.0;
                                    // texCoords[i*8 + 5]  = 0.0;
                                    // texCoords[i*8 + 6]  = 1.0;
                                    // texCoords[i*8 + 7]  = 1.0;
                                }

                                attributes.st = new Cesium.GeometryAttribute({
                                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                                    componentsPerAttribute: 2,
                                    values: texCoords
                                });
                            }

                            // 12 triangles:  6 faces, 2 triangles each.
                            indices = new Uint16Array(max.length * 2 * 3);
                            var min_pos = new Cesium.Cartesian3(9999999999999, 9999999999999, 9999999999999);
                            var max_pos = new Cesium.Cartesian3(-9999999999999, -9999999999999, -9999999999999);
                            for (var i = 0; i < max.length; i++) {
                                indices[i * 6 + 0] = 4 * i + 0;
                                indices[i * 6 + 1] = 4 * i + 1;
                                indices[i * 6 + 2] = 4 * i + 2;
                                indices[i * 6 + 3] = 4 * i + 1;
                                indices[i * 6 + 4] = 4 * i + 2;
                                indices[i * 6 + 5] = 4 * i + 3;

                                if (max[i].x >= max_pos.x && max[i].y >= max_pos.y && max[i].z >= max_pos.z) {
                                    max_pos = max[i];
                                }
                                if (min[i].x <= min_pos.x && min[i].y <= min_pos.y && min[i].z <= min_pos.z) {
                                    min_pos = min[i];
                                }
                            }
                        }
                        var diff = Cesium.Cartesian3.subtract(max_pos, min_pos, diffScratch);
                        var radius = Cesium.Cartesian3.magnitude(diff) * 0.5;

                        return new Cesium.Geometry({
                            attributes: attributes,
                            indices: indices,
                            primitiveType: Cesium.PrimitiveType.TRIANGLES,
                            boundingSphere: new Cesium.BoundingSphere(Cesium.Cartesian3.ZERO, radius)
                        });
                    }
                }]);

                return WellNoBottom;
            }();

            /***/
}),
/* 72 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RectangularSensorGraphics = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function RectangularSensorGraphics(options) {
                this._show = undefined;
                this._radius = undefined;
                this._xHalfAngle = undefined;
                this._yHalfAngle = undefined;
                this._lineColor = undefined;
                this._showSectorLines = undefined;
                this._showSectorSegmentLines = undefined;
                this._showLateralSurfaces = undefined;
                this._material = undefined;
                this._showDomeSurfaces = undefined;
                this._showDomeLines = undefined;
                this._showIntersection = undefined;
                this._intersectionColor = undefined;
                this._intersectionWidth = undefined;
                this._showThroughEllipsoid = undefined;
                this._gaze = undefined;
                this._showScanPlane = undefined;
                this._scanPlaneColor = undefined;
                this._scanPlaneMode = undefined;
                this._scanPlaneRate = undefined;
                this._definitionChanged = new Cesium.Event();
                this.merge(Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT));
            }

            Object.defineProperties(RectangularSensorGraphics.prototype, {
                definitionChanged: {
                    get: function get() {
                        return this._definitionChanged;
                    }
                },

                show: Cesium.createPropertyDescriptor('show'),
                radius: Cesium.createPropertyDescriptor('radius'),
                xHalfAngle: Cesium.createPropertyDescriptor('xHalfAngle'),
                yHalfAngle: Cesium.createPropertyDescriptor('yHalfAngle'),
                lineColor: Cesium.createPropertyDescriptor('lineColor'),
                showSectorLines: Cesium.createPropertyDescriptor('showSectorLines'),
                showSectorSegmentLines: Cesium.createPropertyDescriptor('showSectorSegmentLines'),
                showLateralSurfaces: Cesium.createPropertyDescriptor('showLateralSurfaces'),
                material: Cesium.createMaterialPropertyDescriptor('material'),
                showDomeSurfaces: Cesium.createPropertyDescriptor('showDomeSurfaces'),
                showDomeLines: Cesium.createPropertyDescriptor('showDomeLines '),
                showIntersection: Cesium.createPropertyDescriptor('showIntersection'),
                intersectionColor: Cesium.createPropertyDescriptor('intersectionColor'),
                intersectionWidth: Cesium.createPropertyDescriptor('intersectionWidth'),
                showThroughEllipsoid: Cesium.createPropertyDescriptor('showThroughEllipsoid'),
                gaze: Cesium.createPropertyDescriptor('gaze'),
                showScanPlane: Cesium.createPropertyDescriptor('showScanPlane'),
                scanPlaneColor: Cesium.createPropertyDescriptor('scanPlaneColor'),
                scanPlaneMode: Cesium.createPropertyDescriptor('scanPlaneMode'),
                scanPlaneRate: Cesium.createPropertyDescriptor('scanPlaneRate')
            });

            RectangularSensorGraphics.prototype.clone = function (result) {
                if (!Cesium.defined(result)) {
                    result = new RectangularSensorGraphics();
                }

                result.show = this.show;
                result.radius = this.radius;
                result.xHalfAngle = this.xHalfAngle;
                result.yHalfAngle = this.yHalfAngle;
                result.lineColor = this.lineColor;
                result.showSectorLines = this.showSectorLines;
                result.showSectorSegmentLines = this.showSectorSegmentLines;
                result.showLateralSurfaces = this.showLateralSurfaces;
                result.material = this.material;
                result.showDomeSurfaces = this.showDomeSurfaces;
                result.showDomeLines = this.showDomeLines;
                result.showIntersection = this.showIntersection;
                result.intersectionColor = this.intersectionColor;
                result.intersectionWidth = this.intersectionWidth;
                result.showThroughEllipsoid = this.showThroughEllipsoid;
                result.gaze = this.gaze;
                result.showScanPlane = this.showScanPlane;
                result.scanPlaneColor = this.scanPlaneColor;
                result.scanPlaneMode = this.scanPlaneMode;
                result.scanPlaneRate = this.scanPlaneRate;

                return result;
            };

            RectangularSensorGraphics.prototype.merge = function (source) {
                if (!Cesium.defined(source)) {
                    throw new Cesium.DeveloperError('source is required.');
                }
                this.slice = Cesium.defaultValue(this.slice, source.slice);
                this.show = Cesium.defaultValue(this.show, source.show);
                this.radius = Cesium.defaultValue(this.radius, source.radius);
                this.xHalfAngle = Cesium.defaultValue(this.xHalfAngle, source.xHalfAngle);
                this.yHalfAngle = Cesium.defaultValue(this.yHalfAngle, source.yHalfAngle);
                this.lineColor = Cesium.defaultValue(this.lineColor, source.lineColor);
                this.showSectorLines = Cesium.defaultValue(this.showSectorLines, source.showSectorLines);
                this.showSectorSegmentLines = Cesium.defaultValue(this.showSectorSegmentLines, source.showSectorSegmentLines);
                this.showLateralSurfaces = Cesium.defaultValue(this.showLateralSurfaces, source.showLateralSurfaces);
                this.material = Cesium.defaultValue(this.material, source.material);
                this.showDomeSurfaces = Cesium.defaultValue(this.showDomeSurfaces, source.showDomeSurfaces);
                this.showDomeLines = Cesium.defaultValue(this.showDomeLines, source.showDomeLines);
                this.showIntersection = Cesium.defaultValue(this.showIntersection, source.showIntersection);
                this.intersectionColor = Cesium.defaultValue(this.intersectionColor, source.intersectionColor);
                this.intersectionWidth = Cesium.defaultValue(this.intersectionWidth, source.intersectionWidth);
                this.showThroughEllipsoid = Cesium.defaultValue(this.showThroughEllipsoid, source.showThroughEllipsoid);
                this.gaze = Cesium.defaultValue(this.gaze, source.gaze);
                this.showScanPlane = Cesium.defaultValue(this.showScanPlane, source.showScanPlane);
                this.scanPlaneColor = Cesium.defaultValue(this.scanPlaneColor, source.scanPlaneColor);
                this.scanPlaneMode = Cesium.defaultValue(this.scanPlaneMode, source.scanPlaneMode);
                this.scanPlaneRate = Cesium.defaultValue(this.scanPlaneRate, source.scanPlaneRate);
            };

            exports.RectangularSensorGraphics = RectangularSensorGraphics;

            /***/
}),
/* 73 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RectangularSensorPrimitive = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _RectangularSensorVS = __webpack_require__(172);

            var _RectangularSensorVS2 = _interopRequireDefault(_RectangularSensorVS);

            var _RectangularSensorFS = __webpack_require__(173);

            var _RectangularSensorFS2 = _interopRequireDefault(_RectangularSensorFS);

            var _RectangularSensor = __webpack_require__(174);

            var _RectangularSensor2 = _interopRequireDefault(_RectangularSensor);

            var _RectangularSensorScanPlaneFS = __webpack_require__(175);

            var _RectangularSensorScanPlaneFS2 = _interopRequireDefault(_RectangularSensorScanPlaneFS);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var BoundingSphere = Cesium.BoundingSphere;
            var Cartesian3 = Cesium.Cartesian3;
            var Color = Cesium.Color;
            var combine = Cesium.combine;
            var ComponentDatatype = Cesium.ComponentDatatype;
            var defaultValue = Cesium.defaultValue;
            var defined = Cesium.defined;
            // var defineProperties = Object.defineProperties;
            // var destroyObject = Cesium.destroyObject;
            var DeveloperError = Cesium.DeveloperError;
            var Matrix4 = Cesium.Matrix4;
            var PrimitiveType = Cesium.PrimitiveType;
            var Buffer = Cesium.Buffer;
            var BufferUsage = Cesium.BufferUsage;
            var DrawCommand = Cesium.DrawCommand;
            var Pass = Cesium.Pass;
            var RenderState = Cesium.RenderState;
            var ShaderProgram = Cesium.ShaderProgram;
            var ShaderSource = Cesium.ShaderSource;
            var VertexArray = Cesium.VertexArray;
            var BlendingState = Cesium.BlendingState;
            var CullFace = Cesium.CullFace;
            var Material = Cesium.Material;
            var SceneMode = Cesium.SceneMode;
            var VertexFormat = Cesium.VertexFormat;
            var CesiumMath = Cesium.Math;
            var Matrix3 = Cesium.Matrix3;
            var Matrix4 = Cesium.Matrix4;
            var JulianDate = Cesium.JulianDate;

            // var BoxGeometry = Cesium.BoxGeometry;
            // var EllipsoidGeometry = Cesium.EllipsoidGeometry;

            var sin = Math.sin;
            var cos = Math.cos;
            var tan = Math.tan;
            var atan = Math.atan;
            var asin = Math.asin;

            var attributeLocations = {
                position: 0,
                normal: 1
            };

            function RectangularSensorPrimitive(options) {
                var self = this;

                options = defaultValue(options, defaultValue.EMPTY_OBJECT);

                /**
                 * 是否显示
                 */
                this.show = defaultValue(options.show, true);

                /**
                 * 切分程度
                 */
                this.slice = defaultValue(options.slice, 32);

                /**
                 * 传感器的模型矩阵
                 */
                this.modelMatrix = Matrix4.clone(options.modelMatrix, new Matrix4());
                this._modelMatrix = new Matrix4();
                this._computedModelMatrix = new Matrix4();
                this._computedScanPlaneModelMatrix = new Matrix4();

                /**
                 * 传感器的半径
                 */
                this.radius = defaultValue(options.radius, Number.POSITIVE_INFINITY);
                this._radius = undefined;

                /**
                 * 传感器水平半角
                 */
                this.xHalfAngle = defaultValue(options.xHalfAngle, 0);
                this._xHalfAngle = undefined;

                /**
                 * 传感器垂直半角
                 */
                this.yHalfAngle = defaultValue(options.yHalfAngle, 0);
                this._yHalfAngle = undefined;

                /**
                 * 线的颜色
                 */
                this.lineColor = defaultValue(options.lineColor, Color.WHITE);

                /**
                 * 是否显示扇面的线
                 */
                this.showSectorLines = defaultValue(options.showSectorLines, true);

                /**
                 * 是否显示扇面和圆顶面连接的线
                 */
                this.showSectorSegmentLines = defaultValue(options.showSectorSegmentLines, true);

                /**
                 * 是否显示侧面
                 */
                this.showLateralSurfaces = defaultValue(options.showLateralSurfaces, true);

                /**
                 * 目前用的统一材质
                 * @type {Material}
                 */
                this.material = defined(options.material) ? options.material : Material.fromType(Material.ColorType);
                this._material = undefined;
                this._translucent = undefined;

                /**
                 * 侧面材质
                 * @type {Material}
                 */
                this.lateralSurfaceMaterial = defined(options.lateralSurfaceMaterial) ? options.lateralSurfaceMaterial : Material.fromType(Material.ColorType);
                this._lateralSurfaceMaterial = undefined;
                this._lateralSurfaceTranslucent = undefined;

                /**
                 * 是否显示圆顶表面
                 */
                this.showDomeSurfaces = defaultValue(options.showDomeSurfaces, true);

                /**
                 * 圆顶表面材质
                 * @type {Material}
                 */
                this.domeSurfaceMaterial = defined(options.domeSurfaceMaterial) ? options.domeSurfaceMaterial : Material.fromType(Material.ColorType);
                this._domeSurfaceMaterial = undefined;

                /**
                 * 是否显示圆顶面线
                 */
                this.showDomeLines = defaultValue(options.showDomeLines, true);

                /**
                 * 是否显示与地球相交的线
                 */
                this.showIntersection = defaultValue(options.showIntersection, true);

                /**
                 * 与地球相交的线的颜色
                 */
                this.intersectionColor = defaultValue(options.intersectionColor, Color.WHITE);

                /**
                 * 与地球相交的线的宽度（像素）
                 */
                this.intersectionWidth = defaultValue(options.intersectionWidth, 5.0);

                /**
                 * 是否穿过地球
                 */
                this.showThroughEllipsoid = defaultValue(options.showThroughEllipsoid, false);
                this._showThroughEllipsoid = undefined;

                /**
                 * 是否显示扫描面
                 */
                this.showScanPlane = defaultValue(options.showScanPlane, true);

                /**
                 * 扫描面颜色
                 */
                this.scanPlaneColor = defaultValue(options.scanPlaneColor, Color.WHITE);

                /**
                 * 扫描面模式 垂直vertical/水平horizontal
                 */
                this.scanPlaneMode = defaultValue(options.scanPlaneMode, 'horizontal');

                /**
                 * 扫描速率
                 */
                this.scanPlaneRate = defaultValue(options.scanPlaneRate, 10);

                this._scanePlaneXHalfAngle = 0;
                this._scanePlaneYHalfAngle = 0;

                //时间计算的起点
                this._time = JulianDate.now();

                this._boundingSphere = new BoundingSphere();
                this._boundingSphereWC = new BoundingSphere();

                //扇面 sector
                this._sectorFrontCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });
                this._sectorBackCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });
                this._sectorVA = undefined;

                //扇面边线 sectorLine
                this._sectorLineCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.LINES,
                    boundingVolume: this._boundingSphereWC
                });
                this._sectorLineVA = undefined;

                //扇面分割线 sectorSegmentLine
                this._sectorSegmentLineCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.LINES,
                    boundingVolume: this._boundingSphereWC
                });
                this._sectorSegmentLineVA = undefined;

                //弧面 dome
                this._domeFrontCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });
                this._domeBackCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });
                this._domeVA = undefined;

                //弧面线 domeLine
                this._domeLineCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.LINES,
                    boundingVolume: this._boundingSphereWC
                });
                this._domeLineVA = undefined;

                //扫描面 scanPlane/scanRadial
                this._scanPlaneFrontCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });
                this._scanPlaneBackCommand = new DrawCommand({
                    owner: this,
                    primitiveType: PrimitiveType.TRIANGLES,
                    boundingVolume: this._boundingSphereWC
                });

                this._scanRadialCommand = undefined;

                this._colorCommands = [];

                this._frontFaceRS = undefined;
                this._backFaceRS = undefined;
                this._sp = undefined;

                this._uniforms = {
                    u_type: function u_type() {
                        return 0; //面
                    },
                    u_xHalfAngle: function u_xHalfAngle() {
                        return self.xHalfAngle;
                    },
                    u_yHalfAngle: function u_yHalfAngle() {
                        return self.yHalfAngle;
                    },
                    u_radius: function u_radius() {
                        return self.radius;
                    },
                    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
                        return self.showThroughEllipsoid;
                    },
                    u_showIntersection: function u_showIntersection() {
                        return self.showIntersection;
                    },
                    u_intersectionColor: function u_intersectionColor() {
                        return self.intersectionColor;
                    },
                    u_intersectionWidth: function u_intersectionWidth() {
                        return self.intersectionWidth;
                    },
                    u_normalDirection: function u_normalDirection() {
                        return 1.0;
                    },
                    u_lineColor: function u_lineColor() {
                        return self.lineColor;
                    }
                };

                this._scanUniforms = {
                    u_xHalfAngle: function u_xHalfAngle() {
                        return self._scanePlaneXHalfAngle;
                    },
                    u_yHalfAngle: function u_yHalfAngle() {
                        return self._scanePlaneYHalfAngle;
                    },
                    u_radius: function u_radius() {
                        return self.radius;
                    },
                    u_color: function u_color() {
                        return self.scanPlaneColor;
                    },
                    u_showThroughEllipsoid: function u_showThroughEllipsoid() {
                        return self.showThroughEllipsoid;
                    },
                    u_showIntersection: function u_showIntersection() {
                        return self.showIntersection;
                    },
                    u_intersectionColor: function u_intersectionColor() {
                        return self.intersectionColor;
                    },
                    u_intersectionWidth: function u_intersectionWidth() {
                        return self.intersectionWidth;
                    },
                    u_normalDirection: function u_normalDirection() {
                        return 1.0;
                    },
                    u_lineColor: function u_lineColor() {
                        return self.lineColor;
                    }
                };
            }

            RectangularSensorPrimitive.prototype.update = function (frameState) {
                var mode = frameState.mode;
                if (!this.show || mode !== SceneMode.SCENE3D) {
                    return;
                }
                var createVS = false;
                var createRS = false;
                var createSP = false;

                var xHalfAngle = this.xHalfAngle;
                var yHalfAngle = this.yHalfAngle;

                if (xHalfAngle < 0.0 || yHalfAngle < 0.0) {
                    throw new DeveloperError('halfAngle must be greater than or equal to zero.');
                }
                if (xHalfAngle == 0.0 || yHalfAngle == 0.0) {
                    return;
                }
                if (this._xHalfAngle !== xHalfAngle || this._yHalfAngle !== yHalfAngle) {
                    this._xHalfAngle = xHalfAngle;
                    this._yHalfAngle = yHalfAngle;
                    createVS = true;
                }

                var radius = this.radius;
                if (radius < 0.0) {
                    throw new DeveloperError('this.radius must be greater than or equal to zero.');
                }
                var radiusChanged = false;
                if (this._radius !== radius) {
                    radiusChanged = true;
                    this._radius = radius;
                    this._boundingSphere = new BoundingSphere(Cartesian3.ZERO, this.radius);
                }

                var modelMatrixChanged = !Matrix4.equals(this.modelMatrix, this._modelMatrix);
                if (modelMatrixChanged || radiusChanged) {
                    Matrix4.clone(this.modelMatrix, this._modelMatrix);
                    Matrix4.multiplyByUniformScale(this.modelMatrix, this.radius, this._computedModelMatrix);
                    BoundingSphere.transform(this._boundingSphere, this.modelMatrix, this._boundingSphereWC);
                }

                var showThroughEllipsoid = this.showThroughEllipsoid;
                if (this._showThroughEllipsoid !== this.showThroughEllipsoid) {
                    this._showThroughEllipsoid = showThroughEllipsoid;
                    createRS = true;
                }

                var material = this.material;
                if (this._material !== material) {
                    this._material = material;
                    createRS = true;
                    createSP = true;
                }
                var translucent = material.isTranslucent();
                if (this._translucent !== translucent) {
                    this._translucent = translucent;
                    createRS = true;
                }

                if (this.showScanPlane) {
                    var time = frameState.time;
                    var timeDiff = JulianDate.secondsDifference(time, this._time);
                    if (timeDiff < 0) {
                        this._time = JulianDate.clone(time, this._time);
                    }
                    var percentage = Math.max(timeDiff % this.scanPlaneRate / this.scanPlaneRate, 0);
                    var angle;

                    if (this.scanPlaneMode == 'horizontal') {
                        angle = 2 * yHalfAngle * percentage - yHalfAngle;
                        var cosYHalfAngle = cos(angle);
                        var tanXHalfAngle = tan(xHalfAngle);

                        var maxX = atan(cosYHalfAngle * tanXHalfAngle);
                        this._scanePlaneXHalfAngle = maxX;
                        this._scanePlaneYHalfAngle = angle;
                        Cesium.Matrix3.fromRotationX(this._scanePlaneYHalfAngle, matrix3Scratch);
                    } else {
                        angle = 2 * xHalfAngle * percentage - xHalfAngle;
                        var tanYHalfAngle = tan(yHalfAngle);
                        var cosXHalfAngle = cos(angle);

                        var maxY = atan(cosXHalfAngle * tanYHalfAngle);
                        this._scanePlaneXHalfAngle = angle;
                        this._scanePlaneYHalfAngle = maxY;
                        Cesium.Matrix3.fromRotationY(this._scanePlaneXHalfAngle, matrix3Scratch);
                    }

                    Cesium.Matrix4.multiplyByMatrix3(this.modelMatrix, matrix3Scratch, this._computedScanPlaneModelMatrix);
                    Matrix4.multiplyByUniformScale(this._computedScanPlaneModelMatrix, this.radius, this._computedScanPlaneModelMatrix);
                }

                if (createVS) {
                    createVertexArray(this, frameState);
                }
                if (createRS) {
                    createRenderState(this, showThroughEllipsoid, translucent);
                }
                if (createSP) {
                    createShaderProgram(this, frameState, material);
                }
                if (createRS || createSP) {
                    createCommands(this, translucent);
                }

                var commandList = frameState.commandList;
                var passes = frameState.passes;
                var colorCommands = this._colorCommands;
                if (passes.render) {
                    for (var i = 0, len = colorCommands.length; i < len; i++) {
                        var colorCommand = colorCommands[i];
                        commandList.push(colorCommand);
                    }
                }
            };

            var matrix3Scratch = new Matrix3();
            var nScratch = new Cartesian3();

            //region -- VertexArray --

            /**
             * 计算zoy面和zoy面单位扇形位置
             * @param primitive
             * @returns {{zoy: Array, zox: Array}}
             */
            function computeUnitPosiiton(primitive, xHalfAngle, yHalfAngle) {
                var slice = primitive.slice;

                //以中心为角度
                var cosYHalfAngle = cos(yHalfAngle);
                var tanYHalfAngle = tan(yHalfAngle);
                var cosXHalfAngle = cos(xHalfAngle);
                var tanXHalfAngle = tan(xHalfAngle);

                var maxY = atan(cosXHalfAngle * tanYHalfAngle);
                var maxX = atan(cosYHalfAngle * tanXHalfAngle);

                //ZOY面单位圆
                var zoy = [];
                for (var i = 0; i < slice; i++) {
                    var phi = 2 * maxY * i / (slice - 1) - maxY;
                    zoy.push(new Cartesian3(0, sin(phi), cos(phi)));
                }
                //zox面单位圆
                var zox = [];
                for (var i = 0; i < slice; i++) {
                    var phi = 2 * maxX * i / (slice - 1) - maxX;
                    zox.push(new Cartesian3(sin(phi), 0, cos(phi)));
                }

                return {
                    zoy: zoy,
                    zox: zox
                };
            }

            /**
             * 计算扇面的位置
             * @param unitPosition
             * @returns {Array}
             */
            function computeSectorPositions(primitive, unitPosition) {
                var xHalfAngle = primitive.xHalfAngle,
                    yHalfAngle = primitive.yHalfAngle,
                    zoy = unitPosition.zoy,
                    zox = unitPosition.zox;
                var positions = [];

                //zoy面沿y轴逆时针转xHalfAngle
                var matrix3 = Matrix3.fromRotationY(xHalfAngle, matrix3Scratch);
                positions.push(zoy.map(function (p) {
                    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
                }));
                //zox面沿x轴顺时针转yHalfAngle
                var matrix3 = Matrix3.fromRotationX(-yHalfAngle, matrix3Scratch);
                positions.push(zox.map(function (p) {
                    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
                }).reverse());
                //zoy面沿y轴顺时针转xHalfAngle
                var matrix3 = Matrix3.fromRotationY(-xHalfAngle, matrix3Scratch);
                positions.push(zoy.map(function (p) {
                    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
                }).reverse());
                //zox面沿x轴逆时针转yHalfAngle
                var matrix3 = Matrix3.fromRotationX(yHalfAngle, matrix3Scratch);
                positions.push(zox.map(function (p) {
                    return Matrix3.multiplyByVector(matrix3, p, new Cesium.Cartesian3());
                }));
                return positions;
            }

            /**
             * 创建扇面顶点
             * @param context
             * @param positions
             * @returns {*}
             */
            function createSectorVertexArray(context, positions) {
                var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
                var vertices = new Float32Array(2 * 3 * 3 * planeLength);

                var k = 0;
                for (var i = 0, len = positions.length; i < len; i++) {
                    var planePositions = positions[i];
                    var n = Cartesian3.normalize(Cartesian3.cross(planePositions[0], planePositions[planePositions.length - 1], nScratch), nScratch);
                    for (var j = 0, planeLength = planePositions.length - 1; j < planeLength; j++) {
                        vertices[k++] = 0.0;
                        vertices[k++] = 0.0;
                        vertices[k++] = 0.0;
                        vertices[k++] = -n.x;
                        vertices[k++] = -n.y;
                        vertices[k++] = -n.z;

                        vertices[k++] = planePositions[j].x;
                        vertices[k++] = planePositions[j].y;
                        vertices[k++] = planePositions[j].z;
                        vertices[k++] = -n.x;
                        vertices[k++] = -n.y;
                        vertices[k++] = -n.z;

                        vertices[k++] = planePositions[j + 1].x;
                        vertices[k++] = planePositions[j + 1].y;
                        vertices[k++] = planePositions[j + 1].z;
                        vertices[k++] = -n.x;
                        vertices[k++] = -n.y;
                        vertices[k++] = -n.z;
                    }
                }

                var vertexBuffer = Buffer.createVertexBuffer({
                    context: context,
                    typedArray: vertices,
                    usage: BufferUsage.STATIC_DRAW
                });

                var stride = 2 * 3 * Float32Array.BYTES_PER_ELEMENT;

                var attributes = [{
                    index: attributeLocations.position,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 3,
                    componentDatatype: ComponentDatatype.FLOAT,
                    offsetInBytes: 0,
                    strideInBytes: stride
                }, {
                    index: attributeLocations.normal,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 3,
                    componentDatatype: ComponentDatatype.FLOAT,
                    offsetInBytes: 3 * Float32Array.BYTES_PER_ELEMENT,
                    strideInBytes: stride
                }];

                return new VertexArray({
                    context: context,
                    attributes: attributes
                });
            }

            /**
             * 创建扇面边线顶点
             * @param context
             * @param positions
             * @returns {*}
             */
            function createSectorLineVertexArray(context, positions) {
                var planeLength = positions.length;
                var vertices = new Float32Array(3 * 3 * planeLength);

                var k = 0;
                for (var i = 0, len = positions.length; i < len; i++) {
                    var planePositions = positions[i];
                    vertices[k++] = 0.0;
                    vertices[k++] = 0.0;
                    vertices[k++] = 0.0;

                    vertices[k++] = planePositions[0].x;
                    vertices[k++] = planePositions[0].y;
                    vertices[k++] = planePositions[0].z;
                }

                var vertexBuffer = Buffer.createVertexBuffer({
                    context: context,
                    typedArray: vertices,
                    usage: BufferUsage.STATIC_DRAW
                });

                var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

                var attributes = [{
                    index: attributeLocations.position,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 3,
                    componentDatatype: ComponentDatatype.FLOAT,
                    offsetInBytes: 0,
                    strideInBytes: stride
                }];

                return new VertexArray({
                    context: context,
                    attributes: attributes
                });
            }

            /**
             * 创建扇面圆顶面连接线顶点
             * @param context
             * @param positions
             * @returns {*}
             */
            function createSectorSegmentLineVertexArray(context, positions) {
                var planeLength = Array.prototype.concat.apply([], positions).length - positions.length;
                var vertices = new Float32Array(3 * 3 * planeLength);

                var k = 0;
                for (var i = 0, len = positions.length; i < len; i++) {
                    var planePositions = positions[i];

                    for (var j = 0, planeLength = planePositions.length - 1; j < planeLength; j++) {
                        vertices[k++] = planePositions[j].x;
                        vertices[k++] = planePositions[j].y;
                        vertices[k++] = planePositions[j].z;

                        vertices[k++] = planePositions[j + 1].x;
                        vertices[k++] = planePositions[j + 1].y;
                        vertices[k++] = planePositions[j + 1].z;
                    }
                }

                var vertexBuffer = Buffer.createVertexBuffer({
                    context: context,
                    typedArray: vertices,
                    usage: BufferUsage.STATIC_DRAW
                });

                var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

                var attributes = [{
                    index: attributeLocations.position,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 3,
                    componentDatatype: ComponentDatatype.FLOAT,
                    offsetInBytes: 0,
                    strideInBytes: stride
                }];

                return new VertexArray({
                    context: context,
                    attributes: attributes
                });
            }

            /**
             * 创建圆顶面顶点
             * @param context
             */
            function createDomeVertexArray(context) {
                var geometry = Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
                    vertexFormat: VertexFormat.POSITION_ONLY,
                    stackPartitions: 32,
                    slicePartitions: 32
                }));

                var vertexArray = VertexArray.fromGeometry({
                    context: context,
                    geometry: geometry,
                    attributeLocations: attributeLocations,
                    bufferUsage: BufferUsage.STATIC_DRAW,
                    interleave: false
                });
                return vertexArray;
            }

            /**
             * 创建圆顶面连线顶点
             * @param context
             */
            function createDomeLineVertexArray(context) {
                var geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(new Cesium.EllipsoidOutlineGeometry({
                    vertexFormat: VertexFormat.POSITION_ONLY,
                    stackPartitions: 32,
                    slicePartitions: 32
                }));

                var vertexArray = VertexArray.fromGeometry({
                    context: context,
                    geometry: geometry,
                    attributeLocations: attributeLocations,
                    bufferUsage: BufferUsage.STATIC_DRAW,
                    interleave: false
                });
                return vertexArray;
            }

            /**
             * 创建扫描面顶点
             * @param context
             * @param positions
             * @returns {*}
             */
            function createScanPlaneVertexArray(context, positions) {
                var planeLength = positions.length - 1;
                var vertices = new Float32Array(3 * 3 * planeLength);

                var k = 0;
                for (var i = 0; i < planeLength; i++) {
                    vertices[k++] = 0.0;
                    vertices[k++] = 0.0;
                    vertices[k++] = 0.0;

                    vertices[k++] = positions[i].x;
                    vertices[k++] = positions[i].y;
                    vertices[k++] = positions[i].z;

                    vertices[k++] = positions[i + 1].x;
                    vertices[k++] = positions[i + 1].y;
                    vertices[k++] = positions[i + 1].z;
                }

                var vertexBuffer = Buffer.createVertexBuffer({
                    context: context,
                    typedArray: vertices,
                    usage: BufferUsage.STATIC_DRAW
                });

                var stride = 3 * Float32Array.BYTES_PER_ELEMENT;

                var attributes = [{
                    index: attributeLocations.position,
                    vertexBuffer: vertexBuffer,
                    componentsPerAttribute: 3,
                    componentDatatype: ComponentDatatype.FLOAT,
                    offsetInBytes: 0,
                    strideInBytes: stride
                }];

                return new VertexArray({
                    context: context,
                    attributes: attributes
                });
            }

            function createVertexArray(primitive, frameState) {
                var context = frameState.context;

                var unitSectorPositions = computeUnitPosiiton(primitive, primitive.xHalfAngle, primitive.yHalfAngle);
                var positions = computeSectorPositions(primitive, unitSectorPositions);

                //显示扇面
                if (primitive.showLateralSurfaces) {
                    primitive._sectorVA = createSectorVertexArray(context, positions);
                }

                //显示扇面线
                if (primitive.showSectorLines) {
                    primitive._sectorLineVA = createSectorLineVertexArray(context, positions);
                }

                //显示扇面圆顶面的交线
                if (primitive.showSectorSegmentLines) {
                    primitive._sectorSegmentLineVA = createSectorSegmentLineVertexArray(context, positions);
                }

                //显示弧面
                if (primitive.showDomeSurfaces) {
                    primitive._domeVA = createDomeVertexArray(context);
                }

                //显示弧面线
                if (primitive.showDomeLines) {
                    primitive._domeLineVA = createDomeLineVertexArray(context);
                }

                //显示扫描面
                if (primitive.showScanPlane) {

                    if (primitive.scanPlaneMode == 'horizontal') {
                        var unitScanPlanePositions = computeUnitPosiiton(primitive, CesiumMath.PI_OVER_TWO, 0);
                        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zox);
                    } else {
                        var unitScanPlanePositions = computeUnitPosiiton(primitive, 0, CesiumMath.PI_OVER_TWO);
                        primitive._scanPlaneVA = createScanPlaneVertexArray(context, unitScanPlanePositions.zoy);
                    }
                }
            }

            //endregion

            //region -- ShaderProgram --

            function createCommonShaderProgram(primitive, frameState, material) {
                var context = frameState.context;

                var vs = _RectangularSensorVS2.default;
                var fs = new ShaderSource({
                    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default]
                });

                primitive._sp = ShaderProgram.replaceCache({
                    context: context,
                    shaderProgram: primitive._sp,
                    vertexShaderSource: vs,
                    fragmentShaderSource: fs,
                    attributeLocations: attributeLocations
                });

                var pickFS = new ShaderSource({
                    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorFS2.default],
                    pickColorQualifier: 'uniform'
                });

                primitive._pickSP = ShaderProgram.replaceCache({
                    context: context,
                    shaderProgram: primitive._pickSP,
                    vertexShaderSource: vs,
                    fragmentShaderSource: pickFS,
                    attributeLocations: attributeLocations
                });
            }

            function createScanPlaneShaderProgram(primitive, frameState, material) {
                var context = frameState.context;

                var vs = _RectangularSensorVS2.default;
                var fs = new ShaderSource({
                    sources: [_RectangularSensor2.default, material.shaderSource, _RectangularSensorScanPlaneFS2.default]
                });

                primitive._scanePlaneSP = ShaderProgram.replaceCache({
                    context: context,
                    shaderProgram: primitive._scanePlaneSP,
                    vertexShaderSource: vs,
                    fragmentShaderSource: fs,
                    attributeLocations: attributeLocations
                });
            }

            function createShaderProgram(primitive, frameState, material) {
                createCommonShaderProgram(primitive, frameState, material);

                if (primitive.showScanPlane) {
                    createScanPlaneShaderProgram(primitive, frameState, material);
                }
            }

            //endregion

            //region -- RenderState --

            function createRenderState(primitive, showThroughEllipsoid, translucent) {
                if (translucent) {
                    primitive._frontFaceRS = RenderState.fromCache({
                        depthTest: {
                            enabled: !showThroughEllipsoid
                        },
                        depthMask: false,
                        blending: BlendingState.ALPHA_BLEND,
                        cull: {
                            enabled: true,
                            face: CullFace.BACK
                        }
                    });

                    primitive._backFaceRS = RenderState.fromCache({
                        depthTest: {
                            enabled: !showThroughEllipsoid
                        },
                        depthMask: false,
                        blending: BlendingState.ALPHA_BLEND,
                        cull: {
                            enabled: true,
                            face: CullFace.FRONT
                        }
                    });

                    primitive._pickRS = RenderState.fromCache({
                        depthTest: {
                            enabled: !showThroughEllipsoid
                        },
                        depthMask: false,
                        blending: BlendingState.ALPHA_BLEND
                    });
                } else {
                    primitive._frontFaceRS = RenderState.fromCache({
                        depthTest: {
                            enabled: !showThroughEllipsoid
                        },
                        depthMask: true
                    });

                    primitive._pickRS = RenderState.fromCache({
                        depthTest: {
                            enabled: true
                        },
                        depthMask: true
                    });
                }
            }

            //endregion

            //region -- Command --

            function createCommand(primitive, frontCommand, backCommand, frontFaceRS, backFaceRS, sp, va, uniforms, modelMatrix, translucent, pass, isLine) {
                if (translucent && backCommand) {
                    backCommand.vertexArray = va;
                    backCommand.renderState = backFaceRS;
                    backCommand.shaderProgram = sp;
                    backCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
                    backCommand.uniformMap.u_normalDirection = function () {
                        return -1.0;
                    };
                    backCommand.pass = pass;
                    backCommand.modelMatrix = modelMatrix;
                    primitive._colorCommands.push(backCommand);
                }

                frontCommand.vertexArray = va;
                frontCommand.renderState = frontFaceRS;
                frontCommand.shaderProgram = sp;
                frontCommand.uniformMap = combine(uniforms, primitive._material._uniforms);
                if (isLine) {
                    frontCommand.uniformMap.u_type = function () {
                        return 1;
                    };
                }
                frontCommand.pass = pass;
                frontCommand.modelMatrix = modelMatrix;
                primitive._colorCommands.push(frontCommand);
            }

            function createCommands(primitive, translucent) {
                primitive._colorCommands.length = 0;

                var pass = translucent ? Pass.TRANSLUCENT : Pass.OPAQUE;

                //显示扇面
                if (primitive.showLateralSurfaces) {
                    createCommand(primitive, primitive._sectorFrontCommand, primitive._sectorBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
                }
                //显示扇面线
                if (primitive.showSectorLines) {
                    createCommand(primitive, primitive._sectorLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
                }
                //显示扇面交接线
                if (primitive.showSectorSegmentLines) {
                    createCommand(primitive, primitive._sectorSegmentLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._sectorSegmentLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
                }
                //显示弧面
                if (primitive.showDomeSurfaces) {
                    createCommand(primitive, primitive._domeFrontCommand, primitive._domeBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass);
                }
                //显示弧面线
                if (primitive.showDomeLines) {
                    createCommand(primitive, primitive._domeLineCommand, undefined, primitive._frontFaceRS, primitive._backFaceRS, primitive._sp, primitive._domeLineVA, primitive._uniforms, primitive._computedModelMatrix, translucent, pass, true);
                }
                //显示扫描面
                if (primitive.showScanPlane) {
                    createCommand(primitive, primitive._scanPlaneFrontCommand, primitive._scanPlaneBackCommand, primitive._frontFaceRS, primitive._backFaceRS, primitive._scanePlaneSP, primitive._scanPlaneVA, primitive._scanUniforms, primitive._computedScanPlaneModelMatrix, translucent, pass);
                }
            }

            //endregion

            exports.RectangularSensorPrimitive = RectangularSensorPrimitive;

            /***/
}),
/* 74 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            __webpack_require__(75);

            __webpack_require__(76);

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _version = __webpack_require__(43);

            var ver = _interopRequireWildcard(_version);

            var _MapVClass = __webpack_require__(23);

            var _widgetManager = __webpack_require__(44);

            var widget = _interopRequireWildcard(_widgetManager);

            var _BaseWidget = __webpack_require__(77);

            var _map = __webpack_require__(78);

            var _ViewerEx = __webpack_require__(46);

            var _layer = __webpack_require__(20);

            var layer = _interopRequireWildcard(_layer);

            var _FloodByEntity = __webpack_require__(116);

            var _FloodByTerrain = __webpack_require__(117);

            var _Measure = __webpack_require__(118);

            var _MeasureVolume = __webpack_require__(119);

            var _Skyline = __webpack_require__(120);

            var _TerrainClip = __webpack_require__(122);

            var _TerrainClipPlan = __webpack_require__(123);

            var _Underground = __webpack_require__(124);

            var _ViewShed3D = __webpack_require__(125);

            var _Sightline = __webpack_require__(127);

            var _HeightCounterByTerrain = __webpack_require__(128);

            var _Slope = __webpack_require__(129);

            var _MixedOcclusion = __webpack_require__(130);

            var _TilesEditor = __webpack_require__(131);

            var _TilesClipPlan = __webpack_require__(132);

            var _TilesClip = __webpack_require__(133);

            var _TilesFlat = __webpack_require__(136);

            var _TilesFlood = __webpack_require__(137);

            var _FlyLine = __webpack_require__(138);

            var _KeyboardRoam = __webpack_require__(69);

            var _Draw = __webpack_require__(4);

            var _index = __webpack_require__(26);

            var Attr = _interopRequireWildcard(_index);

            var _EventType = __webpack_require__(18);

            var EventType = _interopRequireWildcard(_EventType);

            var _Tooltip = __webpack_require__(5);

            var _Util = __webpack_require__(7);

            var DrawUtil = _interopRequireWildcard(_Util);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Edit = __webpack_require__(21);

            var _Edit2 = __webpack_require__(63);

            var _Edit3 = __webpack_require__(60);

            var _Edit4 = __webpack_require__(58);

            var _Edit5 = __webpack_require__(64);

            var _Edit6 = __webpack_require__(57);

            var _Edit7 = __webpack_require__(25);

            var _Edit8 = __webpack_require__(10);

            var _Edit9 = __webpack_require__(22);

            var _Edit10 = __webpack_require__(59);

            var _Edit11 = __webpack_require__(62);

            var _Edit12 = __webpack_require__(65);

            var _Edit13 = __webpack_require__(67);

            var _Edit14 = __webpack_require__(66);

            var _EditP = __webpack_require__(68);

            var _PlotUtil = __webpack_require__(11);

            __webpack_require__(139);

            __webpack_require__(141);

            __webpack_require__(143);

            __webpack_require__(145);

            __webpack_require__(147);

            __webpack_require__(149);

            __webpack_require__(151);

            __webpack_require__(153);

            __webpack_require__(155);

            __webpack_require__(157);

            __webpack_require__(159);

            __webpack_require__(160);

            __webpack_require__(161);

            __webpack_require__(162);

            __webpack_require__(163);

            var _CircleFadeMaterial = __webpack_require__(164);

            var _CircleWaveMaterial = __webpack_require__(47);

            var _CircleScanMaterial = __webpack_require__(166);

            var _GroundLineFlowMaterial = __webpack_require__(168);

            var _LineFlowMaterial = __webpack_require__(36);

            var _TextMaterial = __webpack_require__(170);

            var _RectangularSensorPrimitive = __webpack_require__(73);

            var _RectangularSensorGraphics = __webpack_require__(72);

            var _RectangularSensorVisualizer = __webpack_require__(176);

            var _DivPoint = __webpack_require__(178);

            var _DynamicRiver = __webpack_require__(179);

            var _water = __webpack_require__(181);

            var water = _interopRequireWildcard(_water);

            var _RainFS = __webpack_require__(182);

            var _RainFS2 = _interopRequireDefault(_RainFS);

            var _SnowFS = __webpack_require__(183);

            var _SnowFS2 = _interopRequireDefault(_SnowFS);

            var _FogEffect = __webpack_require__(184);

            var _InvertedScene = __webpack_require__(185);

            var _SnowCover = __webpack_require__(187);

            var _WaterSpout = __webpack_require__(189);

            var _ZoomNavigation = __webpack_require__(190);

            var _matrix = __webpack_require__(17);

            var matrix = _interopRequireWildcard(_matrix);

            var _model = __webpack_require__(191);

            var model = _interopRequireWildcard(_model);

            var _point = __webpack_require__(2);

            var point = _interopRequireWildcard(_point);

            var _polygon = __webpack_require__(12);

            var polygon = _interopRequireWildcard(_polygon);

            var _polyline = __webpack_require__(33);

            var polyline = _interopRequireWildcard(_polyline);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            var _config2Entity = __webpack_require__(28);

            var _tileset = __webpack_require__(27);

            var tileset = _interopRequireWildcard(_tileset);

            var _Video3D = __webpack_require__(192);

            var _Video2D = __webpack_require__(194);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            exports.Cesium = Cesium; //方便vue等技术栈直接使用


            //===========框架基本信息=========  


            exports.name = "MapV3D ( MapVGIS for Cesium )三维地球框架";
            exports.website = "http://www.aimapvision.com/";
            exports.author = "图洋科技 LYW";
            exports.version = ver.version;
            exports.update = ver.update;

            //=============额外类=====================

            exports.MapVClass = _MapVClass.MapVClass;

            //widget

            exports.widget = widget;

            exports.widget.BaseWidget = _BaseWidget.BaseWidget;

            //=============三维框架类=====================

            exports.createMap = _map.createMap;

            exports.ViewerEx = _ViewerEx.ViewerEx;

            exports.layer = layer;

            //=====================分析相关=====================
            exports.analysi = {};

            //淹没分析（polygon矢量面抬高）

            exports.analysi.FloodByEntity = _FloodByEntity.FloodByEntity;

            //淹没分析 （基于terrain地形）

            exports.analysi.FloodByTerrain = _FloodByTerrain.FloodByTerrain;

            //量算（长度、面积、角度等）

            exports.analysi.Measure = _Measure.Measure;

            //方量分析

            exports.analysi.MeasureVolume = _MeasureVolume.MeasureVolume;

            //天际线 描边

            exports.analysi.Skyline = _Skyline.Skyline;

            //地形开挖 类 (基于地形)

            exports.analysi.TerrainClip = _TerrainClip.TerrainClip;

            //地形开挖 类（平面 Plan原生）

            exports.analysi.TerrainClipPlan = _TerrainClipPlan.TerrainClipPlan;

            //地下模式

            exports.analysi.Underground = _Underground.Underground;

            //可视域分析 

            exports.analysi.ViewShed3D = _ViewShed3D.ViewShed3D;

            //通视分析

            exports.analysi.Sightline = _Sightline.Sightline;

            //等高线

            exports.analysi.HeightCounterByTerrain = _HeightCounterByTerrain.HeightCounterByTerrain;

            //坡度坡向

            exports.analysi.Slope = _Slope.Slope;

            //=====================3dtiles模型 分析相关  =====================
            exports.tiles = {};

            //混合遮挡

            exports.tiles.MixedOcclusion = _MixedOcclusion.MixedOcclusion;

            //模型编辑（移动、旋转等）

            exports.tiles.TilesEditor = _TilesEditor.TilesEditor;

            //模型裁剪（平面 Plan原生）

            exports.tiles.TilesClipPlan = _TilesClipPlan.TilesClipPlan;

            //模型 裁剪（单个、对数据有要求）

            exports.tiles.TilesClip = _TilesClip.TilesClip;

            //模型 压平分析 （单个、对数据有要求）

            exports.tiles.TilesFlat = _TilesFlat.TilesFlat;

            //模型 淹没分析（单个、对数据有要求）

            exports.tiles.TilesFlood = _TilesFlood.TilesFlood;

            //=====================相机 视角 相关=====================

            exports.FlyLine = _FlyLine.FlyLine;

            exports.KeyboardType = _KeyboardRoam.KeyboardType;

            //=====================Draw标绘=====================

            exports.Draw = _Draw.Draw;

            exports.draw = {};
            exports.draw.register = _Draw.register;

            exports.draw.attr = Attr;

            exports.draw.event = EventType;

            exports.draw.tooltip = _Tooltip.message;

            exports.draw.util = DrawUtil;

            exports.draw.dragger = draggerCtl;

            exports.DrawEdit = {};

            exports.DrawEdit.Base = _Edit.EditBase;

            exports.DrawEdit.Circle = _Edit2.EditCircle;

            exports.DrawEdit.Corridor = _Edit3.EditCorridor;

            exports.DrawEdit.Curve = _Edit4.EditCurve;

            exports.DrawEdit.Ellipsoid = _Edit5.EditEllipsoid;

            exports.DrawEdit.Point = _Edit6.EditPoint;

            exports.DrawEdit.Polygon = _Edit7.EditPolygon;

            exports.DrawEdit.PolygonEx = _Edit8.EditPolygonEx;

            exports.DrawEdit.Polyline = _Edit9.EditPolyline;

            exports.DrawEdit.PolylineVolume = _Edit10.EditPolylineVolume;

            exports.DrawEdit.Rectangle = _Edit11.EditRectangle;

            exports.DrawEdit.Wall = _Edit12.EditWall;

            exports.DrawEdit.Box = _Edit13.EditBox;

            exports.DrawEdit.Plane = _Edit14.EditPlane;

            exports.DrawEdit.PModel = _EditP.EditPModel;

            //Draw标绘 扩展部分，下面也可以单独插件的方式另外打包

            exports.draw.plotUtil = _PlotUtil.plotUtil;

            //=====================扩展的矢量对象=====================
            //扩展的材质

            exports.CircleFadeMaterial = _CircleFadeMaterial.CircleFadeMaterial;

            exports.CircleWaveMaterial = _CircleWaveMaterial.CircleWaveMaterial;

            exports.CircleScanMaterial = _CircleScanMaterial.CircleScanMaterial;

            //贴地线

            exports.GroundLineFlowMaterial = _GroundLineFlowMaterial.GroundLineFlowMaterial;

            //动态线、墙

            exports.LineFlowMaterial = _LineFlowMaterial.LineFlowMaterial;

            //文本材质

            exports.TextMaterial = _TextMaterial.TextMaterial;

            //相控阵雷达

            exports.RectangularSensorPrimitive = _RectangularSensorPrimitive.RectangularSensorPrimitive;
            exports.RectangularSensorGraphics = _RectangularSensorGraphics.RectangularSensorGraphics;
            exports.RectangularSensorVisualizer = _RectangularSensorVisualizer.RectangularSensorVisualizer;
            var originalDefaultVisualizersCallback = Cesium.DataSourceDisplay.defaultVisualizersCallback;
            Cesium.DataSourceDisplay.defaultVisualizersCallback = function (scene, entityCluster, dataSource) {
                var entities = dataSource.entities;
                var array = originalDefaultVisualizersCallback(scene, entityCluster, dataSource);
                return array.concat([new _RectangularSensorVisualizer.RectangularSensorVisualizer(scene, entities)]);
            };

            //div点

            exports.DivPoint = _DivPoint.DivPoint;

            //动态河流、公路

            exports.DynamicRiver = _DynamicRiver.DynamicRiver;

            //水域 相关效果

            exports.water = water;

            //=====================场景特效=====================
            exports.scene = {};

            //雨雪 着色器

            exports.scene.RainFS = _RainFS2.default;

            exports.scene.SnowFS = _SnowFS2.default;

            //雾特效

            exports.scene.FogEffect = _FogEffect.FogEffect;

            //场景倒影

            exports.scene.InvertedScene = _InvertedScene.InvertedScene;

            //雾覆盖 效果

            exports.scene.SnowCover = _SnowCover.SnowCover;

            //水柱粒子效果

            exports.scene.WaterSpout = _WaterSpout.WaterSpout;

            //===================== tool =====================

            exports.ZoomNavigation = _ZoomNavigation.ZoomNavigation;

            //===================== util =====================

            exports.matrix = matrix;

            exports.model = model;

            exports.point = point;

            exports.polygon = polygon;

            exports.polyline = polyline;

            exports.pointconvert = pointconvert;

            exports.util = util;

            exports.util.config2Entity = _config2Entity.config2Entity;

            exports.tileset = tileset;

            //=====================视频融合 相关  =====================
            exports.video = {};

            //视频融合（投射3D，贴物体表面）

            exports.video.Video3D = _Video3D.Video3D;

            //视频融合（投射2D平面） 

            exports.video.Video2D = _Video2D.Video2D;

            //===========兼容历史版本命名(如果你接收的是非升级版本，可以注释下面代码)=============
            exports.latlng = point; //1.6

            exports.TilesEditor = _TilesEditor.TilesEditor; //1.8.3
            exports.Measure = _Measure.Measure; //1.8.3
            exports.util.createModel = model.createModel; //1.8.3
            exports.util.tileset = tileset; //1.8.3

            exports.AnimationLineMaterialProperty = _LineFlowMaterial.LineFlowMaterial; //1.8.5
            exports.ElliposidFadeMaterialProperty = _CircleFadeMaterial.CircleFadeMaterial; //1.8.5
            exports.GroundPolylineFlowMaterial = _GroundLineFlowMaterial.GroundLineFlowMaterial; //1.8.5

            exports.analysi.TerrainExcavate = _TerrainClip.TerrainClip; //1.9.0
            exports.analysi.TerrainFlood = _FloodByTerrain.FloodByTerrain; //1.9.0
            exports.analysi.VideoShed3D = _Video3D.Video3D; //1.9.0
            exports.VideoShed3D = _Video3D.Video3D; //1.9.0

            exports.util.terrainPolyline = polyline.computeSurfaceLine; //1.9.1
            exports.point.formatPositon = point.formatPosition; //1.9.1  单词错误改正

            exports.util.hasTerrain = layer.hasTerrain; //1.9.3
            exports.util.getEllipsoidTerrain = layer.getEllipsoidTerrain; //1.9.3
            exports.util.getTerrainProvider = layer.getTerrainProvider; //1.9.3

            //移动了方法
            exports.point.computePolygonHeightRange = polygon.getHeightRange; //2.0.2
            exports.point.updateHeightForClampToGround = point.setPositionSurfaceHeight; //2.0.2 
            exports.point.terrainPolyline = polyline.computeSurfaceLine; //2.0.2 
            exports.util.getLinkedPointList = polyline.getLinkedPointList; //2.0.2 


            //打印信息
            util.printVersion();

            /***/
}),
/* 75 */
/***/ (function (module, exports, __webpack_require__) {

            // extracted by mini-css-extract-plugin

            /***/
}),
/* 76 */
/***/ (function (module, exports, __webpack_require__) {

            // extracted by mini-css-extract-plugin

            /***/
}),
/* 77 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.BaseWidget = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _zepto = __webpack_require__(6);

            var _loader = __webpack_require__(45);

            var _widgetManager = __webpack_require__(44);

            var _MapVClass = __webpack_require__(23);

            var _util = __webpack_require__(1);

            var _resources_cache = [];

            var BaseWidget = exports.BaseWidget = _MapVClass.MapVClass.extend({
                viewer: null,
                options: {},
                config: {}, //配置的config信息 
                path: "", //当前widget目录相对路径 
                isActivate: false, //是否激活状态
                isCreate: false,
                initialize: function initialize(cfg, map) {
                    this.viewer = map;
                    this.config = cfg;
                    this.path = cfg.path || '';
                    this.init();
                },
                addCacheVersion: function addCacheVersion(_resource) {
                    if (_resource == null) return _resource;

                    var cacheVersion = (0, _widgetManager.getCacheVersion)();
                    if (cacheVersion) {
                        if (_resource.indexOf('?') == -1) _resource += "?time=" + cacheVersion; else if (_resource.indexOf('time=' + cacheVersion) == -1) _resource += "&time=" + cacheVersion;
                    }
                    return _resource;
                },
                //激活插件
                activateBase: function activateBase() {
                    var that = this;

                    if (this.isActivate) {
                        //已激活状态时跳出 
                        this.changeWidgetView(function (viewopt) {
                            if (viewopt._dom) {
                                //将层置顶
                                (0, _zepto.zepto)(".layui-layer").each(function () {
                                    (0, _zepto.zepto)(this).css("z-index", 19891000);
                                });
                                (0, _zepto.zepto)(viewopt._dom).css("z-index", 19891014);
                            }
                        });
                        return;
                    }

                    this.beforeActivate();
                    this.isActivate = true;
                    //console.log('激活widget:' + this.config.uri);

                    if (!this.isCreate) {
                        //首次进行创建 
                        if (this.options.resources && this.options.resources.length > 0) {
                            var resources = [];

                            for (var i = 0; i < this.options.resources.length; i++) {
                                var _resource = this.options.resources[i];
                                _resource = this._getUrl(_resource);

                                if (_resources_cache.indexOf(_resource) != -1) continue; //不加重复资源

                                resources.push(_resource);
                            }
                            _resources_cache = _resources_cache.concat(resources); //不加重复资源

                            _loader.Loader.async(resources, function () {
                                var result = that.create(function () {
                                    that._createWidgetView();
                                    that.isCreate = true;
                                });
                                if (result) return;
                                if (that.config.createAtStart) {
                                    that.config.createAtStart = false;
                                    that.isActivate = false;
                                    that.isCreate = true;
                                    return;
                                }
                                that._createWidgetView();
                                that.isCreate = true;
                            });
                            return;
                        } else {
                            var result = this.create(function () {
                                that._createWidgetView();
                                this.isCreate = true;
                            });
                            if (result) return;
                            if (that.config.createAtStart) {
                                that.config.createAtStart = false;
                                that.isActivate = false;
                                that.isCreate = true;
                                return;
                            }
                        }
                        this.isCreate = true;
                    }
                    this._createWidgetView();

                    return this;
                },
                //创建插件的view
                _createWidgetView: function _createWidgetView() {
                    var viewopt = this.options.view;
                    if (viewopt === undefined || viewopt === null) {
                        this._startActivate();
                    } else if ((0, _util.isArray)(viewopt)) {
                        this._viewcreate_allcount = viewopt.length;
                        this._viewcreate_okcount = 0;

                        for (var i = 0; i < viewopt.length; i++) {
                            this.createItemView(viewopt[i]);
                        }
                    } else {
                        this._viewcreate_allcount = 1;
                        this._viewcreate_okcount = 0;
                        this.createItemView(viewopt);
                    }
                },
                changeWidgetView: function changeWidgetView(calback) {
                    var viewopt = this.options.view;
                    if (viewopt === undefined || viewopt === null) {
                        return false;
                    } else if ((0, _util.isArray)(viewopt)) {
                        var hascal = false;
                        for (var i = 0; i < viewopt.length; i++) {
                            hascal = hascal || calback(viewopt[i]);
                        }
                        return hascal;
                    } else {
                        return calback(viewopt);
                    }
                },
                createItemView: function createItemView(viewopt) {
                    switch (viewopt.type) {
                        default:
                        case "window":
                            this._openWindow(viewopt);
                            break;
                        case "divwindow":
                            this._openDivWindow(viewopt);
                            break;
                        case "append":
                            var view_url = this._getUrl(viewopt.url);
                            var that = this;
                            that.getHtml(view_url, function (html) {
                                that._appendView(viewopt, html);
                            });
                            break;
                        case "custom":
                            //自定义 
                            var view_url = this._getUrl(viewopt.url);

                            var that = this;
                            viewopt.open(view_url, function (html) {
                                that.winCreateOK(viewopt, html);

                                that._viewcreate_okcount++;
                                if (that._viewcreate_okcount >= that._viewcreate_allcount) {
                                    that._startActivate(html);
                                }
                            }, this);
                            break;
                    }
                },
                _viewcreate_allcount: 0,
                _viewcreate_okcount: 0,
                //==============layer弹窗================= 
                _openWindow: function _openWindow(viewopt) {
                    var that = this;
                    var view_url = this._getUrl(viewopt.url);

                    var opts = {
                        type: 2,
                        content: [view_url, 'no'],
                        success: function success(layero) {
                            viewopt._layerOpening = false;
                            viewopt._dom = layero;

                            //得到iframe页的窗口对象，执行iframe页的方法：viewWindow.method();
                            var viewWindow = window[layero.find('iframe')[0]['name']];

                            //设置css
                            if (that.config.css) (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(that.config.css);

                            //隐藏弹窗
                            if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

                            layer.setTop(layero);
                            that.winCreateOK(viewopt, viewWindow);

                            that._viewcreate_okcount++;
                            if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);

                            //通知页面,页面需要定义initWidgetView方法
                            if (viewWindow && viewWindow.initWidgetView) viewWindow.initWidgetView(that); else console.error("" + view_url + "页面没有定义function initWidgetView(widget)方法，无法初始化widget页面!");
                        }
                    };
                    if (viewopt._layerIdx > 0) {
                        //debugger
                    }

                    viewopt._layerOpening = true;
                    viewopt._layerIdx = layer.open(this._getWinOpt(viewopt, opts));
                },
                _openDivWindow: function _openDivWindow(viewopt) {
                    var view_url = this._getUrl(viewopt.url);
                    //div弹窗
                    var that = this;
                    this.getHtml(view_url, function (data) {
                        var opts = {
                            type: 1,
                            content: data,
                            success: function success(layero) {
                                viewopt._layerOpening = false;
                                viewopt._dom = layero;

                                //隐藏弹窗
                                if (that.config.hasOwnProperty("visible") && !that.config.visible) (0, _zepto.zepto)(layero).hide();

                                layer.setTop(layero);
                                that.winCreateOK(viewopt, layero);

                                that._viewcreate_okcount++;
                                if (that._viewcreate_okcount >= that._viewcreate_allcount) that._startActivate(layero);
                            }
                        };
                        viewopt._layerOpening = true;
                        viewopt._layerIdx = layer.open(that._getWinOpt(viewopt, opts));
                    });
                },
                _getUrl: function _getUrl(url) {
                    url = this.addCacheVersion(url);

                    if (url.startsWith("/") || url.startsWith(".") || url.startsWith("http")) return url; else return this.path + url;
                },
                _getWinOpt: function _getWinOpt(viewopt, opts) {
                    //优先使用cofig中配置，覆盖js中的定义 
                    var def = (0, _widgetManager.getDefWindowOptions)();
                    var windowOptions = _zepto.zepto.extend(def, viewopt.windowOptions);
                    windowOptions = _zepto.zepto.extend(windowOptions, this.config.windowOptions);
                    viewopt.windowOptions = windowOptions; //赋值 

                    var that = this;
                    var _size = this._getWinSize(windowOptions);

                    var title = false;
                    if (!windowOptions.noTitle) {
                        title = this.config.name || ' ';
                        if (this.config.icon) {
                            title = '<i class="' + this.config.icon + '" ></i>&nbsp;' + title;
                        }
                    }

                    //默认值
                    var defOpts = {
                        title: title,
                        area: _size.area,
                        offset: _size.offset,
                        shade: 0,
                        maxmin: false,
                        beforeEnd: function beforeEnd() {
                            that.beforeDisable();
                        },
                        end: function end() {
                            // 销毁后触发的回调
                            viewopt._layerIdx = -1;
                            viewopt._dom = null;
                            that.disableBase(true);
                        },
                        full: function full(dom) {
                            //最大化后触发的回调
                            that.winFull(dom);
                        },
                        min: function min(dom) {
                            //最小化后触发的回调
                            that.winMin(dom);
                        },
                        restore: function restore(dom) {
                            //还原 后触发的回调
                            that.winRestore(dom);
                        }
                    };
                    var cfgOpts = _zepto.zepto.extend(defOpts, windowOptions);
                    return _zepto.zepto.extend(cfgOpts, opts || {});
                },
                //计算弹窗大小和位置
                _getWinSize: function _getWinSize(windowOptions) {
                    //获取高宽 
                    var _width = this.bfb2Number(windowOptions.width, document.documentElement.clientWidth, windowOptions);
                    var _height = this.bfb2Number(windowOptions.height, document.documentElement.clientHeight, windowOptions);

                    //计算位置offset
                    var offset = '';
                    var position = windowOptions.position;
                    if (position) {
                        if (typeof position == "string") {
                            //t顶部,b底部,r右边缘,l左边缘,lt左上角,lb左下角,rt右上角,rb右下角
                            offset = position;
                        } else if ((typeof position === 'undefined' ? 'undefined' : _typeof(position)) == "object") {
                            var _top;
                            var _left;

                            if (position.hasOwnProperty("top") && position.top != null) {
                                _top = this.bfb2Number(position.top, document.documentElement.clientHeight, windowOptions);
                            }
                            if (position.hasOwnProperty("bottom") && position.bottom != null) {
                                windowOptions._hasresize = true;

                                var _bottom = this.bfb2Number(position.bottom, document.documentElement.clientHeight, windowOptions);

                                if (_top != null) {
                                    _height = document.documentElement.clientHeight - _top - _bottom;
                                } else {
                                    _top = document.documentElement.clientHeight - _height - _bottom;
                                }
                            }

                            if (position.hasOwnProperty("left") && position.left != null) {
                                _left = this.bfb2Number(position.left, document.documentElement.clientWidth, windowOptions);
                            }
                            if (position.hasOwnProperty("right") && position.right != null) {
                                windowOptions._hasresize = true;
                                var _right = this.bfb2Number(position.right, document.documentElement.clientWidth, windowOptions);

                                if (_left != null) {
                                    _width = document.documentElement.clientWidth - _left - _right;
                                } else {
                                    _left = document.documentElement.clientWidth - _width - _right;
                                }
                            }

                            if (_top == null) _top = (document.documentElement.clientHeight - _height) / 2;
                            if (_left == null) _left = (document.documentElement.clientWidth - _width) / 2;

                            offset = [_top + 'px', _left + 'px'];
                        }
                    }

                    //最大最小高度判断
                    if (windowOptions.hasOwnProperty("minHeight") && _height < windowOptions.minHeight) {
                        windowOptions._hasresize = true;
                        _height = windowOptions.minHeight;
                    }
                    if (windowOptions.hasOwnProperty("maxHeight") && _height > windowOptions.maxHeight) {
                        windowOptions._hasresize = true;
                        _height = windowOptions.maxHeight;
                    }

                    //最大最小宽度判断
                    if (windowOptions.hasOwnProperty("minHeight") && _width < windowOptions.minWidth) {
                        windowOptions._hasresize = true;
                        _width = windowOptions.minWidth;
                    }
                    if (windowOptions.hasOwnProperty("maxWidth") && _width > windowOptions.maxWidth) {
                        windowOptions._hasresize = true;
                        _width = windowOptions.maxWidth;
                    }

                    var area;
                    if (_width && _height) area = [_width + 'px', _height + 'px']; else area = _width + 'px';

                    return { area: area, offset: offset };
                },
                bfb2Number: function bfb2Number(str, allnum, windowOptions) {
                    if (typeof str == 'string' && str.indexOf("%") != -1) {
                        windowOptions._hasresize = true;

                        return allnum * Number(str.replace("%", "")) / 100;
                    }
                    return str;
                },
                //==============直接添加到index上=================  
                _appendView: function _appendView(viewopt, html) {
                    viewopt._dom = (0, _zepto.zepto)(html).appendTo(viewopt.parent || 'body');

                    //设置css
                    if (this.config.css) (0, _zepto.zepto)(viewopt._dom).css(this.config.css);

                    this.winCreateOK(viewopt, html);

                    this._viewcreate_okcount++;
                    if (this._viewcreate_okcount >= this._viewcreate_allcount) this._startActivate(html);
                },

                //释放插件
                disableBase: function disableBase(nobefore) {
                    if (!this.isActivate) return;

                    if (!nobefore) this.beforeDisable();

                    var has = this.changeWidgetView(function (viewopt) {
                        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                            if (viewopt._layerOpening) {
                                //窗口还在加载中
                                //console.log('释放widget窗口还在加载中:' + viewopt._layerIdx);
                            }
                            layer.close(viewopt._layerIdx);
                            return true;
                        } else {
                            if (viewopt.type == "append" && viewopt._dom) {
                                viewopt._dom.remove();
                                viewopt._dom = null;
                            }
                            if (viewopt.type == "custom" && viewopt.close) {
                                viewopt.close();
                            }
                            return false;
                        }
                    });
                    if (has) return;

                    this.disable();
                    this.isActivate = false;

                    //还原配置为初始状态
                    if (this.config.autoReset) {
                        this.resetConfig();
                    }

                    //console.log('释放widget:' + this.config.uri);
                },
                //还原配置为初始状态
                resetConfig: function resetConfig() {
                    if (this.config._firstConfigBak) {
                        var _backData = this.config._firstConfigBak;
                        for (var aa in _backData) {
                            if (aa == "uri") continue;
                            this.config[aa] = _backData[aa];
                        }
                    }
                },
                //设置view弹窗的显示和隐藏
                setViewVisible: function setViewVisible(visible) {
                    this.changeWidgetView(function (viewopt) {
                        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                            if (visible) {
                                (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).show();
                            } else {
                                (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).hide();
                            }
                        } else if (viewopt.type == "append" && viewopt._dom) {
                            if (visible) (0, _zepto.zepto)(viewopt._dom).show(); else (0, _zepto.zepto)(viewopt._dom).hide();
                        }
                    });
                },
                //设置view弹窗的css
                setViewCss: function setViewCss(style) {
                    this.changeWidgetView(function (viewopt) {
                        if (viewopt._layerIdx != null && viewopt._layerIdx != -1) {
                            (0, _zepto.zepto)("#layui-layer" + viewopt._layerIdx).css(style);
                        } else if (viewopt.type == "append" && viewopt._dom) {
                            (0, _zepto.zepto)(viewopt._dom).css(style);
                        }
                    });
                },
                //主窗体改变大小后触发
                indexResize: function indexResize() {
                    if (!this.isActivate) return;

                    var that = this;
                    this.changeWidgetView(function (viewopt) {
                        if (viewopt._layerIdx == null || viewopt._layerIdx == -1 || viewopt.windowOptions == null || !viewopt.windowOptions._hasresize) return;

                        var _size = that._getWinSize(viewopt.windowOptions);

                        var _style = {};
                        if ((0, _util.isArray)(_size.area)) {
                            if (_size.area[0]) _style.width = _size.area[0];
                            if (_size.area[1]) _style.height = _size.area[1];
                        }

                        if ((0, _util.isArray)(_size.offset)) {
                            if (_size.offset[1]) _style.top = _size.offset[0];
                            if (_size.offset[1]) _style.left = _size.offset[1];
                        }
                        (0, _zepto.zepto)(viewopt._dom).attr("myTopLeft", true);
                        layer.style(viewopt._layerIdx, _style);

                        if (viewopt.type == "divwindow") layer.iframeAuto(viewopt._layerIdx);
                    });
                },
                _startActivate: function _startActivate(layero) {
                    this.activate(layero);
                    if (this.config.success) {
                        this.config.success(this);
                    }
                    if (!this.isActivate) {
                        //窗口打开中没加载完成时，被释放
                        this.disableBase();
                    }
                },
                //子类继承后覆盖 
                init: function init() { },
                //子类继承后覆盖 
                create: function create(endfun) { },
                //子类继承后覆盖
                beforeActivate: function beforeActivate() { },
                activate: function activate(layero) { },

                //子类继承后覆盖
                beforeDisable: function beforeDisable() { },
                disable: function disable() { },

                //子类继承后覆盖 
                winCreateOK: function winCreateOK(opt, result) { },
                //窗口最大化后触发
                winFull: function winFull() { },
                //窗口最小化后触发
                winMin: function winMin() { },
                //窗口还原 后触发
                winRestore: function winRestore() { },

                //公共方法
                getHtml: function getHtml(url, callback) {
                    _zepto.zepto.ajax({
                        url: url,
                        type: "GET",
                        dataType: 'html',
                        timeout: 0, //永不超时
                        success: function success(data) {
                            callback(data);
                        }
                    });
                }

            });

            /***/
}),
/* 78 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.createMap = createMap;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _util2 = __webpack_require__(1);

            var _util = _interopRequireWildcard(_util2);

            var _ViewerEx = __webpack_require__(46);

            var _GaodePOIGeocoder = __webpack_require__(115);

            var _layer2 = __webpack_require__(20);

            var _layer = _interopRequireWildcard(_layer2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function createMap(opt) {

                if (opt.url) {
                    _zepto.zepto.ajax({
                        type: "get",
                        dataType: "json",
                        url: opt.url,
                        timeout: 0, //永不超时
                        success: function success(config) {
                            if (config.serverURL) opt.serverURL = config.serverURL;

                            //map初始化 
                            var viewer = initMap(config.map3d, opt);
                            if (opt.success) opt.success(viewer, config, config); //第2个config为了兼容1.7以前版本
                        },
                        error: function error(XMLHttpRequest, textStatus, errorThrown) {
                            console.log(opt.url + "文件加载失败！");
                            _util.alert(opt.url + "文件加载失败！");
                        }
                    });
                    return null;
                } else {
                    var viewer = initMap(opt.data, opt);
                    if (opt.success) opt.success(viewer, opt.data);
                    return viewer;
                }
            }

            function initMap(config, optsWB) {
                var id = optsWB.id;

                //数据优先级：optsWB > config > opts 

                //如果options未设置时的默认参数
                var opts = {
                    animation: false, //是否创建动画小器件，左下角仪表   
                    timeline: false, //是否显示时间线控件   
                    fullscreenButton: true, //右下角全屏按钮
                    vrButton: false, //右下角vr虚拟现实按钮

                    geocoder: false, //是否显示地名查找控件   
                    sceneModePicker: false, //是否显示投影方式控件  
                    homeButton: true, //回到默认视域按钮
                    navigationHelpButton: true, //是否显示帮助信息控件  
                    navigationInstructionsInitiallyVisible: false, //在用户明确单击按钮之前是否自动显示

                    infoBox: true, //是否显示点击要素之后显示的信息 
                    selectionIndicator: false, //选择模型是是否显示绿色框, 
                    shouldAnimate: true,
                    showRenderLoopErrors: true, //是否显示错误弹窗信息

                    baseLayerPicker: false, //地图底图
                    contextmenu: true //右键菜单
                };

                //config中可以配置map所有options
                for (var key in config) {
                    opts[key] = config[key];
                }
                //wboptions中可以配置map所有options覆盖

                for (var key in optsWB) {
                    if (key === "id" || key === "success") continue;
                    opts[key] = optsWB[key];
                }

                //一些默认值的修改【by LYW】
                if (Cesium.Ion) Cesium.Ion.defaultAccessToken = opts.ionToken || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI1NjM5MjMxOS1lMWVkLTQyNDQtYTM4Yi0wZjA4ZDMxYTlmNDMiLCJpZCI6MTQ4MiwiaWF0IjoxNTI4Njc3NDQyfQ.vVoSexHMqQhKK5loNCv6gCA5d5_z3wE2M0l_rWnIP_w';
                Cesium.AnimationViewModel.defaultTicks = opts.animationTicks || [0.1, 0.25, 0.5, 1.0, 2.0, 5.0, 10.0, 15.0, 30.0, 60.0, 120.0, 300.0, 600.0, 900.0, 1800.0, 3600.00];

                //自定义搜索栏Geocoder
                if (opts.geocoder === true) {
                    opts.geocoder = new _GaodePOIGeocoder.GaodePOIGeocoder(opts.geocoderConfig);
                }

                //地形
                var terrainProvider;
                if (opts.terrain && opts.terrain.visible) {
                    terrainProvider = getTerrainProvider(opts.terrain, opts.serverURL);
                    opts.terrainProvider = terrainProvider;
                } else {
                    opts.terrainProvider = _layer.getEllipsoidTerrain();
                }

                //地图底图图层预处理   
                var hasremoveimagery = false;
                if (opts.baseLayerPicker) {
                    //有baseLayerPicker插件时
                    if (!opts.imageryProviderViewModels && opts.basemaps && opts.basemaps.length > 0) {
                        var imgOBJ = getImageryProviderArr(opts.basemaps);
                        opts.imageryProviderViewModels = imgOBJ.imageryProviderViewModels;
                        opts.selectedImageryProviderViewModel = imgOBJ.imageryProviderViewModels[imgOBJ.index];
                    }

                    if (!opts.terrainProviderViewModels) {
                        opts.terrainProviderViewModels = getTerrainProviderViewModelsArr(opts.terrain, opts.serverURL);
                        opts.selectedTerrainProviderViewModel = opts.terrainProviderViewModels[1];
                    }
                } else {
                    //无baseLayerPicker插件时
                    if (opts.imageryProvider == null) {
                        //未配底图时
                        hasremoveimagery = true;
                        opts.imageryProvider = new Cesium.TileMapServiceImageryProvider({
                            url: Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII')
                        });
                    }
                }

                //地球初始化
                var viewer = new Cesium.Viewer(id, opts);

                //地图底图图层 
                if (hasremoveimagery) {
                    var imageryLayerCollection = viewer.imageryLayers;
                    var length = imageryLayerCollection.length;
                    for (var i = 0; i < length; i++) {
                        var layer = imageryLayerCollection.get(0);
                        imageryLayerCollection.remove(layer, true);
                    }
                }
                if (opts.geocoder) {
                    opts.geocoder.viewer = viewer;
                }

                delete opts.geocoder;
                delete opts.imageryProviderViewModels;
                delete opts.selectedImageryProviderViewModel;
                delete opts.terrainProviderViewModels;
                delete opts.selectedTerrainProviderViewModel;
                delete opts.terrainProvider;
                delete opts.imageryProvider;

                viewer.mapv = new _ViewerEx.ViewerEx(viewer, opts); //图洋扩展的viewer支持

                viewer.mapv.terrainProvider = terrainProvider;
                viewer.gisdata = {
                    config: viewer.mapv.config //兼容1.7以前的历史版本属性

                }; return viewer;
            };

            //获取配置的地形 
            function getTerrainProvider(cfg, serverURL) {
                if (cfg && cfg.url) {
                    if (serverURL) {
                        cfg.url = cfg.url.replace('$serverURL$', serverURL);
                    }
                    cfg.url = cfg.url.replace('$hostname$', location.hostname).replace('$host$', location.host);
                }

                return _layer.getTerrainProvider(cfg);
            }

            //获取自定义底图切换
            function getImageryProviderArr(layersCfg) {
                var providerViewModels = [];
                var selectedIndex = 0;

                window._temp_createImageryProvider = _layer.createImageryProvider;

                for (var i = 0; i < layersCfg.length; i++) {
                    var item = layersCfg[i];
                    if (item.type == "group" && item.layers == null) continue;

                    if (item.visible) selectedIndex = providerViewModels.length;

                    var funstr = 'window._temp_mapv_basemaps' + i + ' = function () {\
                        var item = ' + JSON.stringify(item) + ';\
                        if (item.type == "group") {\
                            var arrVec = [];\
                            for (var index = 0; index < item.layers.length; index++) {\
                                var temp = window._temp_createImageryProvider(item.layers[index]);\
                                if (temp == null) continue;\
                                arrVec.push(temp);\
                            }\
                            return arrVec;\
                        }\
                        else {\
                            return window._temp_createImageryProvider(item);\
                        } \
                    }';
                    eval(funstr);

                    var imgModel = new Cesium.ProviderViewModel({
                        name: item.name || "未命名",
                        tooltip: item.name || "未命名",
                        iconUrl: item.icon || "",
                        creationFunction: eval('window._temp_mapv_basemaps' + i)
                    });
                    providerViewModels.push(imgModel);
                }

                return {
                    imageryProviderViewModels: providerViewModels,
                    index: selectedIndex
                };
            }

            function getTerrainProviderViewModelsArr(cfg, serverURL) {
                return [new Cesium.ProviderViewModel({
                    name: '无地形',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/Ellipsoid.png'),
                    tooltip: 'WGS84标准椭球，即 EPSG:4326',
                    category: '',
                    creationFunction: function creationFunction() {
                        return _layer.getEllipsoidTerrain();
                    }
                }), new Cesium.ProviderViewModel({
                    name: 'MapVGIS 中国地形',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
                    tooltip: 'MapVGIS提供的高分辨率中国地形',
                    category: '',
                    creationFunction: function creationFunction() {
                        return getTerrainProvider(cfg, serverURL);
                    }
                }), new Cesium.ProviderViewModel({
                    name: 'Cesium Ion 全球地形',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
                    tooltip: 'Cesium官方Ion提供的高分辨率全球地形',
                    category: '',
                    creationFunction: function creationFunction() {
                        return _layer.getTerrainProvider({
                            type: 'ion'
                        });;
                    }
                }), new Cesium.ProviderViewModel({
                    name: 'ArcGIS 全球地形',
                    iconUrl: Cesium.buildModuleUrl('Widgets/Images/TerrainProviders/CesiumWorldTerrain.png'),
                    tooltip: 'arcgis官方提供的高分辨率全球地形',
                    category: '',
                    creationFunction: function creationFunction() {
                        return _layer.getTerrainProvider({
                            "type": "arcgis",
                            "url": 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer'
                        });;
                    }
                })];
            }

            /***/
}),
/* 79 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Evented = exports.Events = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _MapVClass = __webpack_require__(23);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            /*
             * @class Evented
             * @aka Evented
             * @inherits MapVClass
             *
             * A set of methods shared between event-powered classes (like `Map` and `Marker`). Generally, events allow you to execute some function when something happens with an object (e.g. the user clicks on the map, causing the map to fire `'click'` event).
             *
             * @example
             *
             * ```js
             * map.on('click', function(e) {
             * 	alert(e.latlng);
             * } );
             * ```
             *
             * Leaflet deals with event listeners by reference, so if you want to add a listener and then remove it, define it as a function:
             *
             * ```js
             * function onClick(e) { ... }
             *
             * map.on('click', onClick);
             * map.off('click', onClick);
             * ```
             */

            var Events = exports.Events = {
                /* @method on(type: String, fn: Function, context?: Object): this
              * Adds a listener function (`fn`) to a particular event type of the object. You can optionally specify the context of the listener (object the this keyword will point to). You can also pass several space-separated types (e.g. `'click dblclick'`).
              *
              * @alternative
              * @method on(eventMap: Object): this
              * Adds a set of type/listener pairs, e.g. `{click: onClick, mousemove: onMouseMove}`
              */
                on: function on(types, fn, context) {

                    // types can be a map of types/handlers
                    if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
                        for (var type in types) {
                            // we don't process space-separated events here for performance;
                            // it's a hot path since Layer uses the on(obj) syntax
                            this._on(type, types[type], fn);
                        }
                    } else {
                        // types can be a string of space-separated words
                        types = Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._on(types[i], fn, context);
                        }
                    }

                    return this;
                },

                /* @method off(type: String, fn?: Function, context?: Object): this
              * Removes a previously added listener function. If no function is specified, it will remove all the listeners of that particular event from the object. Note that if you passed a custom context to `on`, you must pass the same context to `off` in order to remove the listener.
              *
              * @alternative
              * @method off(eventMap: Object): this
              * Removes a set of type/listener pairs.
              *
              * @alternative
              * @method off: this
              * Removes all listeners to all events on the object.
              */
                off: function off(types, fn, context) {

                    if (!types) {
                        // clear all listeners if called without arguments
                        delete this._events;
                    } else if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
                        for (var type in types) {
                            this._off(type, types[type], fn);
                        }
                    } else {
                        types = Util.splitWords(types);

                        for (var i = 0, len = types.length; i < len; i++) {
                            this._off(types[i], fn, context);
                        }
                    }

                    return this;
                },

                // attach listener (without syntactic sugar now)
                _on: function _on(type, fn, context) {
                    this._events = this._events || {};

                    /* get/init listeners for type */
                    var typeListeners = this._events[type];
                    if (!typeListeners) {
                        typeListeners = [];
                        this._events[type] = typeListeners;
                    }

                    if (context === this) {
                        // Less memory footprint.
                        context = undefined;
                    }
                    var newListener = { fn: fn, ctx: context },
                        listeners = typeListeners;

                    // check if fn already there
                    for (var i = 0, len = listeners.length; i < len; i++) {
                        if (listeners[i].fn === fn && listeners[i].ctx === context) {
                            return;
                        }
                    }

                    listeners.push(newListener);
                },

                _off: function _off(type, fn, context) {
                    var listeners, i, len;

                    if (!this._events) {
                        return;
                    }

                    listeners = this._events[type];

                    if (!listeners) {
                        return;
                    }

                    if (!fn) {
                        // Set all removed listeners to noop so they are not called if remove happens in fire
                        for (i = 0, len = listeners.length; i < len; i++) {
                            listeners[i].fn = Util.falseFn;
                        }
                        // clear all listeners for a type if function isn't specified
                        delete this._events[type];
                        return;
                    }

                    if (context === this) {
                        context = undefined;
                    }

                    if (listeners) {

                        // find fn and remove it
                        for (i = 0, len = listeners.length; i < len; i++) {
                            var l = listeners[i];
                            if (l.ctx !== context) {
                                continue;
                            }
                            if (l.fn === fn) {

                                // set the removed listener to noop so that's not called if remove happens in fire
                                l.fn = Util.falseFn;

                                if (this._firingCount) {
                                    /* copy array in case events are being fired */
                                    this._events[type] = listeners = listeners.slice();
                                }
                                listeners.splice(i, 1);

                                return;
                            }
                        }
                    }
                },

                // @method fire(type: String, data?: Object, propagate?: Boolean): this
                // Fires an event of the specified type. You can optionally provide an data
                // object — the first argument of the listener function will contain its
                // properties. The event can optionally be propagated to event parents.
                fire: function fire(type, data, propagate) {
                    if (!this.listens(type, propagate)) {
                        return this;
                    }

                    var event = Util.extend({}, data, {
                        type: type,
                        target: this,
                        sourceTarget: data && data.sourceTarget || this
                    });

                    if (this._events) {
                        var listeners = this._events[type];

                        if (listeners) {
                            this._firingCount = this._firingCount + 1 || 1;
                            for (var i = 0, len = listeners.length; i < len; i++) {
                                var l = listeners[i];
                                l.fn.call(l.ctx || this, event);
                            }

                            this._firingCount--;
                        }
                    }

                    if (propagate) {
                        // propagate the event to parents (set with addEventParent)
                        this._propagateEvent(event);
                    }

                    return this;
                },

                // @method listens(type: String): Boolean
                // Returns `true` if a particular event type has any listeners attached to it.
                listens: function listens(type, propagate) {
                    var listeners = this._events && this._events[type];
                    if (listeners && listeners.length) {
                        return true;
                    }

                    if (propagate) {
                        // also check parents for listeners if event propagates
                        for (var id in this._eventParents) {
                            if (this._eventParents[id].listens(type, propagate)) {
                                return true;
                            }
                        }
                    }
                    return false;
                },

                // @method once(…): this
                // Behaves as [`on(…)`](#evented-on), except the listener will only get fired once and then removed.
                once: function once(types, fn, context) {

                    if ((typeof types === 'undefined' ? 'undefined' : _typeof(types)) === 'object') {
                        for (var type in types) {
                            this.once(type, types[type], fn);
                        }
                        return this;
                    }

                    var handler = Util.bind(function () {
                        this.off(types, fn, context).off(types, handler, context);
                    }, this);

                    // add a listener that's executed once and removed after that
                    return this.on(types, fn, context).on(types, handler, context);
                },

                // @method addEventParent(obj: Evented): this
                // Adds an event parent - an `Evented` that will receive propagated events
                addEventParent: function addEventParent(obj) {
                    this._eventParents = this._eventParents || {};
                    this._eventParents[Util.stamp(obj)] = obj;
                    return this;
                },

                // @method removeEventParent(obj: Evented): this
                // Removes an event parent, so it will stop receiving propagated events
                removeEventParent: function removeEventParent(obj) {
                    if (this._eventParents) {
                        delete this._eventParents[Util.stamp(obj)];
                    }
                    return this;
                },

                _propagateEvent: function _propagateEvent(e) {
                    for (var id in this._eventParents) {
                        this._eventParents[id].fire(e.type, Util.extend({
                            layer: e.target,
                            propagatedFrom: e.target
                        }, e), true);
                    }
                }
            };

            // aliases; we should ditch those eventually

            // @method addEventListener(…): this
            // Alias to [`on(…)`](#evented-on)
            Events.addEventListener = Events.on;

            // @method removeEventListener(…): this
            // Alias to [`off(…)`](#evented-off)

            // @method clearAllEventListeners(…): this
            // Alias to [`off()`](#evented-off)
            Events.removeEventListener = Events.clearAllEventListeners = Events.off;

            // @method addOneTimeEventListener(…): this
            // Alias to [`once(…)`](#evented-once)
            Events.addOneTimeEventListener = Events.once;

            // @method fireEvent(…): this
            // Alias to [`fire(…)`](#evented-fire)
            Events.fireEvent = Events.fire;

            // @method hasEventListeners(…): Boolean
            // Alias to [`listens(…)`](#evented-listens)
            Events.hasEventListeners = Events.listens;

            var Evented = exports.Evented = _MapVClass.MapVClass.extend(Events);

            /***/
}),
/* 80 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = repeat * materialInput.st;\r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - time), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material;\r\n}"

            /***/
}),
/* 81 */
/***/ (function (module, exports) {

            module.exports = "//2个图片的叠加融合\r\nczm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\nczm_material material = czm_getDefaultMaterial(materialInput);\r\nvec2 st = repeat * materialInput.st;\r\nvec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - time), st.t));\r\nif(color.a == 0.0)\r\n{\r\n    material.alpha = colorImage.a;\r\n    material.diffuse = colorImage.rgb; \r\n}\r\nelse\r\n{\r\n    material.alpha = colorImage.a * color.a;\r\n    material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n}\r\nvec4 colorBG = texture2D(image2,materialInput.st);\r\nif(colorBG.a>0.5){\r\n    material.diffuse = bgColor.rgb;\r\n}\r\nreturn material;\r\n}"

            /***/
}),
/* 82 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    material.diffuse = 1.5 * color.rgb;\r\n    vec2 st = materialInput.st;\r\n    vec3 str = materialInput.str;\r\n    float dis = distance(st, vec2(0.5, 0.5));\r\n    float per = fract(time);\r\n    if(abs(str.z)>0.001){\r\n        discard;\r\n    }\r\n    if(dis >0.5){\r\n        discard;\r\n    }else {\r\n        float perDis = 0.5/count;\r\n        float disNum;\r\n        float bl = .0;\r\n        for(int i=0;i<=999;i++){\r\n            if(float(i)<=count){\r\n                disNum = perDis*float(i) - dis + per/count;\r\n                if(disNum>0.0){\r\n                    if(disNum<perDis){\r\n                        bl = 1.0-disNum/perDis;\r\n                    }\r\n                    else if(disNum-perDis<perDis){\r\n                        bl = 1.0 - abs(1.0-disNum/perDis);\r\n                    }\r\n                    material.alpha = pow(bl,gradient);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return material;\r\n}"

            /***/
}),
/* 83 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GroupLayer = undefined;

            var _BaseLayer = __webpack_require__(13);

            var GroupLayer = _BaseLayer.BaseLayer.extend({
                create: function create() {
                    this._layers = this.config._layers;
                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        this.hasOpacity = arr[i].hasOpacity;
                        this.hasZIndex = arr[i].hasZIndex;
                    }
                },
                setVisible: function setVisible(val) {
                    this._visible = val;

                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        arr[i].setVisible(val);
                    }
                },
                //添加 
                add: function add() {
                    this._visible = true;

                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        arr[i].setVisible(true);
                    }
                },
                //移除
                remove: function remove() {
                    this._visible = false;

                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        arr[i].setVisible(false);
                    }
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        arr[i].centerAt(duration);
                    }
                },
                //设置透明度
                setOpacity: function setOpacity(value) {
                    var arr = this._layers;
                    for (var i = 0, len = arr.length; i < len; i++) {
                        if (!arr[i].hasOpacity) continue;
                        arr[i].setOpacity(value);
                    }
                }

                //设置叠加顺序
                //setZIndex: function (value) {
                //    var arr = this.config._layers;
                //    for (var i = 0; i < arr.length; i++) {
                //        arr[i].setZIndex(value);
                //    }
                //},


            });

            exports.GroupLayer = GroupLayer;

            /***/
}),
/* 84 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GraticuleLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _BaseLayer = __webpack_require__(13);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var GraticuleLayer = _BaseLayer.BaseLayer.extend({
                model: null,
                //添加 
                add: function add() {
                    if (this.model == null) {
                        this.initData();
                    }
                    this.model.setVisible(true);
                },
                //移除
                remove: function remove() {
                    if (this.model == null) return;

                    this.model.setVisible(false);
                },

                initData: function initData() {
                    function GraticuleLayer(description, scene) {

                        description = description || {};

                        this._tilingScheme = description.tilingScheme || new Cesium.GeographicTilingScheme();

                        this._color = description.color || new Cesium.Color(1.0, 1.0, 1.0, 0.4);

                        this._tileWidth = description.tileWidth || 256;
                        this._tileHeight = description.tileHeight || 256;

                        this._ready = true;

                        // default to decimal intervals
                        this._sexagesimal = description.sexagesimal || false;
                        this._numLines = description.numLines || 50;

                        this._scene = scene;
                        this._labels = new Cesium.LabelCollection();
                        scene.primitives.add(this._labels);
                        this._polylines = new Cesium.PolylineCollection();
                        scene.primitives.add(this._polylines);
                        this._ellipsoid = scene.globe.ellipsoid;

                        var canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 256;
                        this._canvas = canvas;

                        var that = this;
                        scene.camera.moveEnd.addEventListener(function () {
                            if (!that._show) return;

                            that._polylines.removeAll();
                            that._labels.removeAll();
                            that._currentExtent = null;
                            that._drawGrid(that._getExtentView());
                        });
                        scene.imageryLayers.addImageryProvider(this);
                    };

                    var definePropertyWorks = function () {
                        try {
                            return 'x' in Object.defineProperty({}, 'x', {});
                        } catch (e) {
                            return false;
                        }
                    }();

                    /**
                     * Defines properties on an object, using Object.defineProperties if available,
                     * otherwise returns the object unchanged.  This function should be used in
                     * setup code to prevent errors from completely halting JavaScript execution
                     * in legacy browsers.
                     *
                     * @private
                     *
                     * @exports defineProperties
                     */
                    var defineProperties = Object.defineProperties;
                    if (!definePropertyWorks || !defineProperties) {
                        defineProperties = function defineProperties(o) {
                            return o;
                        };
                    }

                    defineProperties(GraticuleLayer.prototype, {
                        url: {
                            get: function get() {
                                return undefined;
                            }
                        },

                        proxy: {
                            get: function get() {
                                return undefined;
                            }
                        },

                        tileWidth: {
                            get: function get() {
                                return this._tileWidth;
                            }
                        },

                        tileHeight: {
                            get: function get() {
                                return this._tileHeight;
                            }
                        },

                        maximumLevel: {
                            get: function get() {
                                return 18;
                            }
                        },

                        minimumLevel: {
                            get: function get() {
                                return 0;
                            }
                        },
                        tilingScheme: {
                            get: function get() {
                                return this._tilingScheme;
                            }
                        },
                        rectangle: {
                            get: function get() {
                                return this._tilingScheme.rectangle;
                            }
                        },
                        tileDiscardPolicy: {
                            get: function get() {
                                return undefined;
                            }
                        },
                        errorEvent: {
                            get: function get() {
                                return this._errorEvent;
                            }
                        },
                        ready: {
                            get: function get() {
                                return this._ready;
                            }
                        },
                        credit: {
                            get: function get() {
                                return this._credit;
                            }
                        },
                        hasAlphaChannel: {
                            get: function get() {
                                return true;
                            }
                        }
                    });

                    GraticuleLayer.prototype.makeLabel = function (lng, lat, text, top, color) {
                        this._labels.add({
                            position: this._ellipsoid.cartographicToCartesian(new Cesium.Cartographic(lng, lat, 10.0)),
                            text: text,
                            //font: 'normal',
                            //style: Cesium.LabelStyle.FILL,
                            //fillColor: 'white',
                            //outlineColor: 'white',
                            font: 'normal small-caps normal 16px 楷体',
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            fillColor: Cesium.Color.AZURE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,

                            pixelOffset: new Cesium.Cartesian2(5, top ? 5 : -5),
                            eyeOffset: Cesium.Cartesian3.ZERO,
                            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                            verticalOrigin: top ? Cesium.VerticalOrigin.BOTTOM : Cesium.VerticalOrigin.TOP,
                            scale: 1.0
                        });
                    };

                    GraticuleLayer.prototype._drawGrid = function (extent) {

                        if (this._currentExtent && this._currentExtent.equals(extent)) {
                            return;
                        }
                        this._currentExtent = extent;

                        this._polylines.removeAll();
                        this._labels.removeAll();

                        var minPixel = 0;
                        var maxPixel = this._canvasSize;

                        var dLat = 0,
                            dLng = 0,
                            index;
                        // get the nearest to the calculated value
                        for (index = 0; index < mins.length && dLat < (extent.north - extent.south) / 10; index++) {
                            dLat = mins[index];
                        }
                        for (index = 0; index < mins.length && dLng < (extent.east - extent.west) / 10; index++) {
                            dLng = mins[index];
                        }

                        // round iteration limits to the computed grid interval
                        var minLng = (extent.west < 0 ? Math.ceil(extent.west / dLng) : Math.floor(extent.west / dLng)) * dLng;
                        var minLat = (extent.south < 0 ? Math.ceil(extent.south / dLat) : Math.floor(extent.south / dLat)) * dLat;
                        var maxLng = (extent.east < 0 ? Math.ceil(extent.east / dLat) : Math.floor(extent.east / dLat)) * dLat;
                        var maxLat = (extent.north < 0 ? Math.ceil(extent.north / dLng) : Math.floor(extent.north / dLng)) * dLng;

                        // extend to make sure we cover for non refresh of tiles
                        minLng = Math.max(minLng - 2 * dLng, -Math.PI);
                        maxLng = Math.min(maxLng + 2 * dLng, Math.PI);
                        minLat = Math.max(minLat - 2 * dLat, -Math.PI / 2);
                        maxLat = Math.min(maxLat + 2 * dLng, Math.PI / 2);

                        var ellipsoid = this._ellipsoid;
                        var lat,
                            lng,
                            granularity = Cesium.Math.toRadians(1);

                        // labels positions
                        var latitudeText = minLat + Math.floor((maxLat - minLat) / dLat / 2) * dLat;
                        for (lng = minLng; lng < maxLng; lng += dLng) {
                            // draw meridian
                            var path = [];
                            for (lat = minLat; lat < maxLat; lat += granularity) {
                                path.push(new Cesium.Cartographic(lng, lat));
                            }
                            path.push(new Cesium.Cartographic(lng, maxLat));
                            this._polylines.add({
                                positions: ellipsoid.cartographicArrayToCartesianArray(path),
                                width: 1
                            });
                            var degLng = Cesium.Math.toDegrees(lng);
                            this.makeLabel(lng, latitudeText, this._sexagesimal ? this._decToSex(degLng) : degLng.toFixed(gridPrecision(dLng)), false);
                        }

                        // lats
                        var longitudeText = minLng + Math.floor((maxLng - minLng) / dLng / 2) * dLng;
                        for (lat = minLat; lat < maxLat; lat += dLat) {
                            // draw parallels
                            var path = [];
                            for (lng = minLng; lng < maxLng; lng += granularity) {
                                path.push(new Cesium.Cartographic(lng, lat));
                            }
                            path.push(new Cesium.Cartographic(maxLng, lat));
                            this._polylines.add({
                                positions: ellipsoid.cartographicArrayToCartesianArray(path),
                                width: 1
                            });
                            var degLat = Cesium.Math.toDegrees(lat);
                            this.makeLabel(longitudeText, lat, this._sexagesimal ? this._decToSex(degLat) : degLat.toFixed(gridPrecision(dLat)), true);
                        }
                    };

                    GraticuleLayer.prototype.requestImage = function (x, y, level) {

                        if (this._show) {
                            this._drawGrid(this._getExtentView());
                        }

                        return this._canvas;
                    };

                    GraticuleLayer.prototype.setVisible = function (visible) {
                        this._show = visible;
                        if (!visible) {
                            this._polylines.removeAll();
                            this._labels.removeAll();
                        } else {
                            this._currentExtent = null;
                            this._drawGrid(this._getExtentView());
                        }
                    };

                    GraticuleLayer.prototype.isVisible = function () {
                        return this._show;
                    };

                    GraticuleLayer.prototype._decToSex = function (d) {
                        var degs = Math.floor(d);
                        var mins = ((Math.abs(d) - degs) * 60.0).toFixed(2);
                        if (mins == "60.00") {
                            degs += 1.0; mins = "0.00";
                        }
                        return [degs, ":", mins].join('');
                    };

                    GraticuleLayer.prototype._getExtentView = function () {
                        var camera = this._scene.camera;
                        var canvas = this._scene.canvas;
                        var corners = [camera.pickEllipsoid(new Cesium.Cartesian2(0, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, 0), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(0, canvas.height), this._ellipsoid), camera.pickEllipsoid(new Cesium.Cartesian2(canvas.width, canvas.height), this._ellipsoid)];
                        for (var index = 0; index < 4; index++) {
                            if (corners[index] === undefined) {
                                return Cesium.Rectangle.MAX_VALUE;
                            }
                        }
                        return Cesium.Rectangle.fromCartographicArray(this._ellipsoid.cartesianArrayToCartographicArray(corners));
                    };

                    function gridPrecision(dDeg) {
                        if (dDeg < 0.01) return 2;
                        if (dDeg < 0.1) return 1;
                        if (dDeg < 1) return 0;
                        return 0;
                    }

                    var mins = [Cesium.Math.toRadians(0.05), Cesium.Math.toRadians(0.1), Cesium.Math.toRadians(0.2), Cesium.Math.toRadians(0.5), Cesium.Math.toRadians(1.0), Cesium.Math.toRadians(2.0), Cesium.Math.toRadians(5.0), Cesium.Math.toRadians(10.0)];

                    function loggingMessage(message) {
                        var logging = document.getElementById('logging');
                        logging.innerHTML += message;
                    }

                    this.model = new GraticuleLayer({ numLines: 10 }, this.viewer.scene);
                }

            });

            exports.GraticuleLayer = GraticuleLayer;

            /***/
}),
/* 85 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FeatureGridLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _TileLayer = __webpack_require__(48);

            var _config2Entity = __webpack_require__(28);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var FeatureGridLayer = _TileLayer.TileLayer.extend({
                dataSource: null,
                hasOpacity: false,
                create: function create() {
                    this.dataSource = new Cesium.CustomDataSource(); //用于entity
                    this.primitives = new Cesium.PrimitiveCollection(); //用于primitive

                    this.config.id = Cesium.defaultValue(this.config.id, new Date().getTime());

                    var that = this;
                    this.config.type_new = "custom_featuregrid";
                    this.config.addImageryCache = function (opts) {
                        return that._addImageryCache(opts);
                    };
                    this.config.removeImageryCache = function (opts) {
                        return that._removeImageryCache(opts);
                    };
                    this.config.removeAllImageryCache = function (opts) {
                        return that._removeAllImageryCache(opts);
                    };

                    //是建筑物单体化时
                    if (this.config.dth) {
                        var dthEvent = (0, _config2Entity.createDthEntity)(this.viewer, this.config.dth);
                        this.config.mouseover = dthEvent.mouseover;
                        this.config.mouseout = dthEvent.mouseout;
                    }

                    var config = this.config;
                    if (config.symbol && config.symbol.styleOptions) {
                        var style = config.symbol.styleOptions;
                        if (Cesium.defined(style.clampToGround)) {
                            config.clampToGround = style.clampToGround;
                        }
                        if (Cesium.defined(style.color)) {
                            var color = new Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5)));
                            config.fill = color;
                        }
                        if (Cesium.defined(style.outlineColor)) {
                            var outlineColor = new Cesium.Color.fromCssColorString(style.outlineColor || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0)));
                            config.stroke = outlineColor;
                        }
                        if (Cesium.defined(style.outlineWidth)) {
                            config.strokeWidth = style.outlineWidth;
                        }
                        this.config = config;
                    }
                },
                getLength: function getLength() {
                    return this.primitives.length + this.dataSource.entities.values.length;
                },
                addEx: function addEx() {
                    this.viewer.dataSources.add(this.dataSource);
                    this.viewer.scene.primitives.add(this.primitives);
                },
                removeEx: function removeEx() {
                    this.viewer.dataSources.remove(this.dataSource);
                    this.viewer.scene.primitives.remove(this.primitives);
                },
                _addImageryCache: function _addImageryCache(opts) { },
                _removeImageryCache: function _removeImageryCache(opts) { },
                _removeAllImageryCache: function _removeAllImageryCache() { }

            });

            exports.FeatureGridLayer = FeatureGridLayer;

            /***/
}),
/* 86 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.POILayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _CustomFeatureGridLayer = __webpack_require__(37);

            var _Attr = __webpack_require__(38);

            var _Attr2 = __webpack_require__(30);

            var _Attr3 = __webpack_require__(16);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var POILayer = _CustomFeatureGridLayer.CustomFeatureGridLayer.extend({
                //查询POI服务
                _keys: null,
                _key_index: 0,
                getKey: function getKey() {
                    if (!this._keys) {
                        this._keys = this.config.key || ["c95467d0ed2a3755836e37dc27369f97", "4320dda936d909d73ab438b4e29cf2a2", "e64a96ed7e361cbdc0ebaeaf3818c564", "df3247b7df64434adecb876da94755d7", "d4375ec477cb0a473c448fb1f83be781", "13fdd7b2b90a9d326ae96867ebcc34ce", "c34502450ae556f42b21760faf6695a0", "57f8ebe12797a73fc5b87f5d4ef859b1"];
                    }

                    var thisidx = this._key_index++ % this._keys.length;
                    return this._keys[thisidx];
                },

                //获取网格内的数据，calback为回调方法，参数传数据数组 
                getDataForGrid: function getDataForGrid(opts, calback) {
                    var jwd1 = pointconvert.wgs2gcj([opts.rectangle.xmin, opts.rectangle.ymax]); //加偏
                    var jwd2 = pointconvert.wgs2gcj([opts.rectangle.xmax, opts.rectangle.ymin]); //加偏
                    var polygon = jwd1[0] + "," + jwd1[1] + "|" + jwd2[0] + "," + jwd2[1];

                    var filter = this.config.filter || {};
                    filter.output = "json";
                    filter.key = this.getKey();
                    filter.polygon = polygon;
                    if (!filter.offset) filter.offset = 25;
                    if (!filter.types) filter.types = "120000|130000|190000";

                    var that = this;
                    _zepto.zepto.ajax({
                        url: 'http://restapi.amap.com/v3/place/polygon',
                        type: "get",
                        dataType: "json",
                        timeout: "5000",
                        data: filter,
                        success: function success(data) {
                            if (data.infocode !== "10000") {
                                console.log("POI 请求失败(" + data.infocode + ")：" + data.info);
                                return;
                            }
                            var arrdata = data.pois;
                            calback(arrdata);
                        },
                        error: function error(data) {
                            console.log("POI 请求出错(" + data.status + ")：" + data.statusText);
                        }
                    });
                },
                //根据数据创造entity
                createEntity: function createEntity(opts, attributes) {
                    var inthtml = "<div>名称：" + attributes.name + "</div>" + "<div>地址：" + attributes.address + "</div>" + "<div>区域：" + attributes.pname + attributes.cityname + attributes.adname + "</div>" + "<div>类别：" + attributes.type + "</div>";

                    var arrjwd = attributes.location.split(",");
                    arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
                    var lnglat = this.viewer.mapv.point2map({ x: arrjwd[0], y: arrjwd[1] });

                    var entityOptions = {
                        name: attributes.name,
                        position: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, this.config.height || 3),
                        popup: {
                            html: inthtml,
                            anchor: [0, -15]
                        },
                        properties: attributes
                    };

                    var symbol = this.config.symbol;
                    if (symbol) {
                        var styleOpt = symbol.styleOptions;
                        if (symbol.styleField) {
                            //存在多个symbol，按styleField进行分类
                            var styleFieldVal = attr[symbol.styleField];
                            var styleOptField = symbol.styleFieldOptions[styleFieldVal];
                            if (styleOptField != null) {
                                styleOpt = _zepto.zepto.extend({}, styleOpt);
                                styleOpt = _zepto.zepto.extend(styleOpt, styleOptField);
                            }
                        }
                        styleOpt = styleOpt || {};

                        if (styleOpt.image) {
                            entityOptions.billboard = (0, _Attr2.style2Entity)(styleOpt);
                            entityOptions.billboard.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                        } else {
                            entityOptions.point = (0, _Attr.style2Entity)(styleOpt);
                        }

                        //加上文字标签 
                        if (styleOpt.label) {
                            entityOptions.label = (0, _Attr3.style2Entity)(styleOpt.label);
                            entityOptions.label.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                            entityOptions.label.text = attributes.name;
                        }
                    } else {
                        //无配置时的默认值
                        entityOptions.point = {
                            color: new Cesium.Color.fromCssColorString("#3388ff"),
                            pixelSize: 10,
                            outlineColor: new Cesium.Color.fromCssColorString("#ffffff"),
                            outlineWidth: 2,
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                            scaleByDistance: new Cesium.NearFarScalar(1000, 1, 20000, 0.5)
                        };
                        entityOptions.label = {
                            text: attributes.name,
                            font: 'normal small-caps normal 16px 楷体',
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            fillColor: Cesium.Color.AZURE,
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            pixelOffset: new Cesium.Cartesian2(0, -15), //偏移量   
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, //是地形上方的高度 
                            scaleByDistance: new Cesium.NearFarScalar(1000, 1, 5000, 0.8),
                            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0.0, 5000)
                        };
                    }

                    var entity = this.dataSource.entities.add(entityOptions);
                    return entity;
                }

            });

            exports.POILayer = POILayer;

            /***/
}),
/* 87 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.WFSLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CustomFeatureGridLayer = __webpack_require__(37);

            var _util = __webpack_require__(1);

            var _zepto = __webpack_require__(6);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var WFSLayer = _CustomFeatureGridLayer.CustomFeatureGridLayer.extend({
                //获取网格内的数据，calback为回调方法，参数传数据数组 
                getDataForGrid: function getDataForGrid(opts, calback) {
                    var that = this;

                    //请求的wfs参数
                    var parameters = {
                        service: "WFS",
                        request: "GetFeature",
                        typeName: this.config.layer || this.config.typeName,
                        version: "1.0.0",
                        outputFormat: "application/json",
                        bbox: opts.rectangle.xmin + "," + opts.rectangle.ymin + "," + opts.rectangle.xmax + "," + opts.rectangle.ymax
                    };

                    //其他可选参数
                    if (Cesium.defined(this.config.parameters)) {
                        for (var key in this.config.parameters) {
                            parameters[key] = this.config.parameters[key];
                        }
                    }

                    _zepto.zepto.ajax({
                        url: this.config.url,
                        type: "get",
                        data: parameters,
                        success: function success(featureCollection) {
                            if (!that._visible || !that._cacheGrid[opts.key]) {
                                return; //异步请求结束时,如果已经卸载了网格就直接跳出。
                            }

                            if (featureCollection == undefined || featureCollection == null) {
                                return; //数据为空
                            }

                            if (featureCollection.type == "Feature") featureCollection = { "type": "FeatureCollection", "features": [featureCollection] };

                            calback(featureCollection.features);
                        },
                        error: function error(data) {
                            console.log("请求出错(" + data.status + ")：" + data.statusText);
                        }
                    });
                },
                //根据数据创造entity
                createEntity: function createEntity(opts, item, calback) {
                    if (this.config.dth && this.config.dth.buffer > 0) {
                        //是建筑物单体化时,缓冲扩大点范围
                        item = (0, _util.buffer)(item, this.config.dth.buffer);
                    }

                    var that = this;
                    var dataSource = Cesium.GeoJsonDataSource.load(item, this.config);
                    dataSource.then(function (dataSource) {
                        if (that.checkHasBreak[opts.key]) {
                            return; //异步请求结束时，如果已经卸载了网格就直接跳出。
                        }

                        if (dataSource.entities.values.length == 0) return null;
                        var entity = dataSource.entities.values[0];
                        entity.entityCollection.remove(entity); //从原有的集合中删除  

                        entity._id = that.config.id + "_" + opts.key + "_" + entity.id;

                        that._addEntity(entity, calback);
                    }).otherwise(function (error) {
                        that.showError("服务出错", error);
                    });

                    return null;
                },
                //更新entity，并添加到地图上
                _addEntity: function _addEntity(entity, calback) {
                    // this.dataSource.entities.removeById(entity._id); 
                    // if (this.dataSource.entities.contains(entity))return          
                    if (this.dataSource.entities.getById(entity._id)) return;

                    this.dataSource.entities.add(entity); //加入到当前图层集合图层中

                    //根据config配置，更新entitys  
                    this.config2Entity(entity);

                    calback(entity);
                }

            });

            exports.WFSLayer = WFSLayer;

            /***/
}),
/* 88 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GltfLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _BaseLayer = __webpack_require__(13);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var GltfLayer = _BaseLayer.BaseLayer.extend({
                model: null,
                //添加 
                add: function add() {
                    if (this.model) {
                        this.viewer.entities.add(this.model);
                    } else {
                        this.initData();
                    }
                },
                //移除
                remove: function remove() {
                    this.viewer.entities.remove(this.model);
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    if (this.model == null) return;

                    if (this.config.extent || this.config.center) {
                        this.viewer.mapv.centerAt(this.config.extent || this.config.center, { duration: duration, isWgs84: true });
                    } else {
                        var cfg = this.config.position;
                        this.viewer.mapv.centerAt(cfg, { duration: duration, isWgs84: true });
                    }
                },

                initData: function initData() {
                    var cfg = this.config.position;
                    cfg = this.viewer.mapv.point2map(cfg); //转换坐标系

                    var position = Cesium.Cartesian3.fromDegrees(cfg.x, cfg.y, cfg.z || 0);
                    var heading = Cesium.Math.toRadians(cfg.heading || 0);
                    var pitch = Cesium.Math.toRadians(cfg.pitch || 0);
                    var roll = Cesium.Math.toRadians(cfg.roll || 0);
                    var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
                    var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

                    var modelopts = { uri: this.config.url };
                    for (var key in this.config) {
                        if (key == "url" || key == "name" || key == "position" || key == "center" || key == "tooltip" || key == "popup") continue;
                        modelopts[key] = this.config[key];
                    }

                    this.model = this.viewer.entities.add({
                        name: this.config.name,
                        position: position,
                        orientation: orientation,
                        model: modelopts,
                        _config: this.config,
                        tooltip: this.config.tooltip,
                        popup: this.config.popup
                    });
                },
                //设置透明度
                hasOpacity: true,
                setOpacity: function setOpacity(value) {
                    if (this.model == null) return;
                    this.model.model.color = new Cesium.Color.fromCssColorString("#FFFFFF").withAlpha(value);
                }

            });

            exports.GltfLayer = GltfLayer;

            /***/
}),
/* 89 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Tiles3dLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _BaseLayer = __webpack_require__(13);

            var _util = __webpack_require__(1);

            var _tileset = __webpack_require__(27);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var Tiles3dLayer = _BaseLayer.BaseLayer.extend({
                model: null,
                originalCenter: null,
                positionCenter: null,
                boundingSphere: null,
                //添加 
                add: function add() {
                    if (this.model) {
                        if (!this.viewer.scene.primitives.contains(this.model)) this.viewer.scene.primitives.add(this.model);
                    } else {
                        this.initData();
                    }
                },
                //移除
                remove: function remove() {
                    if (Cesium.defined(this.config.visibleDistanceMax)) this.viewer.scene.camera.changed.removeEventListener(this.updateVisibleDistance, this);

                    if (this.viewer.scene.primitives.contains(this.model)) this.viewer.scene.primitives.remove(this.model);

                    delete this.model;
                    delete this.boundingSphere;
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    if (this.config.extent || this.config.center) {
                        this.viewer.mapv.centerAt(this.config.extent || this.config.center, { duration: duration, isWgs84: true });
                    } else if (this.boundingSphere) {
                        this.viewer.camera.flyToBoundingSphere(this.boundingSphere, {
                            offset: new Cesium.HeadingPitchRange(0.0, -0.5, this.boundingSphere.radius * 2),
                            duration: duration
                        });
                    }
                },

                initData: function initData() {
                    this.model = this.viewer.scene.primitives.add(new Cesium.Cesium3DTileset((0, _util.getProxyUrl)(this.config)));
                    this.model._config = this.config;

                    for (var key in this.config) {
                        if (key == "url" || key == "type" || key == "style" || key == "classificationType") continue;
                        try {
                            this.model[key] = this.config[key];
                        } catch (e) { }
                    }
                    if (this.config.style) {
                        //设置style
                        this.model.style = new Cesium.Cesium3DTileStyle(this.config.style);
                    }

                    var that = this;
                    this.model.readyPromise.then(function (tileset) {
                        if (that.readyPromise) {
                            that.readyPromise(tileset);
                        }

                        if (that.hasOpacity && that._opacity != 1) {
                            //透明度
                            that.setOpacity(that._opacity);
                        }

                        //记录模型原始的中心点
                        var boundingSphere = tileset.boundingSphere;
                        that.boundingSphere = boundingSphere;

                        if (tileset._root && tileset._root.transform) {
                            that.orginMatrixInverse = Cesium.Matrix4.inverse(Cesium.Matrix4.fromArray(tileset._root.transform), new Cesium.Matrix4());

                            if (that.config.scale > 0 && that.config.scale != 1) {
                                tileset._root.transform = Cesium.Matrix4.multiplyByUniformScale(tileset._root.transform, that.config.scale, tileset._root.transform);
                            }
                        }

                        var position = boundingSphere.center; //模型原始的中心点
                        that.positionCenter = position;
                        var catographic = Cesium.Cartographic.fromCartesian(position);

                        var height = Number(catographic.height.toFixed(2));
                        var longitude = Number(Cesium.Math.toDegrees(catographic.longitude).toFixed(6));
                        var latitude = Number(Cesium.Math.toDegrees(catographic.latitude).toFixed(6));
                        that.originalCenter = { x: longitude, y: latitude, z: height };
                        console.log((that.config.name || "") + " 模型原始位置:" + JSON.stringify(that.originalCenter));

                        //转换坐标系【如果是高德谷歌国测局坐标系时转换坐标进行加偏，其它的原样返回】
                        var rawCenter = that.viewer.mapv.point2map(that.originalCenter);
                        if (rawCenter.x != that.originalCenter.x || rawCenter.y != that.originalCenter.y || that.config.offset != null) {

                            that.config.offset = that.config.offset || {}; //配置信息中指定的坐标信息或高度信息
                            if (that.config.offset.x && that.config.offset.y) {
                                that.config.offset = that.viewer.mapv.point2map(that.config.offset); //转换坐标系【如果是高德谷歌国测局坐标系时转换坐标进行加偏，其它的原样返回】
                            }

                            var offsetopt = {
                                x: that.config.offset.x || rawCenter.x,
                                y: that.config.offset.y || rawCenter.y,
                                z: that.config.offset.z || 0,
                                heading: that.config.offset.heading,
                                axis: that.config.axis,
                                scale: that.config.scale,
                                transform: that.config.offset.hasOwnProperty("transform") ? that.config.offset.transform : that.config.offset.heading != null
                            };

                            if (that.config.offset.z == "-height") {
                                offsetopt.z = -height + 5;
                                that.updateMatrix(offsetopt);
                            } else if (that.config.offset.z == "auto") {
                                that.autoHeight(position, offsetopt);
                            } else {
                                that.updateMatrix(offsetopt);
                            }
                        }

                        if (!that.viewer.mapv.isFlyAnimation() && that.config.flyTo) {
                            that.centerAt(0);
                        }

                        if (that.config.calback) {
                            that.config.calback(tileset);
                        }

                        if (Cesium.defined(that.config.visibleDistanceMax)) that.bindVisibleDistance();
                    });
                },

                autoHeight: function autoHeight(position, offsetopt) {
                    var that = this;
                    //求地面海拔
                    (0, _point.getSurfaceTerrainHeight)(this.viewer.scene, position, {
                        asyn: true, //是否异步求准确高度 
                        calback: function calback(newHeight, cartOld) {
                            if (newHeight == null) return;

                            var offsetZ = newHeight - that.originalCenter.z + 1;
                            offsetopt.z = offsetZ;

                            that.updateMatrix(offsetopt);
                        }
                    });
                },
                //变换原点坐标
                updateMatrix: function updateMatrix(offsetopt) {
                    if (this.model == null) return;

                    console.log((this.config.name || "") + " 模型修改后位置:" + JSON.stringify(offsetopt));

                    this.positionCenter = Cesium.Cartesian3.fromDegrees(offsetopt.x, offsetopt.y, offsetopt.z);

                    (0, _tileset.updateMatrix)(this.model, offsetopt);
                },

                hasOpacity: true,
                //设置透明度
                setOpacity: function setOpacity(value) {
                    this._opacity = value;

                    if (this.config.onSetOpacity) {
                        this.config.onSetOpacity(value); //外部自定义处理
                    } else {
                        if (this.model) {
                            this.model.style = new Cesium.Cesium3DTileStyle({
                                color: "color() *vec4(1,1,1," + value + ")"
                            });
                        }
                    }
                },
                showClickFeature: function showClickFeature(value) {
                    if (this.model) {
                        this.model._config.showClickFeature = value;
                    } else {
                        this.config.showClickFeature = value;
                    }
                },
                //绑定
                bindVisibleDistance: function bindVisibleDistance() {
                    this.viewer.scene.camera.changed.addEventListener(this.updateVisibleDistance, this);
                },
                updateVisibleDistance: function updateVisibleDistance() {
                    if (!this._visible) return;
                    if (this.viewer.scene.mode !== Cesium.SceneMode.SCENE3D) return;
                    if (!this.model || !this.boundingSphere || !this.positionCenter) return;

                    var camera_distance = Cesium.Cartesian3.distance(this.positionCenter, this.viewer.camera.position);
                    if (camera_distance > this.config.visibleDistanceMax + 100000) {
                        //在模型的外包围外
                        this.model.show = false;
                    } else {
                        var target = (0, _point.pickCenterPoint)(this.viewer.scene); //取屏幕中心点坐标
                        if (Cesium.defined(target)) {
                            var camera_distance = Cesium.Cartesian3.distance(target, this.viewer.camera.position);
                            this.model.show = camera_distance < this.config.visibleDistanceMax;
                        } else {
                            this.model.show = true;
                        }
                    }
                }

            });

            exports.Tiles3dLayer = Tiles3dLayer;

            /***/
}),
/* 90 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.KmlLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _GeoJsonLayer = __webpack_require__(39);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var KmlLayer = _GeoJsonLayer.GeoJsonLayer.extend({
                queryData: function queryData() {
                    var that = this;

                    var config = (0, _util.getProxyUrl)(this.config);

                    if (config.symbol && config.symbol.styleOptions) {
                        var style = config.symbol.styleOptions;
                        if (Cesium.defined(style.clampToGround)) {
                            config.clampToGround = style.clampToGround;
                        }
                    }

                    var dataSource = Cesium.KmlDataSource.load(config.url, {
                        camera: this.viewer.scene.camera,
                        canvas: this.viewer.scene.canvas,
                        clampToGround: config.clampToGround
                    });
                    dataSource.then(function (dataSource) {
                        that.showResult(dataSource);
                    }).otherwise(function (error) {
                        that.showError("服务出错", error);
                    });
                },
                getEntityAttr: function getEntityAttr(entity) {
                    var attr = { name: entity.name, description: entity.description };
                    var extendedData = entity._kml.extendedData;
                    for (var key in extendedData) {
                        attr[key] = extendedData[key].value;
                    }
                    attr = (0, _util.getAttrVal)(attr);

                    if (attr.description) {
                        attr.description = attr.description.replace(/<div[^>]+>/g, ""); //剔除div html标签
                    }

                    return attr;
                }

            });

            exports.KmlLayer = KmlLayer;

            /***/
}),
/* 91 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CzmlLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _GeoJsonLayer = __webpack_require__(39);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var CzmlLayer = _GeoJsonLayer.GeoJsonLayer.extend({
                queryData: function queryData() {
                    var that = this;

                    var config = (0, _util.getProxyUrl)(this.config);

                    var dataSource = Cesium.CzmlDataSource.load(config.url, config);
                    dataSource.then(function (dataSource) {
                        that.showResult(dataSource);
                    }).otherwise(function (error) {
                        that.showError("服务出错", error);
                    });
                },
                getEntityAttr: function getEntityAttr(entity) {
                    if (entity.description && entity.description.getValue) return entity.description.getValue(this.viewer.clock.currentTime);
                }

            });

            exports.CzmlLayer = CzmlLayer;

            /***/
}),
/* 92 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TerrainLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _BaseLayer = __webpack_require__(13);

            var _layer = __webpack_require__(20);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var TerrainLayer = _BaseLayer.BaseLayer.extend({
                terrain: null,
                //添加 
                add: function add() {
                    if (!this.terrain) {
                        this.terrain = (0, _layer.getTerrainProvider)(this.config.terrain || this.config);
                    }
                    this.viewer.terrainProvider = this.terrain;
                },
                //移除
                remove: function remove() {
                    this.viewer.terrainProvider = (0, _layer.getEllipsoidTerrain)();
                }

            });
            exports.TerrainLayer = TerrainLayer;

            /***/
}),
/* 93 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawLayer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _BaseLayer = __webpack_require__(13);

            var _Draw = __webpack_require__(4);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawLayer = _BaseLayer.BaseLayer.extend({
                create: function create() {
                    this.drawControl = new _Draw.Draw(this.viewer, {
                        hasEdit: false,
                        nameTooltip: false,
                        removeScreenSpaceEvent: false
                    });
                },
                //添加 
                add: function add() {
                    if (this._isload) this.drawControl.setVisible(true); else this._loadData();
                },
                //移除
                remove: function remove() {
                    this.drawControl.setVisible(false);
                },
                //定位至数据区域
                centerAt: function centerAt(duration) {
                    var arr = this.drawControl.getEntitys();
                    this.viewer.flyTo(arr, { duration: duration });
                },
                hasOpacity: false,
                //设置透明度
                setOpacity: function setOpacity(value) { },
                _loadData: function _loadData() {
                    var that = this;
                    _zepto.zepto.ajax({
                        type: "get",
                        dataType: "json",
                        url: this.config.url,
                        timeout: 10000,
                        success: function success(data) {
                            that._isload = true;
                            var arr = that.drawControl.jsonToEntity(data, true, that.config.flyTo);
                            that._bindEntityConfig(arr);

                            if (that.config.calback) {
                                that.config.calback(arr);
                            }
                        },
                        error: function error(XMLHttpRequest, textStatus, errorThrown) {
                            console.log("Json文件" + that.config.url + "加载失败！");
                        }
                    });
                },
                _bindEntityConfig: function _bindEntityConfig(arrEntity) {
                    var that = this;

                    for (var i = 0, len = arrEntity.length; i < len; i++) {
                        var entity = arrEntity[i];

                        //popup弹窗
                        if (this.config.columns || this.config.popup) {
                            entity.popup = {
                                html: function html(entity) {
                                    var attr = entity.attribute.attr;
                                    attr.layer_name = that.config.name;
                                    attr.draw_type = entity.attribute.type;
                                    attr.draw_typename = entity.attribute.name;
                                    return (0, _util.getPopupForConfig)(that.config, attr);
                                },
                                anchor: this.config.popupAnchor || [0, -15]
                            };
                        }
                        if (this.config.tooltip) {
                            entity.tooltip = {
                                html: function html(entity) {
                                    var attr = entity.attribute.attr;
                                    attr.layer_name = that.config.name;
                                    attr.draw_type = entity.attribute.type;
                                    attr.draw_typename = entity.attribute.name;
                                    return (0, _util.getPopupForConfig)({ popup: that.config.tooltip }, attr);
                                },
                                anchor: this.config.tooltipAnchor || [0, -15]
                            };
                        }
                        if (this.config.click) {
                            entity.click = this.config.click;
                        }
                        if (this.config.mouseover) {
                            entity.mouseover = this.config.mouseover;
                        }
                        if (this.config.mouseout) {
                            entity.mouseout = this.config.mouseout;
                        }
                    }
                }

            });
            exports.DrawLayer = DrawLayer;

            /***/
}),
/* 94 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.BaiduImageryProvider = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var height = 33746824; //百度地图

            var width = 33554054;

            function BaiduImageryProvider(option) {
                var url = option.url;
                if (Cesium.defined(option.layer)) {
                    switch (option.layer) {
                        case "vec":
                            url = 'http://online{s}.map.bdimg.com/onlinelabel/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'ph' : 'pl') + '&scaler=1&p=1';
                            break;
                        case "img_d":
                            url = 'http://shangetu{s}.map.bdimg.com/it/u=x={x};y={y};z={z};v=009;type=sate&fm=46';
                            break;
                        case "img_z":
                            url = 'http://online{s}.map.bdimg.com/tile/?qt=tile&x={x}&y={y}&z={z}&styles=' + (option.bigfont ? 'sh' : 'sl') + '&v=020';
                            break;

                        case "custom":
                            //Custom 各种自定义样式
                            //可选值：dark,midnight,grayscale,hardedge,light,redalert,googlelite,grassgreen,pink,darkgreen,bluish
                            option.customid = option.customid || 'midnight';
                            url = 'http://api{s}.map.bdimg.com/customimage/tile?&x={x}&y={y}&z={z}&scale=1&customid=' + option.customid;
                            break;

                        case "time":
                            //实时路况
                            var time = new Date().getTime();
                            url = 'http://its.map.baidu.com:8002/traffic/TrafficTileService?x={x}&y={y}&level={z}&time=' + time + '&label=web2D&v=017';
                            break;
                    }
                }
                this._url = url;

                this._tileWidth = 256;
                this._tileHeight = 256;
                this._maximumLevel = 18;

                var rectangleSouthwestInMeters = new Cesium.Cartesian2(-width, -height);
                var rectangleNortheastInMeters = new Cesium.Cartesian2(width, height);
                this._tilingScheme = new Cesium.WebMercatorTilingScheme({ rectangleSouthwestInMeters: rectangleSouthwestInMeters, rectangleNortheastInMeters: rectangleNortheastInMeters });

                this._credit = undefined;
                this._rectangle = this._tilingScheme.rectangle;
                this._ready = true;
            }
            Object.defineProperties(BaiduImageryProvider.prototype, {
                url: {
                    get: function get() {
                        return this._url;
                    }
                },

                token: {
                    get: function get() {
                        return this._token;
                    }
                },

                proxy: {
                    get: function get() {
                        return this._proxy;
                    }
                },

                tileWidth: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileWidth;
                    }
                },

                tileHeight: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileHeight;
                    }
                },

                maximumLevel: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._maximumLevel;
                    }
                },

                minimumLevel: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return 0;
                    }
                },

                tilingScheme: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tilingScheme;
                    }
                },

                rectangle: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._rectangle;
                    }
                },

                tileDiscardPolicy: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileDiscardPolicy;
                    }
                },

                errorEvent: {
                    get: function get() {
                        return this._errorEvent;
                    }
                },

                ready: {
                    get: function get() {
                        return this._ready;
                    }
                },

                readyPromise: {
                    get: function get() {
                        return this._readyPromise.promise;
                    }
                },

                credit: {
                    get: function get() {
                        return this._credit;
                    }
                },

                usingPrecachedTiles: {
                    get: function get() {
                        return this._useTiles;
                    }
                },

                hasAlphaChannel: {
                    get: function get() {
                        return true;
                    }
                },

                layers: {
                    get: function get() {
                        return this._layers;
                    }
                }
            });

            BaiduImageryProvider.prototype.getTileCredits = function (x, y, level) {
                return undefined;
            };

            BaiduImageryProvider.prototype.requestImage = function (x, y, level) {
                if (!this._ready) {
                    throw new DeveloperError('requestImage must not be called before the imagery provider is ready.');
                }

                var tileW = this._tilingScheme.getNumberOfXTilesAtLevel(level);
                var tileH = this._tilingScheme.getNumberOfYTilesAtLevel(level);

                var url = this._url.replace('{x}', x - tileW / 2).replace('{y}', tileH / 2 - y - 1).replace('{z}', level).replace('{s}', Math.floor(Math.random() * 10));

                return Cesium.ImageryProvider.loadImage(this, url);
            };

            exports.BaiduImageryProvider = BaiduImageryProvider;

            /***/
}),
/* 95 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FeatureGridImageryProvider = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function FeatureGridImageryProvider(options) {
                options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
                this.options = options;

                this._tileWidth = Cesium.defaultValue(options.tileWidth, 256);
                this._tileHeight = Cesium.defaultValue(options.tileHeight, 256);
                this._minimumLevel = Cesium.defaultValue(options.minimumLevel, 0);
                this._maximumLevel = options.maximumLevel;

                if (options.rectangle && options.rectangle.xmin && options.rectangle.xmax && options.rectangle.ymin && options.rectangle.ymax) {
                    var xmin = options.rectangle.xmin;
                    var xmax = options.rectangle.xmax;
                    var ymin = options.rectangle.ymin;
                    var ymax = options.rectangle.ymax;
                    options.rectangle = Cesium.Rectangle.fromDegrees(xmin, ymin, xmax, ymax);
                }
                this._tilingScheme = Cesium.defaultValue(options.tilingScheme, new Cesium.GeographicTilingScheme({ ellipsoid: options.ellipsoid }));
                this._rectangle = Cesium.defaultValue(options.rectangle, this._tilingScheme.rectangle);
                this._rectangle = Cesium.Rectangle.intersection(this._rectangle, this._tilingScheme.rectangle);
                this._hasAlphaChannel = Cesium.defaultValue(options.hasAlphaChannel, true);

                this._errorEvent = new Cesium.Event();
                this._readyPromise = Cesium.when.resolve(true);
                this._credit = undefined;
                this._ready = true;
            }

            Object.defineProperties(FeatureGridImageryProvider.prototype, {
                url: {
                    get: function get() {
                        return this._url;
                    }
                },

                token: {
                    get: function get() {
                        return this._token;
                    }
                },

                proxy: {
                    get: function get() {
                        return this._proxy;
                    }
                },

                tileWidth: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileWidth must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileWidth;
                    }
                },

                tileHeight: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileHeight must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileHeight;
                    }
                },

                maximumLevel: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('maximumLevel must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._maximumLevel;
                    }
                },

                minimumLevel: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('minimumLevel must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug'); 
                        return 0;
                    }
                },

                tilingScheme: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tilingScheme must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tilingScheme;
                    }
                },

                rectangle: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('rectangle must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._rectangle;
                    }
                },

                tileDiscardPolicy: {
                    get: function get() {
                        //>>includeStart('debug', pragmas.debug);
                        if (!this._ready) {
                            throw new DeveloperError('tileDiscardPolicy must not be called before the imagery provider is ready.');
                        }
                        //>>includeEnd('debug');

                        return this._tileDiscardPolicy;
                    }
                },

                errorEvent: {
                    get: function get() {
                        return this._errorEvent;
                    }
                },

                ready: {
                    get: function get() {
                        return this._ready;
                    }
                },

                readyPromise: {
                    get: function get() {
                        return this._readyPromise.promise;
                    }
                },

                credit: {
                    get: function get() {
                        return this._credit;
                    }
                },

                usingPrecachedTiles: {
                    get: function get() {
                        return this._useTiles;
                    }
                },

                hasAlphaChannel: {
                    get: function get() {
                        return true;
                    }
                },

                layers: {
                    get: function get() {
                        return this._layers;
                    }
                }
            });

            FeatureGridImageryProvider.prototype.getTileCredits = function (x, y, level) {
                return undefined;
            };

            //显示瓦片信息
            FeatureGridImageryProvider.prototype.requestImage = function (x, y, level) {
                var canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;

                if (level < this._minimumLevel || Cesium.defined(this._maximumLevel) && level > this._maximumLevel) return canvas;

                if (this.options.debuggerTileInfo) {
                    var context = canvas.getContext('2d');

                    context.strokeStyle = '#ffff00';
                    context.lineWidth = 2;
                    context.strokeRect(1, 1, 255, 255);

                    var label = 'L' + level + 'X' + x + 'Y' + y;
                    context.font = 'bold 25px Arial';
                    context.textAlign = 'center';
                    context.fillStyle = 'black';
                    context.fillText(label, 127, 127);
                    context.fillStyle = '#ffff00';
                    context.fillText(label, 124, 124);
                }
                return canvas;
            };

            FeatureGridImageryProvider.prototype._getGridKey = function (opts) {
                return opts.level + "_x" + opts.x + "_y" + opts.y;
            };

            FeatureGridImageryProvider.prototype.addImageryCache = function (opts) {
                if (opts.level < this._minimumLevel || opts.level < opts.maxLevel - 1 || Cesium.defined(this._maximumLevel) && opts.level > this._maximumLevel) return;

                //console.log('新增' + JSON.stringify(opts));
                if (this.options.addImageryCache) {
                    opts.key = this._getGridKey(opts);
                    this.options.addImageryCache(opts);
                }
            };

            FeatureGridImageryProvider.prototype.removeImageryCache = function (opts) {
                var hasRemoveAll = opts.maxLevel < this._minimumLevel || Cesium.defined(this._maximumLevel) && opts.level > this._maximumLevel;
                if (hasRemoveAll && this.options.removeAllImageryCache) {
                    this.options.removeAllImageryCache();
                    return;
                }

                //console.log('删除' + JSON.stringify(opts));
                if (this.options.removeImageryCache) {
                    opts.key = this._getGridKey(opts);
                    this.options.removeImageryCache(opts);
                }
            };

            exports.FeatureGridImageryProvider = FeatureGridImageryProvider;

            /***/
}),
/* 96 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawLabel = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(24);

            var _Attr = __webpack_require__(16);

            var attr = _interopRequireWildcard(_Attr);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawLabel = exports.DrawLabel = _Draw.DrawPoint.extend({
                type: 'label',
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        show: false,
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        label: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.label);
                }

            });

            /***/
}),
/* 97 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawModel = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(24);

            var _Attr = __webpack_require__(31);

            var attr = _interopRequireWildcard(_Attr);

            var _Attr2 = __webpack_require__(16);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawModel = exports.DrawModel = _Draw.DrawPoint.extend({
                type: 'model',
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        model: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    if (attribute.style && attribute.style.label) {
                        //同时加文字
                        addattr.label = (0, _Attr2.style2Entity)(attribute.style.label);
                    }

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    this.updateOrientation(style, entity);
                    if (style && style.label) {
                        //同时加文字
                        (0, _Attr2.style2Entity)(style.label, entity.label);
                    }
                    return attr.style2Entity(style, entity.model);
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    this.updateOrientation(this.entity.attribute.style, this.entity);
                },
                //角度更新
                updateOrientation: function updateOrientation(style, entity) {
                    var position = entity.position.getValue(this.viewer.clock.currentTime);
                    if (position == null) return;

                    var heading = Cesium.Math.toRadians(Number(style.heading || 0.0));
                    var pitch = Cesium.Math.toRadians(Number(style.pitch || 0.0));
                    var roll = Cesium.Math.toRadians(Number(style.roll || 0.0));

                    var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
                    entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
                }

            });

            /***/
}),
/* 98 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawCurve = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _Attr = __webpack_require__(29);

            var _Edit = __webpack_require__(58);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //曲线
            var DrawCurve = exports.DrawCurve = _Draw.DrawPolyline.extend({
                type: 'curve',
                //获取编辑对象  
                editClass: _Edit.EditCurve,
                _positions_show: null,
                getDrawPosition: function getDrawPosition() {
                    return this._positions_show;
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    if (this._positions_draw == null || this._positions_draw.length < 3) {
                        this._positions_show = this._positions_draw;
                        return;
                    }

                    this._positions_show = (0, _Attr.line2curve)(this._positions_draw, this.entity.attribute.style.closure);
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   


                    this.entity._positions_draw = this._positions_draw;
                    this.entity._positions_show = this._positions_show;

                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_show;
                    }, false);

                    this._positions_show = null;
                }

            });

            /***/
}),
/* 99 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPolylineVolume = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(51);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(59);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPolylineVolume = exports.DrawPolylineVolume = _Draw.DrawPolyline.extend({
                type: 'polylineVolume',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 9999, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditPolylineVolume,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
                    if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

                    if (attribute.config) {
                        //允许外部传入
                        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
                    } else {
                        this._minPointNum = this._minPointNum_def;
                        this._maxPointNum = this._maxPointNum_def;
                    }

                    var that = this;
                    var addattr = {
                        polylineVolume: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    addattr.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
                        return that.getDrawPosition();
                    }, false);

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    this.entity._positions_draw = this._positions_draw;

                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.polylineVolume);
                },
                updateAttrForDrawing: function updateAttrForDrawing() { },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.polylineVolume.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }

            });

            /***/
}),
/* 100 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawCorridor = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(53);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(60);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawCorridor = exports.DrawCorridor = _Draw.DrawPolyline.extend({
                type: 'corridor',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 9999, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditCorridor,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
                    if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

                    if (attribute.config) {
                        //允许外部传入
                        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
                    } else {
                        this._minPointNum = this._minPointNum_def;
                        this._maxPointNum = this._maxPointNum_def;
                    }

                    var that = this;
                    var addattr = {
                        corridor: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    addattr.corridor.positions = new Cesium.CallbackProperty(function (time) {
                        return that.getDrawPosition();
                    }, false);

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    this.entity._positions_draw = this._positions_draw;

                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.corridor);
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    var style = this.entity.attribute.style;
                    if (!style.clampToGround) {
                        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                        if (maxHight != 0) {
                            this.entity.corridor.height = maxHight;
                            style.height = maxHight;

                            if (style.extrudedHeight) this.entity.corridor.extrudedHeight = maxHight + Number(style.extrudedHeight);
                        }
                    }
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.corridor.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }

            });

            /***/
}),
/* 101 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawRectangle = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(55);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(62);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawRectangle = exports.DrawRectangle = _Draw.DrawPolyline.extend({
                type: 'rectangle',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditRectangle,
                //获取属性处理类
                attrClass: attr,
                getRectangle: function getRectangle() {
                    var positions = this.getDrawPosition();
                    if (positions.length < 2) return null;
                    return Cesium.Rectangle.fromCartesianArray(positions);
                },
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    var that = this;
                    var addattr = {
                        rectangle: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    addattr.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
                        return that.getRectangle();
                    }, false);

                    //线：边线宽度大于1时
                    addattr.polyline = {
                        clampToGround: attribute.style.clampToGround,
                        arcType: Cesium.ArcType.RHUMB,
                        show: false
                    };

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    this.entity._draw_positions = this._positions_draw;
                    this.bindOutline(this.entity); //边线

                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.rectangle);
                },
                bindOutline: function bindOutline(entity) {
                    //是否显示：边线宽度大于1时
                    entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                        return entity.rectangle.outline && entity.rectangle.outline.getValue(time) && entity.rectangle.outlineWidth && entity.rectangle.outlineWidth.getValue(time) > 1;
                    }, false);
                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        if (!entity.polyline.show.getValue(time)) return null;
                        if (!entity._draw_positions) return null;

                        return attr.getOutlinePositions(entity);
                    }, false);
                    entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                        return entity.rectangle.outlineWidth;
                    }, false);
                    entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return entity.rectangle.outlineColor.getValue(time);
                    }, false));
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    var style = this.entity.attribute.style;
                    if (!style.clampToGround) {
                        var maxHight = (0, _point.getMaxHeight)(this.getDrawPosition());
                        if (maxHight != 0) {
                            this.entity.rectangle.height = maxHight;
                            style.height = maxHight;

                            if (style.extrudedHeight) this.entity.rectangle.extrudedHeight = maxHight + Number(style.extrudedHeight);
                        }
                    }
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this._positions_draw;
                    //entity.rectangle.coordinates = this.getRectangle(); 
                    entity.rectangle.coordinates = new Cesium.CallbackProperty(function (time) {
                        if (entity._positions_draw.length < 2) return null;
                        return Cesium.Rectangle.fromCartesianArray(entity._positions_draw);
                    }, false);
                }

            });

            /***/
}),
/* 102 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawCircle = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _Attr = __webpack_require__(40);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(63);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawCircle = exports.DrawCircle = _Draw.DrawPolyline.extend({
                type: 'ellipse',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditCircle,
                //获取属性处理类
                attrClass: attr,
                getShowPosition: function getShowPosition(time) {
                    if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
                    return null;
                },
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (attribute.type == "ellipse") //椭圆
                        this._maxPointNum = 3; else //圆
                        this._maxPointNum = 2;

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getShowPosition(time);
                        }, false),
                        ellipse: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    //线：边线宽度大于1时
                    addattr.polyline = {
                        clampToGround: attribute.style.clampToGround,
                        arcType: Cesium.ArcType.RHUMB,
                        show: false
                    };

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象 
                    this.bindOutline(this.entity); //边线
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.ellipse);
                },
                bindOutline: function bindOutline(entity) {
                    //是否显示：边线宽度大于1时
                    entity.polyline.show = new Cesium.CallbackProperty(function (time) {
                        return entity.ellipse.outline && entity.ellipse.outline.getValue(time) && entity.ellipse.outlineWidth && entity.ellipse.outlineWidth.getValue(time) > 1;
                    }, false);
                    entity.polyline.positions = new Cesium.CallbackProperty(function (time) {
                        if (!entity.polyline.show.getValue(time)) return null;

                        return attr.getOutlinePositions(entity);
                    }, false);
                    entity.polyline.width = new Cesium.CallbackProperty(function (time) {
                        return entity.ellipse.outlineWidth;
                    }, false);
                    entity.polyline.material = new Cesium.ColorMaterialProperty(new Cesium.CallbackProperty(function (time) {
                        return entity.ellipse.outlineColor.getValue(time);
                    }, false));
                },
                updateAttrForDrawing: function updateAttrForDrawing(isLoad) {
                    if (!this._positions_draw) return;

                    if (isLoad) {
                        if (this._positions_draw instanceof Cesium.Cartesian3) {
                            this._positions_draw = [this._positions_draw];
                        }
                        this.addPositionsForRadius(this._positions_draw[0]);
                        return;
                    }

                    if (this._positions_draw.length < 2) return;

                    var style = this.entity.attribute.style;

                    //高度处理
                    if (!style.clampToGround) {
                        var height = this.formatNum(Cesium.Cartographic.fromCartesian(this._positions_draw[0]).height, 2);
                        this.entity.ellipse.height = height;
                        style.height = height;

                        if (style.extrudedHeight) {
                            var extrudedHeight = height + Number(style.extrudedHeight);
                            this.entity.ellipse.extrudedHeight = extrudedHeight;
                        }
                    }

                    //半径处理
                    var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
                    this.entity.ellipse.semiMinorAxis = radius; //短半轴

                    if (this._maxPointNum == 3) {
                        //长半轴
                        var semiMajorAxis;
                        if (this._positions_draw.length == 3) {
                            semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
                        } else {
                            semiMajorAxis = radius;
                        }
                        this.entity.ellipse.semiMajorAxis = semiMajorAxis;

                        style.semiMinorAxis = radius;
                        style.semiMajorAxis = semiMajorAxis;
                    } else {
                        this.entity.ellipse.semiMajorAxis = radius;

                        style.radius = radius;
                    }
                },
                addPositionsForRadius: function addPositionsForRadius(position) {
                    var style = this.entity.attribute.style;

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: this.entity.ellipse.semiMajorAxis.getValue(this.viewer.clock.currentTime), //长半轴
                        semiMinorAxis: this.entity.ellipse.semiMinorAxis.getValue(this.viewer.clock.currentTime), //短半轴
                        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                    });

                    //长半轴上的坐标点
                    var majorPos = outerPositions[1];
                    this._positions_draw.push(majorPos);

                    if (this._maxPointNum == 3) {
                        //椭圆
                        //短半轴上的坐标点 
                        var minorPos = outerPositions[0];
                        this._positions_draw.push(minorPos);
                    }
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this._positions_draw;
                    //this.entity.position = this.getShowPosition();
                    entity.position = new Cesium.CallbackProperty(function (time) {
                        if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
                        return null;
                    }, false);
                }

            });

            /***/
}),
/* 103 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawCylinder = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(54);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(104);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawCylinder = exports.DrawCylinder = _Draw.DrawPolyline.extend({
                type: 'cylinder',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditCylinder,
                //获取属性处理类
                attrClass: attr,
                getShowPosition: function getShowPosition(time) {
                    if (this._positions_draw && this._positions_draw.length > 1) return (0, _point.addPositionsHeight)(this._positions_draw[0], this.entity.cylinder.length.getValue(time) / 2);
                    return null;
                },
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getShowPosition(time);
                        }, false),
                        cylinder: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象 
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.cylinder);
                },
                updateAttrForDrawing: function updateAttrForDrawing(isLoad) {
                    if (!this._positions_draw) return;

                    if (isLoad) {
                        if (this._positions_draw instanceof Cesium.Cartesian3) {
                            this._positions_draw = [this._positions_draw];
                        }
                        this.addPositionsForRadius(this._positions_draw[0]);
                        return;
                    }

                    if (this._positions_draw.length < 2) return;

                    var style = this.entity.attribute.style;

                    //半径处理
                    var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
                    this.entity.cylinder.bottomRadius = radius;

                    style.topRadius = this.entity.cylinder.topRadius.getValue(this.viewer.clock.currentTime);
                    style.bottomRadius = radius;
                },
                addPositionsForRadius: function addPositionsForRadius(position) {
                    var style = this.entity.attribute.style;

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: style.bottomRadius, //长半轴
                        semiMinorAxis: style.bottomRadius //短半轴 
                    });

                    //长半轴上的坐标点 
                    this._positions_draw.push(outerPositions[0]);
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this._positions_draw;
                    //this.entity.position = this.getShowPosition();
                    entity.position = new Cesium.CallbackProperty(function (time) {
                        if (entity._positions_draw && entity._positions_draw.length > 0) return (0, _point.addPositionsHeight)(entity._positions_draw[0], entity.cylinder.length.getValue(time) / 2);
                        return null;
                    }, false);
                }

            });

            /***/
}),
/* 104 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.EditCylinder = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Dragger = __webpack_require__(8);

            var draggerCtl = _interopRequireWildcard(_Dragger);

            var _Tooltip = __webpack_require__(5);

            var _Edit = __webpack_require__(25);

            var _point = __webpack_require__(2);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var EditCylinder = exports.EditCylinder = _Edit.EditPolygon.extend({
                //取enity对象的对应矢量数据
                getGraphic: function getGraphic() {
                    return this.entity.cylinder;
                },
                //修改坐标会回调，提高显示的效率
                changePositionsToCallback: function changePositionsToCallback() {
                    this._positions_draw = this.entity._positions_draw;

                    var time = this.viewer.clock.currentTime;
                    var style = this.entity.attribute.style;

                    style.topRadius = this.getGraphic().topRadius.getValue(time);
                    this.getGraphic().topRadius = new Cesium.CallbackProperty(function (time) {
                        return style.topRadius;
                    }, false);

                    style.bottomRadius = this.getGraphic().bottomRadius.getValue(time);
                    this.getGraphic().bottomRadius = new Cesium.CallbackProperty(function (time) {
                        return style.bottomRadius;
                    }, false);

                    style.length = this.getGraphic().length.getValue(time);
                    this.getGraphic().length = new Cesium.CallbackProperty(function (time) {
                        return style.length;
                    }, false);
                },
                //图形编辑结束后调用
                finish: function finish() {
                    this.entity._positions_draw = this._positions_draw;

                    var style = this.entity.attribute.style;
                    this.getGraphic().topRadius = style.topRadius;
                    this.getGraphic().bottomRadius = style.bottomRadius;
                    this.getGraphic().length = style.length;
                },
                bindDraggers: function bindDraggers() {
                    var that = this;

                    var positions = this.getPosition();
                    var style = this.entity.attribute.style;
                    var time = this.viewer.clock.currentTime;

                    //中心点
                    var index = 0;
                    var position = positions[index];
                    var dragger = draggerCtl.createDragger(this.dataSource, {
                        position: position,
                        onDrag: function onDrag(dragger, position) {
                            positions[dragger.index] = position;

                            //=====全部更新========== 
                            that.updateDraggers();
                        }
                    });
                    dragger.index = index;
                    this.draggers.push(dragger);

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: style.bottomRadius, //长半轴
                        semiMinorAxis: style.bottomRadius, //短半轴
                        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                    });

                    //长半轴上的坐标点
                    index = 1;
                    var majorPos = outerPositions[0];
                    positions[index] = majorPos;
                    var bottomRadiusDragger = draggerCtl.createDragger(this.dataSource, {
                        position: majorPos,
                        type: draggerCtl.PointType.EditAttr,
                        tooltip: _Tooltip.message.dragger.editRadius,
                        onDrag: function onDrag(dragger, position) {
                            positions[dragger.index] = position;

                            var radius = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                            style.bottomRadius = radius;

                            that.updateDraggers();
                        }
                    });
                    bottomRadiusDragger.index = index;
                    this.draggers.push(bottomRadiusDragger);

                    //创建高度拖拽点  
                    index = 2;
                    var position = (0, _point.addPositionsHeight)(positions[0], style.length);
                    positions[index] = position;
                    var draggerTop = draggerCtl.createDragger(this.dataSource, {
                        position: position,
                        type: draggerCtl.PointType.MoveHeight,
                        tooltip: _Tooltip.message.dragger.moveHeight,
                        onDrag: function onDrag(dragger, position) {
                            positions[dragger.index] = position;
                            var length = that.formatNum(Cesium.Cartesian3.distance(positions[0], position), 2);
                            style.length = length;

                            that.updateDraggers();
                        }
                    });
                    draggerTop.index = index;
                    this.draggers.push(draggerTop);

                    // if (style.topRadius > 0) {
                    //     //获取圆（或椭圆）边线上的坐标点数组
                    //     var outerPositionsTop = getEllipseOuterPositions({
                    //         position: position,
                    //         semiMajorAxis: style.topRadius, //长半轴
                    //         semiMinorAxis: style.topRadius, //短半轴
                    //         rotation: Cesium.Math.toRadians(Number(style.rotation || 0)),
                    //     }); 
                    //     //长半轴上的坐标点
                    //     index = 3
                    //     var majorPos = outerPositionsTop[0];
                    //     positions[index] = majorPos;
                    //     var topRadiusDragger = draggerCtl.createDragger(this.dataSource, {
                    //         position: majorPos,
                    //         type: draggerCtl.PointType.EditAttr,
                    //         tooltip: message.dragger.editRadius,
                    //         onDrag: function (dragger, position) {
                    //             var center = positions[2]

                    //             //高度改为圆锥高度
                    //             var height = Cesium.Cartographic.fromCartesian(center).height;
                    //             var car = Cesium.Cartographic.fromCartesian(position)
                    //             position = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, height);
                    //             dragger.position.setValue(position)

                    //             position = position
                    //             positions[dragger.index] = position;

                    //             var radius = that.formatNum(Cesium.Cartesian3.distance(center, position), 2);
                    //             style.topRadius = radius;

                    //             that.updateDraggers();
                    //         }
                    //     });
                    //     topRadiusDragger.index = index;
                    //     this.draggers.push(topRadiusDragger);
                    // }

                }

            });

            /***/
}),
/* 105 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawEllipsoid = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _Attr = __webpack_require__(56);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(64);

            var _polygon = __webpack_require__(12);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawEllipsoid = exports.DrawEllipsoid = _Draw.DrawPolyline.extend({
                type: 'ellipsoid',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 3, //最多允许点的个数 
                //获取编辑对象  
                editClass: _Edit.EditEllipsoid,
                //获取属性处理类
                attrClass: attr,
                getShowPosition: function getShowPosition(time) {
                    if (this._positions_draw && this._positions_draw.length > 0) return this._positions_draw[0];
                    return null;
                },
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getShowPosition(time);
                        }, false),
                        ellipsoid: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象 
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.ellipsoid);
                },
                updateAttrForDrawing: function updateAttrForDrawing(isLoad) {
                    if (!this._positions_draw) return;

                    if (isLoad) {
                        if (this._positions_draw instanceof Cesium.Cartesian3) {
                            this._positions_draw = [this._positions_draw];
                        }
                        this.addPositionsForRadius(this._positions_draw[0]);
                        return;
                    }

                    if (this._positions_draw.length < 2) return;

                    var style = this.entity.attribute.style;

                    //半径处理
                    var radius = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[1]), 2);
                    style.extentRadii = radius; //短半轴
                    style.heightRadii = radius;

                    //长半轴
                    var semiMajorAxis;
                    if (this._positions_draw.length == 3) {
                        semiMajorAxis = this.formatNum(Cesium.Cartesian3.distance(this._positions_draw[0], this._positions_draw[2]), 2);
                    } else {
                        semiMajorAxis = radius;
                    }
                    style.widthRadii = semiMajorAxis;

                    this.updateRadii(style);
                },
                updateRadii: function updateRadii(style) {
                    this.entity.ellipsoid.radii.setValue(new Cesium.Cartesian3(style.extentRadii, style.widthRadii, style.heightRadii));
                },
                addPositionsForRadius: function addPositionsForRadius(position) {
                    var style = this.entity.attribute.style;

                    //获取圆（或椭圆）边线上的坐标点数组
                    var outerPositions = (0, _polygon.getEllipseOuterPositions)({
                        position: position,
                        semiMajorAxis: Number(style.extentRadii), //长半轴
                        semiMinorAxis: Number(style.widthRadii), //短半轴 
                        rotation: Cesium.Math.toRadians(Number(style.rotation || 0))
                    });

                    //长半轴上的坐标点 
                    this._positions_draw.push(outerPositions[0]);

                    //短半轴上的坐标点  
                    this._positions_draw.push(outerPositions[1]);
                },
                //图形绘制结束后调用
                finish: function finish() {
                    // this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象   
                    // this.entity._positions_draw = this._positions_draw;
                    // this.entity.position = this.getShowPosition(); 

                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this._positions_draw;
                    entity.position = new Cesium.CallbackProperty(function (time) {
                        if (entity._positions_draw && entity._positions_draw.length > 0) return entity._positions_draw[0];
                        return null;
                    }, false);
                }

            });

            /***/
}),
/* 106 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawWall = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(14);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(52);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(65);

            var _Util = __webpack_require__(7);

            var Util = _interopRequireWildcard(_Util);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawWall = exports.DrawWall = _Draw.DrawPolyline.extend({
                type: 'wall',
                //坐标位置相关
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 9999, //最多允许点的个数
                //获取编辑对象  
                editClass: _Edit.EditWall,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = [];

                    if (!this._minPointNum_def) this._minPointNum_def = this._minPointNum;
                    if (!this._maxPointNum_def) this._maxPointNum_def = this._maxPointNum;

                    if (attribute.config) {
                        //允许外部传入
                        this._minPointNum = attribute.config.minPointNum || this._minPointNum_def;
                        this._maxPointNum = attribute.config.maxPointNum || this._maxPointNum_def;
                    } else {
                        this._minPointNum = this._minPointNum_def;
                        this._maxPointNum = this._maxPointNum_def;
                    }

                    this.maximumHeights = [];
                    this.minimumHeights = [];

                    var that = this;
                    var addattr = {
                        wall: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    addattr.wall.positions = new Cesium.CallbackProperty(function (time) {
                        return that.getDrawPosition();
                    }, false);
                    addattr.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
                        return that.getMinimumHeights();
                    }, false);
                    addattr.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
                        return that.getMaximumHeights();
                    }, false);

                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象   
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.wall);
                },
                maximumHeights: null,
                getMaximumHeights: function getMaximumHeights(entity) {
                    return this.maximumHeights;
                },
                minimumHeights: null,
                getMinimumHeights: function getMinimumHeights(entity) {
                    return this.minimumHeights;
                },
                updateAttrForDrawing: function updateAttrForDrawing() {
                    var style = this.entity.attribute.style;
                    var position = this.getDrawPosition();
                    var len = position.length;

                    this.maximumHeights = new Array(len);
                    this.minimumHeights = new Array(len);

                    for (var i = 0; i < len; i++) {
                        var height = Cesium.Cartographic.fromCartesian(position[i]).height;
                        this.minimumHeights[i] = height;
                        this.maximumHeights[i] = height + Number(style.extrudedHeight);
                    }
                },
                //获取外部entity的坐标到_positions_draw
                setDrawPositionByEntity: function setDrawPositionByEntity(entity) {
                    var positions = this.getPositions(entity);
                    this._positions_draw = positions;

                    var time = this.viewer.clock.currentTime;
                    this._minimumHeights = entity.wall.minimumHeights && entity.wall.minimumHeights.getValue(time);
                    this._maximumHeights = entity.wall.maximumHeights && entity.wall.maximumHeights.getValue(time);
                    if (!this._minimumHeights || this._minimumHeights.length == 0 || !this._maximumHeights || this._maximumHeights.length == 0) return;

                    entity.attribute.style = entity.attribute.style || {};
                    entity.attribute.style.extrudedHeight = this._maximumHeights[0] - this._minimumHeights[0];
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象  
                    // this.entity.wall.positions = this.getDrawPosition();
                    // this.entity.wall.minimumHeights = this.getMinimumHeights();
                    // this.entity.wall.maximumHeights = this.getMaximumHeights(); 

                    entity._positions_draw = this.getDrawPosition();
                    entity.wall.positions = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);

                    entity._minimumHeights = this.getMinimumHeights();
                    entity.wall.minimumHeights = new Cesium.CallbackProperty(function (time) {
                        return entity._minimumHeights;
                    }, false);

                    entity._maximumHeights = this.getMaximumHeights();
                    entity.wall.maximumHeights = new Cesium.CallbackProperty(function (time) {
                        return entity._maximumHeights;
                    }, false);
                }

            });

            /***/
}),
/* 107 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPlane = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(24);

            var _Attr = __webpack_require__(49);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(66);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPlane = exports.DrawPlane = _Draw.DrawPoint.extend({
                type: 'plane',
                //获取编辑对象  
                editClass: _Edit.EditPlane,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        plane: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.plane);
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.position = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }

            });

            /***/
}),
/* 108 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawBox = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(24);

            var _Attr = __webpack_require__(50);

            var attr = _interopRequireWildcard(_Attr);

            var _Edit = __webpack_require__(67);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawBox = exports.DrawBox = _Draw.DrawPoint.extend({
                type: 'box',
                //获取编辑对象  
                editClass: _Edit.EditBox,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    this._positions_draw = null;

                    var that = this;
                    var addattr = {
                        position: new Cesium.CallbackProperty(function (time) {
                            return that.getDrawPosition();
                        }, false),
                        box: attr.style2Entity(attribute.style),
                        attribute: attribute
                    };
                    this.entity = this.dataSource.entities.add(addattr); //创建要素对象
                    return this.entity;
                },
                style2Entity: function style2Entity(style, entity) {
                    return attr.style2Entity(style, entity.box);
                },
                //图形绘制结束后调用
                finish: function finish() {
                    var entity = this.entity;

                    entity.editing = this.getEditClass(entity); //绑定编辑对象   

                    entity._positions_draw = this.getDrawPosition();
                    entity.position = new Cesium.CallbackProperty(function (time) {
                        return entity._positions_draw;
                    }, false);
                }

            });

            /***/
}),
/* 109 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DrawPModel = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(32);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(31);

            var attr = _interopRequireWildcard(_Attr);

            var _Tooltip = __webpack_require__(5);

            var _EditP = __webpack_require__(68);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var DrawPModel = exports.DrawPModel = _Draw.DrawBase.extend({
                type: 'point',
                //获取编辑对象  
                editClass: _EditP.EditPModel,
                //获取属性处理类
                attrClass: attr,
                //根据attribute参数创建Entity
                createFeature: function createFeature(attribute) {
                    var _this = this;

                    this._positions_draw = Cesium.Cartesian3.ZERO;

                    var style = attribute.style;

                    var modelPrimitive = this.primitives.add(Cesium.Model.fromGltf({
                        url: style.modelUrl,
                        modelMatrix: this.getModelMatrix(style),
                        minimumPixelSize: Cesium.defaultValue(style.minimumPixelSize, 0.0),
                        scale: Cesium.defaultValue(style.scale, 1.0)
                    }));
                    modelPrimitive.readyPromise.then(function (model) {
                        _this.style2Entity(style, _this.entity);
                    });
                    modelPrimitive.attribute = attribute;
                    this.entity = modelPrimitive;

                    return this.entity;
                },
                getModelMatrix: function getModelMatrix(cfg, position) {
                    var hpRoll = new Cesium.HeadingPitchRoll(Cesium.Math.toRadians(cfg.heading || 0), Cesium.Math.toRadians(cfg.pitch || 0), Cesium.Math.toRadians(cfg.roll || 0));
                    var fixedFrameTransform = Cesium.Transforms.eastNorthUpToFixedFrame;

                    var modelMatrix = Cesium.Transforms.headingPitchRollToFixedFrame(position || this._positions_draw, hpRoll, this.viewer.scene.globe.ellipsoid, fixedFrameTransform);
                    // Cesium.Matrix4.multiplyByUniformScale(modelMatrix, Cesium.defaultValue(cfg.scale, 1), modelMatrix);
                    return modelMatrix;
                },
                style2Entity: function style2Entity(style, entity) {
                    entity.modelMatrix = this.getModelMatrix(style, entity.position);
                    return attr.style2Entity(style, entity);
                },
                //绑定鼠标事件
                bindEvent: function bindEvent() {
                    var _this2 = this;

                    this.getHandler().setInputAction(function (event) {
                        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.endPosition, _this2.entity);
                        if (point) {
                            _this2._positions_draw = point;
                            _this2.entity.modelMatrix = _this2.getModelMatrix(_this2.entity.attribute.style);
                        }
                        _this2.tooltip.showAt(event.endPosition, _Tooltip.message.draw.point.start);
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

                    this.getHandler().setInputAction(function (event) {
                        var point = (0, _point.getCurrentMousePosition)(_this2.viewer.scene, event.position, _this2.entity);
                        if (point) {
                            _this2._positions_draw = point;
                            _this2.disable();
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                },
                //图形绘制结束,更新属性
                finish: function finish() {
                    this.entity.modelMatrix = this.getModelMatrix(this.entity.attribute.style);

                    this.entity.editing = this.getEditClass(this.entity); //绑定编辑对象     
                    this.entity.position = this.getDrawPosition();
                }

            });

            /***/
}),
/* 110 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Popup = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            var _util = __webpack_require__(1);

            var _index = __webpack_require__(26);

            var attrUtil = _interopRequireWildcard(_index);

            var _config2Entity = __webpack_require__(28);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //该类不仅仅是popup处理，是所有一些有关单击事件的统一处理入口（从效率考虑）。

            var Popup = exports.Popup = function () {
                //========== 构造方法 ========== 
                function Popup(viewer, options) {
                    var _this = this;

                    _classCallCheck(this, Popup);

                    this.viewer = viewer;
                    this.options = options || {};

                    this._isOnly = true;
                    this._enable = true;
                    this._depthTest = true;
                    this.viewerid = viewer._container.id;
                    this.objPopup = {};

                    this.highlighted = {
                        feature: undefined,
                        originalColor: new Cesium.Color()
                    };
                    this.defaultHighlightedClr = new Cesium.Color.fromCssColorString("#95e40c");

                    //兼容历史接口
                    this.getPopupForConfig = _util.getPopupForConfig;
                    this.getPopup = _util.getPopup;

                    //添加弹出框 
                    var infoDiv = '<div id="' + this.viewerid + '-mapv3d-pupup-all" ></div>';
                    (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

                    this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
                    //单击事件
                    this.handler.setInputAction(function (event) {
                        if (_this.options.onLeftClick) _this.options.onLeftClick(event);

                        _this.mousePickingClick(event);
                    }, Cesium.defaultValue(this.options.popupEventType, Cesium.ScreenSpaceEventType.LEFT_CLICK));
                    //移动事件
                    this.viewer.scene.postRender.addEventListener(this.bind2scene, this);
                }

                //========== 对外属性 ==========  
                //显示单个模式


                _createClass(Popup, [{
                    key: "mousePickingClick",


                    //========== 方法 ========== 

                    //鼠标点击事件
                    value: function mousePickingClick(event) {
                        this.removeFeatureForImageryLayer();
                        this.removeFeatureFor3dtiles();

                        if (this._isOnly) this.close();
                        if (!this._enable) return;

                        var position = event.position;
                        var pickedObject;
                        try {
                            pickedObject = this.viewer.scene.pick(position);
                        } catch (e) { }

                        var isFindPopup = false;

                        //普通entity对象 && viewer.scene.pickPositionSupported
                        if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                            var entity = pickedObject.id;

                            //popup
                            if (Cesium.defined(entity.popup)) {
                                var cartesian;
                                if (entity.billboard || entity.label || entity.point || entity.model) {
                                    //对点状数据做特殊处理，
                                    cartesian = entity.position;
                                } else {
                                    cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                }
                                this.show(entity, cartesian, position);
                                isFindPopup = true;
                            }

                            //加统一的click处理
                            if (entity.click && typeof entity.click === 'function') {
                                entity.click(entity, position);
                            }
                        }

                        //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
                        else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
                            //取属性
                            var attr = {};
                            var names = pickedObject.getPropertyNames();
                            for (var i = 0; i < names.length; i++) {
                                var name = names[i];
                                if (!pickedObject.hasProperty(name)) continue;

                                var val = pickedObject.getProperty(name);
                                if (val == null) continue;
                                attr[name] = val;
                            }

                            var cfg = pickedObject.tileset._config;
                            if (cfg) {
                                //popup
                                if (Cesium.defined(cfg.popup)) {
                                    var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                    var item = {
                                        id: pickedObject._batchId,
                                        popup: {
                                            html: (0, _util.getPopupForConfig)(cfg, attr),
                                            anchor: cfg.popupAnchor || [0, -15]
                                        }
                                    };
                                    this.show(item, cartesian, position);
                                    isFindPopup = true;
                                }

                                //高亮显示单体对象
                                if (cfg.showClickFeature) {
                                    this.showFeatureFor3dtiles(pickedObject, cfg.clickFeatureColor);
                                }

                                //加统一的click处理
                                if (cfg.click && typeof cfg.click === 'function') {
                                    cfg.click({ attr: attr, feature: pickedObject }, position);
                                }
                            }
                        }
                        //primitive对象 
                        else if (pickedObject && Cesium.defined(pickedObject.primitive)) {
                            var primitive = pickedObject.primitive;

                            //popup
                            if (Cesium.defined(primitive.popup)) {
                                var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                this.show(primitive, cartesian, position);
                                isFindPopup = true;
                            }

                            //加统一的click处理
                            if (primitive.click && typeof primitive.click === 'function') {
                                primitive.click(primitive, position);
                            }
                        } else {
                            //单击地图空白（未单击到矢量或模型数据）时
                            if (this.viewer.mapv.click && typeof this.viewer.mapv.click === 'function') {
                                this.viewer.mapv.click(event);
                            }
                        }

                        if (!isFindPopup) {
                            this.pickImageryLayerFeatures(position);
                        }
                    }

                    //瓦片图层上的矢量对象，动态获取

                }, {
                    key: "pickImageryLayerFeatures",
                    value: function pickImageryLayerFeatures(position) {
                        var scene = this.viewer.scene;
                        var pickRay = scene.camera.getPickRay(position); //position : Cesium.Cartesian2
                        var imageryLayerFeaturePromise = scene.imageryLayers.pickImageryLayerFeatures(pickRay, scene);
                        if (!Cesium.defined(imageryLayerFeaturePromise)) {
                            return;
                        }

                        var that = this;
                        Cesium.when(imageryLayerFeaturePromise, function (features) {
                            if (!Cesium.defined(features) || features.length === 0) {
                                return;
                            }

                            //单击选中的要素对象
                            var feature = features[0];
                            if (feature.imageryLayer == null || feature.imageryLayer.config == null) return;
                            var cfg = feature.imageryLayer.config;

                            that.pickFeatures(feature, position, cfg);

                            //加统一的click处理
                            if (cfg.click && typeof cfg.click === 'function') {
                                cfg.click(features, position); //返回所有的features
                            }
                        }, function (e) {
                            console.log(e);
                        });
                    }
                }, {
                    key: "pickFeatures",
                    value: function pickFeatures(feature, viewerPoint, cfg) {
                        //属性
                        var attr = feature.properties;
                        if (!Cesium.defined(attr) && feature.data) {
                            attr = feature.data.properties || feature.data.attributes;
                        }

                        //显示popup
                        var result = (0, _util.getPopupForConfig)(cfg, attr);
                        if (result) {
                            var position = (0, _point.getCurrentMousePosition)(this.viewer.scene, viewerPoint);
                            this.show({
                                id: 'imageryLayerFeaturePromise',
                                popup: {
                                    html: result,
                                    anchor: cfg.popupAnchor || [0, -12]
                                }
                            }, position, viewerPoint);
                        }

                        //显示要素
                        if (cfg.showClickFeature && feature.data) {
                            this.showFeatureForImageryLayer(feature.data, cfg.pickFeatureStyle);
                        }
                    }

                    //popup处理

                }, {
                    key: "show",
                    value: function show(entity, cartesian, viewPoint) {
                        if (entity == null || entity.popup == null) return;

                        if (!cartesian) {
                            //外部直接传入entity调用show时，可以不传入坐标，自动取值
                            cartesian = attrUtil.getCenterPosition(entity);
                        }

                        //对点状贴地数据做特殊处理，
                        var graphic = entity.billboard || entity.label || entity.point || entity.model;
                        if (graphic && graphic.heightReference) {
                            cartesian = (0, _point.getPositionValue)(cartesian);

                            var tempCarto = Cesium.Cartographic.fromCartesian(cartesian);
                            if (tempCarto && tempCarto.height == 0) {
                                var that = this;
                                if (graphic.heightReference._value == Cesium.HeightReference.CLAMP_TO_GROUND) {
                                    //贴地点，重新计算高度
                                    cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
                                        asyn: true,
                                        calback: function calback(newHeight, cartOld) {
                                            //console.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                                            var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                                            that.show(entity, cartesianNew, viewPoint);
                                        }
                                    });
                                    return;
                                } else if (graphic.heightReference._value == Cesium.HeightReference.RELATIVE_TO_GROUND) {
                                    cartesian = (0, _point.setPositionSurfaceHeight)(this.viewer, cartesian, {
                                        relativeHeight: true,
                                        asyn: true,
                                        calback: function calback(newHeight, cartOld) {
                                            //console.log("原始高度为：" + cartOld.height.toFixed(2) + ",贴地高度：" + newHeight.toFixed(2))

                                            var cartesianNew = Cesium.Cartesian3.fromRadians(cartOld.longitude, cartOld.latitude, newHeight);
                                            that.show(entity, cartesianNew, viewPoint);
                                        }
                                    });
                                    return;
                                }
                            }
                        }

                        var eleId = this.getPopupId(entity);
                        this.close(eleId);

                        this.objPopup[eleId] = {
                            id: entity.id,
                            popup: entity.popup,
                            entity: entity,
                            cartesian: cartesian,
                            viewPoint: viewPoint
                        };

                        //显示内容
                        var inhtml;
                        if (_typeof(entity.popup) === 'object') {
                            inhtml = entity.popup.html;
                            this.objPopup[eleId].onAdd = entity.popup.onAdd;
                            this.objPopup[eleId].onRemove = entity.popup.onRemove;
                        } else {
                            inhtml = entity.popup;
                        }
                        if (!inhtml) return;

                        var that = this;
                        if (typeof inhtml === 'function') {
                            //回调方法 
                            inhtml = inhtml(entity, cartesian, function (inhtml) {
                                that._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
                            });
                        }

                        if (!inhtml) return;

                        this._showHtml(inhtml, eleId, entity, cartesian, viewPoint);
                    }
                }, {
                    key: "getItem",
                    value: function getItem(eleId) {
                        return this.objPopup[eleId];
                    }
                }, {
                    key: "_showHtml",
                    value: function _showHtml(inhtml, eleId, entity, cartesian, viewPoint) {
                        (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-pupup-all').append('<div id="' + eleId + '" class="mapv3d-popup">' + '            <a id="' + eleId + '-popup-close" data-id="' + eleId + '" class="mapv3d-popup-close-button mapv3d-popup-color" >×</a>' + '            <div class="mapv3d-popup-content-wrapper mapv3d-popup-background">' + '                <div class="mapv3d-popup-content mapv3d-popup-color">' + inhtml + '</div>' + '            </div>' + '            <div class="mapv3d-popup-tip-container"><div class="mapv3d-popup-tip mapv3d-popup-background"></div></div>' + '        </div>');

                        var that = this;
                        (0, _zepto.zepto)('#' + eleId + '-popup-close').click(function () {
                            var eleId = (0, _zepto.zepto)(this).attr("data-id");
                            that.close(eleId, true);
                        });

                        //计算显示位置 
                        var result = this.updateViewPoint(eleId, cartesian, entity.popup, viewPoint);
                        if (!result && this._depthTest) {
                            this.close(eleId);
                            return;
                        }

                        //popup的DOM添加到页面的回调方法
                        if (this.objPopup[eleId] && this.objPopup[eleId].onAdd) {
                            this.objPopup[eleId].onAdd(eleId);
                        }
                    }
                }, {
                    key: "updateViewPoint",
                    value: function updateViewPoint(eleId, position, popup, point) {
                        var _position = (0, _point.getPositionValue)(position);
                        if (!Cesium.defined(_position)) {
                            return false;
                        }

                        //如果视角和位置都没有变化，直接返回
                        var camera = this.viewer.camera;
                        var _thiscache = _position.x + "=" + _position.y + "-" + _position.z + "-" + camera.position.x + "=" + camera.position.y + "-" + camera.position.z + "-" + camera.heading + "-" + camera.pitch + "-" + camera.roll;
                        if (_thiscache == this._camera_cache) {
                            return true;
                        }
                        this._camera_cache = _thiscache;
                        //如果视角和位置都没有变化，直接返回

                        var newpoint = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, _position);
                        if (Cesium.defined(newpoint)) {
                            point = newpoint;
                            if (this.objPopup[eleId]) this.objPopup[eleId].viewPoint = newpoint;
                        }

                        if (!Cesium.defined(point)) {
                            console.log('wgs84ToWindowCoordinates无法转换为屏幕坐标');
                            return false;
                        }

                        //判断是否在球的背面
                        var scene = this.viewer.scene;
                        if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
                            //三维模式下 
                            var pickRay = scene.camera.getPickRay(point);
                            var cartesianNew = scene.globe.pick(pickRay, scene);

                            if (cartesianNew) {
                                var len = Cesium.Cartesian3.distance(_position, cartesianNew);
                                if (len > 1000 * 1000) return false;
                            }
                        }
                        //判断是否在球的背面

                        //更新html ，实时更新
                        if ((typeof popup === "undefined" ? "undefined" : _typeof(popup)) === 'object' && popup.timeRender && popup.html && typeof popup.html === 'function') {
                            var inhtml = popup.html(this.objPopup[eleId] && this.objPopup[eleId].entity, _position);
                            (0, _zepto.zepto)("#" + eleId + " .mapv3d-popup-content").html(inhtml);
                        }

                        var _dom = (0, _zepto.zepto)("#" + eleId);
                        var x = point.x - _dom.width() / 2;
                        var y = point.y - _dom.height();

                        if (popup && (typeof popup === "undefined" ? "undefined" : _typeof(popup)) === 'object' && popup.anchor) {
                            x += popup.anchor[0];
                            y += popup.anchor[1];
                        }
                        _dom.css('transform', 'translate3d(' + x + 'px,' + y + 'px, 0)');

                        return true;
                    }
                }, {
                    key: "bind2scene",
                    value: function bind2scene() {
                        for (var i in this.objPopup) {
                            var item = this.objPopup[i];
                            var result = this.updateViewPoint(i, item.cartesian, item.popup, item.viewPoint);
                            if (!result && this._depthTest) {
                                this.close(i);
                            }
                        }
                    }
                }, {
                    key: "getPopupId",
                    value: function getPopupId(entity) {
                        var eleId = this.viewerid + 'popup_' + ((entity.id || "") + "").replace(new RegExp("[^0-9a-zA-Z\_]", "gm"), "_");
                        return eleId;
                    }
                }, {
                    key: "close",
                    value: function close(eleId, removFea) {
                        if (!this._isOnly && eleId) {
                            if ((typeof eleId === "undefined" ? "undefined" : _typeof(eleId)) === 'object') {
                                //传入参数是eneity对象                
                                eleId = this.getPopupId(eleId);
                            }

                            for (var i in this.objPopup) {
                                if (eleId == this.objPopup[i].id || eleId == i) {

                                    //popup的DOM从页面移除的回调方法
                                    if (this.objPopup[i] && this.objPopup[i].onRemove) {
                                        this.objPopup[i].onRemove(i);
                                    }

                                    (0, _zepto.zepto)("#" + i).remove();
                                    delete this.objPopup[i];
                                    break;
                                }
                            }
                        } else {
                            for (var i in this.objPopup) {
                                //popup的DOM从页面移除的回调方法
                                if (this.objPopup[i] && this.objPopup[i].onRemove) {
                                    this.objPopup[i].onRemove(i);
                                }
                            }

                            (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-pupup-all').empty();
                            this.objPopup = {};
                        }

                        if (removFea) {
                            this.removeFeatureForImageryLayer();
                            this.removeFeatureFor3dtiles();
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.close();
                        this.viewer.scene.postRender.removeEventListener(this.bind2scene, this);

                        this.handler.destroy();
                        delete this.handler;

                        (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-pupup-all').remove();
                    }

                    //=====================单击高亮对象处理========================
                    //单击Tile瓦片时同步，高亮显示要素处理

                }, {
                    key: "removeFeatureForImageryLayer",
                    value: function removeFeatureForImageryLayer() {
                        if (this.lastShowFeature == null) return;
                        this.viewer.dataSources.remove(this.lastShowFeature);
                        this.lastShowFeature = null;
                    }
                }, {
                    key: "showFeatureForImageryLayer",
                    value: function showFeatureForImageryLayer(item, style) {
                        var that = this;
                        this.removeFeatureForImageryLayer();

                        var feature = item;
                        if (item.geometryType && item.geometryType.indexOf('esri') != -1) {
                            //arcgis图层时 
                            if (JSON.stringify(item.geometry).length < 10000) {
                                //屏蔽大数据，页面卡顿 
                                var L = window.mapv3d.L || window.L;
                                if (L && L.esri) {
                                    feature = L.esri.Util.arcgisToGeoJSON(item.geometry);
                                } else {
                                    console.log('需要引入 mapv-esri 插件解析arcgis标准的json数据！');
                                    return;
                                }
                            }
                        } else if (item.geometry && item.geometry.type) {
                            var L = window.mapv3d.L || window.L;
                            if (L) {
                                //处理数据里面的坐标为4326
                                var geojson = L.geoJSON(item.geometry, {
                                    coordsToLatLng: function coordsToLatLng(coords) {
                                        if (coords[0] > 180 || coords[0] < -180) {
                                            return L.CRS.EPSG3857.unproject(L.point(coords[0], coords[1]));
                                        }
                                        return new L.LatLng(coords[1], coords[0], coords[2]);
                                    }
                                });
                                feature = geojson.toGeoJSON();
                            }
                        }

                        if (feature == null) return;

                        var loadOpts = {
                            clampToGround: Cesium.defaultValue(style.clampToGround, true),
                            fill: new Cesium.Color.fromCssColorString(Cesium.defaultValue(style.color, "#FFFF00")).withAlpha(Number(Cesium.defaultValue(style.opacity, 0.5))),
                            stroke: new Cesium.Color.fromCssColorString(style.outlineColor || style.color || "#FFFFFF").withAlpha(Cesium.defaultValue(style.outlineOpacity, Cesium.defaultValue(style.opacity, 1.0))),
                            strokeWidth: Cesium.defaultValue(style.outlineWidth, 1)
                        };

                        var dataSource = Cesium.GeoJsonDataSource.load(feature, loadOpts);
                        dataSource.then(function (dataSource) {
                            that.viewer.dataSources.add(dataSource);
                            that.lastShowFeature = dataSource;

                            var entities = dataSource.entities.values;
                            (0, _config2Entity.style2Entity)(entities, style);

                            if (Cesium.defined(style.showTime)) {
                                //定时自动关闭
                                setTimeout(function () {
                                    that.removeFeatureForImageryLayer();
                                }, style.showTime);
                            }
                        }).otherwise(function (error) {
                            console.log(error);
                        });
                    }

                    //单击3dtiles单体化，高亮显示构件处理

                }, {
                    key: "removeFeatureFor3dtiles",
                    value: function removeFeatureFor3dtiles() {
                        if (Cesium.defined(this.highlighted.feature)) {
                            try {
                                this.highlighted.feature.color = this.highlighted.originalColor;
                            } catch (ex) { }
                            this.highlighted.feature = undefined;
                        }
                    }
                }, {
                    key: "showFeatureFor3dtiles",
                    value: function showFeatureFor3dtiles(pickedFeature, color) {
                        this.removeFeatureFor3dtiles();
                        this.highlighted.feature = pickedFeature;

                        Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);
                        if (color && typeof color === 'string') color = new Cesium.Color.fromCssColorString(color);
                        pickedFeature.color = color || this.defaultHighlightedClr;
                    }

                    //=================================================


                }, {
                    key: "isOnly",
                    get: function get() {
                        return this._isOnly;
                    },
                    set: function set(val) {
                        this._isOnly = val;
                    }

                    //是否禁用

                }, {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        this._enable = value;
                        if (!value) {
                            this.close();
                        }
                    }

                    //是否打开深度判断（true时判断是否在球背面）

                }, {
                    key: "depthTest",
                    get: function get() {
                        return this._depthTest;
                    },
                    set: function set(value) {
                        this._depthTest = value;
                    }
                }]);

                return Popup;
            }();

            /***/
}),
/* 111 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Tooltip = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var Tooltip = exports.Tooltip = function () {
                //========== 构造方法 ========== 
                function Tooltip(viewer, options) {
                    var _this = this;

                    _classCallCheck(this, Tooltip);

                    this.viewer = viewer;
                    this.options = options || {};

                    this._enable = true;
                    this.viewerid = viewer._container.id;
                    this.tooltipcontentid = this.viewerid + '-mapv3d-tooltip-content';

                    this.highlighted = {
                        feature: undefined,
                        originalColor: new Cesium.Color()
                    };
                    this.defaultHighlightedClr = new Cesium.Color.fromCssColorString("#95e40c");

                    //兼容历史接口
                    this.getTooltipForConfig = _util.getTooltipForConfig;

                    //添加弹出框  
                    var infoDiv = '<div id="' + this.viewerid + '-mapv3d-tooltip-view" class="mapv3d-popup" style="display:none;">' + '     <div class="mapv3d-popup-content-wrapper  mapv3d-popup-background">' + '         <div id="' + this.tooltipcontentid + '" class="mapv3d-popup-content mapv3d-popup-color"></div>' + '     </div>' + '     <div class="mapv3d-popup-tip-container"><div class="mapv3d-popup-tip  mapv3d-popup-background"></div></div>' + '</div> ';
                    (0, _zepto.zepto)("#" + this.viewerid).append(infoDiv);

                    this._tooltipDOM = (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-tooltip-view');
                    this._tooltipContentDOM = (0, _zepto.zepto)('#' + this.tooltipcontentid);

                    var resizeTimer;
                    var cacheTime = Cesium.defaultValue(this.options.cacheTime, 200);
                    this.handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                    this.handler.setInputAction(function (event) {
                        //鼠标移动事件
                        //setTimeout是为了优化效率
                        if (resizeTimer) {
                            clearTimeout(resizeTimer);
                        }
                        resizeTimer = setTimeout(function () {
                            if (_this.options.onMouseMove) _this.options.onMouseMove(event);
                            _this.mouseMovingPicking(event);
                        }, cacheTime);
                    }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                }

                //========== 对外属性 ==========  

                //是否禁用


                _createClass(Tooltip, [{
                    key: "mouseMovingPicking",


                    //========== 方法 ========== 

                    //鼠标移动事件
                    value: function mouseMovingPicking(event) {
                        var _this2 = this;

                        if (!this._enable) return;

                        (0, _zepto.zepto)('.cesium-viewer').css('cursor', '');

                        if (this.viewer.scene.screenSpaceCameraController.enableRotate === false || this.viewer.scene.screenSpaceCameraController.enableTilt === false || this.viewer.scene.screenSpaceCameraController.enableTranslate === false) {
                            this.close();
                            return;
                        }

                        var position = event.endPosition;

                        var entity; //鼠标感知的对象，可能是entity或primitive等 
                        var pickedObject;
                        try {
                            pickedObject = this.viewer.scene.pick(position, 5, 5);
                        } catch (e) { }

                        //普通entity对象 && this.viewer.scene.pickPositionSupported
                        if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                            entity = pickedObject.id;
                        }
                        //单体化3dtiles数据的处理(如：BIM的构件，城市白膜建筑)
                        else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.tileset) && Cesium.defined(pickedObject.getProperty)) {
                            var cfg = pickedObject.tileset._config;
                            if (cfg) {
                                //取属性
                                var attr = {};
                                var names = pickedObject.getPropertyNames();
                                for (var i = 0; i < names.length; i++) {
                                    var name = names[i];
                                    if (!pickedObject.hasProperty(name)) continue;

                                    var val = pickedObject.getProperty(name);
                                    if (val == null) continue;
                                    attr[name] = val;
                                }

                                entity = {
                                    id: pickedObject._batchId,
                                    tooltip: {
                                        html: (0, _util.getTooltipForConfig)(cfg, attr),
                                        anchor: cfg.popupAnchor || [0, -15]
                                    },
                                    attr: attr, //回调方法中用
                                    feature: pickedObject //回调方法中用
                                };
                                if (!cfg.noMouseMove) {
                                    if (cfg.mouseover) entity.mouseover = cfg.mouseover;
                                    if (cfg.mouseover) entity.mouseover = cfg.mouseover;
                                }

                                //高亮显示单体对象 
                                if (cfg.showMoveFeature) {
                                    this.showFeatureFor3dtiles(pickedObject, cfg.moveFeatureColor);
                                }
                            }
                        }
                        //primitive对象 
                        else if (pickedObject && Cesium.defined(pickedObject.primitive)) {
                            entity = pickedObject.primitive;
                        }

                        if (entity) {
                            //存在鼠标感知的对象
                            if (entity.popup || entity.click || entity.cursorCSS) {
                                (0, _zepto.zepto)('.cesium-viewer').css('cursor', entity.cursorCSS || 'pointer');
                            }

                            //加统一的 mouseover 鼠标移入处理
                            if (!entity.noMouseMove) {
                                //排除标识了不处理其移入事件的对象 ，比如高亮对象本身
                                clearTimeout(this.lastTime);
                                this.lastTime = setTimeout(function (e) {
                                    _this2.activateMouseOver(entity, position);
                                }, 20);
                            }

                            //tooltip
                            if (entity.tooltip) {
                                var cartesian = (0, _point.getCurrentMousePosition)(this.viewer.scene, position);
                                this.show(entity, cartesian, position);
                            } else {
                                this.close();
                            }
                        } else {
                            this.close();

                            clearTimeout(this.lastTime);
                            this.lastTime = setTimeout(function (e) {
                                _this2.activateMouseOut();
                            }, 20);
                        }
                    }
                }, {
                    key: "show",
                    value: function show(entity, cartesian, position) {
                        if (entity == null || entity.tooltip == null) return;

                        //计算显示位置 
                        if (position == null) position = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, cartesian);
                        if (position == null) {
                            this.close();
                            return;
                        }

                        if (this._lastTooltipEntity !== entity) {
                            //避免鼠标移动时重复构造DOM
                            //显示内容
                            var inhtml;
                            var onAdd;
                            if (_typeof(entity.tooltip) === 'object') {
                                inhtml = entity.tooltip.html;
                                onAdd = entity.tooltip.onAdd;
                                this.onRemove = entity.tooltip.onRemove;

                                if (entity.tooltip.check) {
                                    if (!entity.tooltip.check()) {
                                        this.close();
                                        return;
                                    }
                                }
                            } else {
                                inhtml = entity.tooltip;
                            }

                            if (typeof inhtml === 'function') {
                                inhtml = inhtml(entity, cartesian); //回调方法
                            }
                            if (!inhtml) return;

                            this._tooltipContentDOM.html(inhtml);
                            this._tooltipDOM.show();

                            //tooltip的DOM添加到页面的回调方法
                            if (onAdd) onAdd(this.tooltipcontentid);
                        }
                        this._lastTooltipEntity = entity;

                        //定位位置
                        var x = position.x - this._tooltipDOM.width() / 2;
                        var y = position.y - this._tooltipDOM.height();

                        var tooltip = entity.tooltip;
                        if (tooltip && (typeof tooltip === "undefined" ? "undefined" : _typeof(tooltip)) === 'object' && tooltip.anchor) {
                            x += tooltip.anchor[0];
                            y += tooltip.anchor[1];
                        } else {
                            y -= 15; //默认偏上10像素
                        }
                        this._tooltipDOM.css('transform', 'translate3d(' + x + 'px,' + y + 'px, 0)');
                    }
                }, {
                    key: "close",
                    value: function close() {
                        if (this.onRemove) {
                            this.onRemove(this.tooltipcontentid);
                            delete this.onRemove;
                        }

                        this._tooltipContentDOM.empty();
                        this._tooltipDOM.hide();

                        this.removeFeatureFor3dtiles();
                        delete this._lastTooltipEntity;
                    }
                }, {
                    key: "activateMouseOver",
                    value: function activateMouseOver(entity, position) {
                        if (this._lastMouseEntity === entity) return;

                        this.activateMouseOut();

                        if (entity.mouseover && typeof entity.mouseover === 'function') entity.mouseover(entity, position);

                        this._lastMouseEntity = entity;
                    }
                }, {
                    key: "activateMouseOut",
                    value: function activateMouseOut() {
                        if (this._lastMouseEntity == null) return;

                        if (this._lastMouseEntity.mouseout && typeof this._lastMouseEntity.mouseout === 'function') this._lastMouseEntity.mouseout(this._lastMouseEntity);
                        this._lastMouseEntity = null;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.close();

                        this.handler.destroy();
                        delete this.handler;

                        this._tooltipDOM.remove();
                        delete this._tooltipDOM;
                        delete this._tooltipContentDOM;

                        if (this._lastMouseEntity) {
                            this._lastMouseEntity = null;
                        }
                        if (this._lastTooltipEntity) {
                            this._lastTooltipEntity = null;
                        }
                    }

                    //=====================高亮对象处理========================
                    //鼠标移入3dtiles单体化，高亮显示构件处理

                }, {
                    key: "removeFeatureFor3dtiles",
                    value: function removeFeatureFor3dtiles() {
                        if (Cesium.defined(this.highlighted.feature)) {
                            try {
                                this.highlighted.feature.color = this.highlighted.originalColor;
                            } catch (ex) { }
                            this.highlighted.feature = undefined;
                        }
                    }
                }, {
                    key: "showFeatureFor3dtiles",
                    value: function showFeatureFor3dtiles(pickedFeature, color) {
                        this.removeFeatureFor3dtiles();
                        this.highlighted.feature = pickedFeature;

                        Cesium.Color.clone(pickedFeature.color, this.highlighted.originalColor);
                        if (color && typeof color === 'string') color = new Cesium.Color.fromCssColorString(color);
                        pickedFeature.color = color || this.defaultHighlightedClr;
                    }

                    //=================================================


                }, {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        this._enable = value;
                        if (!value) {
                            this.close();
                        }
                    }
                }]);

                return Tooltip;
            }();

            /***/
}),
/* 112 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ContextMenu = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            exports.getDefaultContextMenu = getDefaultContextMenu;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            var point = _interopRequireWildcard(_point);

            var _tileset = __webpack_require__(27);

            var tileset = _interopRequireWildcard(_tileset);

            var _util2 = __webpack_require__(1);

            var _util = _interopRequireWildcard(_util2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var ContextMenu = exports.ContextMenu = function () {
                //========== 构造方法 ========== 
                function ContextMenu(viewer, options) {
                    var _this = this;

                    _classCallCheck(this, ContextMenu);

                    this.viewer = viewer;
                    this.viewerid = viewer._container.id;

                    this._enable = true;
                    this.menuIndex = 0;
                    this.objMenu = {};

                    //添加弹出框 
                    var infoDiv = '<div id="' + this.viewerid + '-mapv3d-contextmenu" class="mapv3d-contextmenu open" style="display:none;">\n                            <ul id="' + this.viewerid + '-mapv3d-contextmenu-ul" class="mapv3d-contextmenu-ul"> \n                            </ul>\n                        </div>';
                    (0, _zepto.zepto)("#" + viewer._container.id).append(infoDiv);

                    this._contextmenuDOM = (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-contextmenu');
                    this._contextmenuULDOM = (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-contextmenu-ul');

                    var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                    handler.setInputAction(function (event) {
                        _this.close();
                    }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
                    handler.setInputAction(function (event) {
                        _this.close();
                    }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);
                    handler.setInputAction(function (event) {
                        _this.close();
                    }, Cesium.ScreenSpaceEventType.RIGHT_DOWN);
                    handler.setInputAction(function (event) {
                        _this.close();
                    }, Cesium.ScreenSpaceEventType.PINCH_START);
                    handler.setInputAction(function (event) {
                        _this.close();
                    }, Cesium.ScreenSpaceEventType.WHEEL);
                    handler.setInputAction(function (event) {
                        _this.close();
                        if (!_this._enable) return;

                        var position = event.position;

                        var entity; //鼠标感知的对象，可能是entity或primitive
                        var pickedObject = viewer.scene.pick(position, 5, 5);

                        var contextmenuItems = viewer.mapv.contextmenuItems;
                        //普通entity对象 
                        if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.id) && pickedObject.id instanceof Cesium.Entity) {
                            entity = pickedObject.id;
                            if (Cesium.defined(entity.contextmenuItems)) contextmenuItems = entity.contextmenuItems;
                        }
                        //primitive对象 
                        else if (Cesium.defined(pickedObject) && Cesium.defined(pickedObject.primitive)) {
                            entity = pickedObject.primitive;
                            if (Cesium.defined(entity.contextmenuItems)) contextmenuItems = entity.contextmenuItems;
                        }

                        _this.show(contextmenuItems, position, entity);
                    }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
                    this.handler = handler;
                }

                //========== 对外属性 ==========  

                //是否禁用


                _createClass(ContextMenu, [{
                    key: 'show',


                    //========== 方法 ========== 

                    value: function show(contextmenu, positionMouse, entity) {
                        if (!contextmenu || contextmenu.length == 0) {
                            this.close();
                            return;
                        };

                        var cartesian = point.getCurrentMousePosition(this.viewer.scene, positionMouse);

                        var inhtml = "";
                        for (var i = 0, len = contextmenu.length; i < len; i++) {
                            var item = contextmenu[i];
                            var result = this.getItemHtml(item, {
                                positionMouse: positionMouse,
                                position: cartesian,
                                target: entity
                            });
                            if (result) inhtml += result;
                        }

                        if (inhtml == "") {
                            this.close();
                            return;
                        };

                        var that = this;
                        this._contextmenuULDOM.html(inhtml);
                        (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-contextmenu-ul .contextmenu-item').click(function (e) {
                            var index = Number((0, _zepto.zepto)(this).attr('data-index'));
                            var item = that.objMenu[index];
                            if (item && item.calback) {
                                item.calback({
                                    positionMouse: positionMouse,
                                    position: cartesian,
                                    data: item,
                                    target: entity
                                });
                            }
                            that.close();
                        });

                        //鼠标滑过弹出二级菜单
                        (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-contextmenu-ul .contextmenu-item').mouseover(function (e) {
                            (0, _zepto.zepto)('.mapv3d-sub-menu').hide(); //所有的二级菜单隐藏

                            var sub_menu = this.querySelector('.mapv3d-sub-menu');
                            if (sub_menu) {
                                sub_menu.style.display = 'block';
                            }

                            (0, _zepto.zepto)('#' + that.viewerid + '-mapv3d-contextmenu-ul .active').removeClass('active');
                            (0, _zepto.zepto)(this).addClass('active');
                        });

                        var top = positionMouse.y;
                        var left = positionMouse.x;
                        this._contextmenuDOM.css({ //不显示前，无法计算width和width
                            "top": top,
                            "left": left
                        }).show();

                        var menuHeight = this._contextmenuDOM.height();
                        var menuWidth = this._contextmenuDOM.width();

                        (0, _zepto.zepto)('#' + this.viewerid + '-mapv3d-contextmenu-ul .mapv3d-sub-menu').css({
                            left: menuWidth + 3 + "px"
                        });

                        //判断垂直方向 是否超过了 屏幕高度
                        if (top + menuHeight > this.viewer.scene.canvas.clientHeight) {
                            top -= menuHeight - 10;
                            if (top <= 0) top = 0;
                        } else {
                            top += 10;
                        }

                        //判断水平方向 是否超过了屏幕宽度
                        if (left + menuWidth > this.viewer.scene.canvas.clientWidth) {
                            left -= menuWidth - 10;
                            if (left <= 0) left = 0;
                        } else {
                            left += 10;
                        }

                        this._contextmenuDOM.css({
                            "top": top,
                            "left": left
                        });
                    }
                }, {
                    key: 'getItemHtml',
                    value: function getItemHtml(item, eventresult) {
                        if (item.hasOwnProperty("visible")) {
                            var visible = item.visible;
                            try {
                                if (typeof visible === 'function') {
                                    //回调方法 
                                    eventresult.data = item;
                                    visible = item.visible(eventresult);
                                }
                            } catch (e) {
                                console.log(e);
                            }

                            if (!visible) return null;
                        }

                        var inhtml;
                        if (item.text) {
                            var childrenHtml = '';
                            var childTip = '';
                            if (item.children) {
                                childrenHtml = '<ul class="mapv3d-contextmenu-ul mapv3d-sub-menu">';
                                for (var j = 0, len2 = item.children.length; j < len2; j++) {
                                    var childitem = item.children[j];
                                    eventresult.data = childitem;
                                    var result = this.getItemHtml(childitem, eventresult);
                                    if (result) childrenHtml += result;
                                }
                                childrenHtml += '</ul>';
                                childTip = '&nbsp;&nbsp;<i class="fa fa-caret-right"></i>';
                            }

                            this.menuIndex++;
                            this.objMenu[this.menuIndex] = item;

                            inhtml = '<li class="contextmenu-item" data-index="' + this.menuIndex + '">\n                        <a href="javascript:void(0)"><i class="' + item.iconCls + '"></i>' + item.text + childTip + '</a>\n                        ' + childrenHtml + '\n                    </li>';
                        } else inhtml = '<li class="line"></li>';
                        return inhtml;
                    }
                }, {
                    key: 'close',
                    value: function close() {
                        this._contextmenuDOM.hide();
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.close();

                        this.handler.destroy();
                        delete this.handler;

                        this._contextmenuDOM.remove();

                        delete this._contextmenuULDOM;
                        delete this._contextmenuDOM;
                    }
                }, {
                    key: 'enable',
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        this._enable = value;
                        if (!value) {
                            this.close();
                        }
                    }
                }]);

                return ContextMenu;
            }();

            function getDefaultContextMenu(viewer) {
                return [{
                    text: '查看此处坐标',
                    iconCls: 'fa fa-info-circle',
                    calback: function calback(e) {
                        //笛卡尔
                        var ptX = point.formatNum(e.position.x, 1);
                        var ptY = point.formatNum(e.position.y, 1);
                        var ptZ = point.formatNum(e.position.z, 1);

                        //经纬度
                        var mpt = point.formatPosition(e.position);

                        var inhtml = '\u7ECF\u5EA6\uFF1A' + mpt.x + ', \u7EAC\u5EA6\uFF1A' + mpt.y + ', \u9AD8\u7A0B\uFF1A' + mpt.z + '\n                    <br/>\u7B1B\u5361\u5C14(xyz)\uFF1A' + ptX + ',' + ptY + ',' + ptZ + ' ';

                        _util.alert(inhtml, '位置信息');
                    }
                }, {
                    text: '查看当前视角',
                    iconCls: 'fa fa-camera-retro',
                    calback: function calback(e) {
                        var mpt = point.getCameraView(viewer);
                        _util.alert(JSON.stringify(mpt), '当前视角信息');
                    }
                }, {
                    text: '视角切换',
                    iconCls: 'fa fa-street-view',
                    children: [{
                        text: '绕此处环绕飞行',
                        iconCls: 'fa fa-retweet',
                        visible: function visible(e) {
                            return !point.windingPoint.isStart;
                        },
                        calback: function calback(e) {
                            point.windingPoint.start(viewer, e.position);
                        }
                    }, {
                        text: '关闭环绕飞行',
                        iconCls: 'fa fa-remove',
                        visible: function visible(e) {
                            return point.windingPoint.isStart;
                        },
                        calback: function calback(e) {
                            point.windingPoint.stop();
                        }
                    }, {
                        text: '移动到此处',
                        iconCls: 'fa fa-send-o',
                        calback: function calback(e) {
                            var range = viewer.scene.camera.positionCartographic.height;
                            if (range > 5000) range = 5000;

                            viewer.camera.lookAt(e.position, new Cesium.HeadingPitchRange(viewer.camera.heading, viewer.camera.pitch, range));
                            viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);
                        }
                    }, {
                        text: '第一视角站到此处',
                        iconCls: 'fa fa-male',
                        calback: function calback(e) {
                            viewer.camera.flyTo({
                                destination: point.addPositionsHeight(e.position, 10), //升高10米
                                orientation: {
                                    heading: Cesium.Math.toRadians(0), //绕垂直于地心的轴旋转
                                    pitch: Cesium.Math.toRadians(10), //绕纬度线旋转
                                    roll: Cesium.Math.toRadians(0) //绕经度线旋转
                                }
                            });
                        }
                    }, {
                        text: '开启键盘漫游',
                        iconCls: 'fa fa-keyboard-o',
                        visible: function visible(e) {
                            return !viewer.mapv.keyboardRoam.enable;
                        },
                        calback: function calback(e) {
                            viewer.mapv.keyboardRoam.enable = true;
                        }
                    }, {
                        text: '关闭键盘漫游',
                        iconCls: 'fa fa-keyboard-o',
                        visible: function visible(e) {
                            return viewer.mapv.keyboardRoam.enable;
                        },
                        calback: function calback(e) {
                            viewer.mapv.keyboardRoam.enable = false;
                        }
                    }]
                }, {
                    text: '三维模型',
                    iconCls: 'fa fa-building-o',
                    visible: function visible(e) {
                        var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                        return Cesium.defined(model);
                    },
                    children: [{
                        text: '显示三角网',
                        iconCls: 'fa fa-connectdevelop',
                        visible: function visible(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            return !model.debugWireframe;
                        },
                        calback: function calback(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            model.debugWireframe = true;
                        }
                    }, {
                        text: '关闭三角网',
                        iconCls: 'fa fa-connectdevelop',
                        visible: function visible(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            return model.debugWireframe;
                        },
                        calback: function calback(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            model.debugWireframe = false;
                        }
                    }, {
                        text: '显示包围盒',
                        iconCls: 'fa fa-codepen',
                        visible: function visible(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            return !model.debugShowBoundingVolume;
                        },
                        calback: function calback(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            model.debugShowBoundingVolume = true;
                        }
                    }, {
                        text: '关闭包围盒',
                        iconCls: 'fa fa-codepen',
                        visible: function visible(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            return model.debugShowBoundingVolume;
                        },
                        calback: function calback(e) {
                            var model = tileset.pick3DTileset(viewer, e.position); //拾取绘制返回的模型
                            model.debugShowBoundingVolume = false;
                        }
                    }]
                }, {
                    text: '地形服务',
                    iconCls: 'fa fa-globe',
                    visible: function visible(e) {
                        return !Cesium.defined(e.target);
                    },
                    children: [{
                        text: '开启地形',
                        iconCls: 'fa fa-rss',
                        visible: function visible(e) {
                            return !viewer.mapv.hasTerrain();
                        },
                        calback: function calback(e) {
                            viewer.mapv.updateTerrainProvider(true);
                        }
                    }, {
                        text: '关闭地形',
                        iconCls: 'fa fa-rss',
                        visible: function visible(e) {
                            return viewer.mapv.hasTerrain();
                        },
                        calback: function calback(e) {
                            viewer.mapv.updateTerrainProvider(false);
                        }
                    }, {
                        text: '显示三角网',
                        iconCls: 'fa fa-connectdevelop',
                        visible: function visible(e) {
                            return !viewer.scene.globe._surface.tileProvider._debug.wireframe;
                        },
                        calback: function calback(e) {
                            viewer.scene.globe._surface.tileProvider._debug.wireframe = true;
                        }
                    }, {
                        text: '关闭三角网',
                        iconCls: 'fa fa-connectdevelop',
                        visible: function visible(e) {
                            return viewer.scene.globe._surface.tileProvider._debug.wireframe;
                        },
                        calback: function calback(e) {
                            viewer.scene.globe._surface.tileProvider._debug.wireframe = false;
                        }
                    }]
                }, {
                    text: '场景设置',
                    iconCls: 'fa fa-gear',
                    children: [{
                        text: '开启深度监测',
                        iconCls: 'fa fa-eye-slash',
                        visible: function visible(e) {
                            return !viewer.scene.globe.depthTestAgainstTerrain;
                        },
                        calback: function calback(e) {
                            viewer.scene.globe.depthTestAgainstTerrain = true;
                        }
                    }, {
                        text: '关闭深度监测',
                        iconCls: 'fa fa-eye',
                        visible: function visible(e) {
                            return viewer.scene.globe.depthTestAgainstTerrain;
                        },
                        calback: function calback(e) {
                            viewer.scene.globe.depthTestAgainstTerrain = false;
                        }
                    }, {
                        text: '开启光照效果',
                        iconCls: 'fa fa-bullseye',
                        visible: function visible(e) {
                            return !viewer.shadows;
                        },
                        calback: function calback(e) {
                            viewer.shadows = true;
                            viewer.terrainShadows = Cesium.ShadowMode.ENABLED;
                            viewer.scene.globe.enableLighting = true;
                        }
                    }, {
                        text: '关闭光照效果',
                        iconCls: 'fa fa-sun-o',
                        visible: function visible(e) {
                            return viewer.shadows;
                        },
                        calback: function calback(e) {
                            viewer.shadows = false;
                            viewer.terrainShadows = Cesium.ShadowMode.RECEIVE_ONLY;
                            viewer.scene.globe.enableLighting = false;
                        }
                    }, {
                        text: '开启大气渲染',
                        iconCls: 'fa fa-cloud',
                        visible: function visible(e) {
                            return !viewer.scene.skyAtmosphere.show;
                        },
                        calback: function calback(e) {

                            viewer.scene.skyAtmosphere.show = true;
                            viewer.scene.globe.showGroundAtmosphere = true;
                        }
                    }, {
                        text: '关闭大气渲染',
                        iconCls: 'fa fa-cloud',
                        visible: function visible(e) {
                            return viewer.scene.skyAtmosphere.show;
                        },
                        calback: function calback(e) {
                            viewer.scene.skyAtmosphere.show = false;
                            viewer.scene.globe.showGroundAtmosphere = false;
                        }
                    }, {
                        text: '场景截图',
                        iconCls: 'fa fa-download',
                        calback: function calback(e) {
                            viewer.mapv.expImage();
                        }
                    }]
                }];
            }

            /***/
}),
/* 113 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Location = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            var point = _interopRequireWildcard(_point);

            var _util2 = __webpack_require__(1);

            var _util = _interopRequireWildcard(_util2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //“鼠标经纬度提示”控件
            var Location = exports.Location = function () {
                //========== 构造方法 ========== 
                function Location(viewer, options) {
                    var _this = this;

                    _classCallCheck(this, Location);

                    this.viewer = viewer;
                    this.options = options;

                    this.locationFormat = options.format || '<div>经度:{x}</div> <div>纬度:{y}</div> <div>海拔：{z}米</div> <div>方向：{heading}度</div> <div>俯仰角：{pitch}度</div>  <div>视高：{height}米</div>';

                    var containerid = viewer._container.id + "-mapv3d-location";
                    var inhtml = '<div id="' + containerid + '"  class="mapv3d-locationbar animation-slide-bottom no-print" ><div class="mapv3d-locationbar-content"></div></div>';
                    (0, _zepto.zepto)("#" + viewer._container.id).append(inhtml);

                    this._dom = (0, _zepto.zepto)('#' + containerid);
                    this._domContent = (0, _zepto.zepto)('#' + containerid + " .mapv3d-locationbar-content");

                    if (options.style) this._dom.css(options.style); else {
                        this._dom.css({
                            "left": viewer.animation ? "170px" : "0",
                            "right": "0",
                            "bottom": viewer.timeline ? "25px" : "0"
                        });
                    }
                    this._visible = true;

                    this.locationData = {};
                    this.locationData.height = viewer.camera.positionCartographic.height.toFixed(1);
                    this.locationData.heading = Cesium.Math.toDegrees(viewer.camera.heading).toFixed(0);
                    this.locationData.pitch = Cesium.Math.toDegrees(viewer.camera.pitch).toFixed(0);

                    if (Cesium.defaultValue(this.options.bindEvent, true)) {
                        var cacheTime = Cesium.defaultValue(this.options.cacheTime, 200);
                        var resizeTimer;
                        var handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
                        handler.setInputAction(function (movement) {
                            //setTimeout是为了优化效率
                            if (resizeTimer) {
                                clearTimeout(resizeTimer);
                            }
                            resizeTimer = setTimeout(function () {
                                _this.updateData(movement);
                            }, cacheTime);
                        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                        this.handler = handler;
                    }

                    //帧率
                    if (options.fps) {
                        // 帧率的计算借助了Cesium中的东西，需要开启debugShowFramesPerSecond
                        viewer.scene.debugShowFramesPerSecond = true;

                        var timeTik = setInterval(function () {
                            if (!viewer.scene._performanceDisplay) return;
                            clearInterval(timeTik);

                            var domFPS = (0, _zepto.zepto)(".cesium-performanceDisplay");

                            //修改样式
                            domFPS.addClass("mapv3d-locationbar-content").removeClass("cesium-performanceDisplay");

                            //移除空节点
                            domFPS.children(".cesium-performanceDisplay-throttled").remove();

                            //添加到状态栏
                            _this._dom.prepend(domFPS);
                        }, 500);
                    }

                    //相机移动结束事件
                    viewer.scene.camera.changed.addEventListener(this.updaeCamera, this);
                }

                //========== 对外属性 ==========  
                //是否显示


                _createClass(Location, [{
                    key: 'updateData',


                    //========== 方法 ==========  
                    value: function updateData(movement) {
                        if (!this._visible) return;

                        var cartesian = point.getCurrentMousePosition(this.viewer.scene, movement.endPosition);
                        if (!cartesian) return;

                        var cartographic = Cesium.Cartographic.fromCartesian(cartesian);

                        this.locationData.z = (cartographic.height / this.viewer.scene.terrainExaggeration).toFixed(1);

                        var jd = Cesium.Math.toDegrees(cartographic.longitude);
                        var wd = Cesium.Math.toDegrees(cartographic.latitude);

                        switch (this.options.crs) {
                            default:
                                //和地图一致的原坐标
                                var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 6;
                                this.locationData.x = jd.toFixed(fixedLen);
                                this.locationData.y = wd.toFixed(fixedLen);
                                break;
                            case "degree":
                                //度分秒形式
                                this.locationData.x = _util.formatDegree(jd);
                                this.locationData.y = _util.formatDegree(wd);
                                break;
                            case "project":
                                //投影坐标
                                var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 0;
                                this.locationData.x = cartesian.x.toFixed(fixedLen);
                                this.locationData.y = cartesian.y.toFixed(fixedLen);
                                break;

                            case "wgs":
                                //标准wgs84格式坐标
                                var fixedLen = this.options.hasOwnProperty('toFixed') ? this.options.toFixed : 6;
                                var wgsPoint = point2wgs({ x: jd, y: wd }); //坐标转换为wgs 
                                this.locationData.x = wgsPoint.x.toFixed(fixedLen);
                                this.locationData.y = wgsPoint.y.toFixed(fixedLen);
                                break;
                            case "wgs-degree":
                                //标准wgs84格式坐标
                                var wgsPoint = point2wgs({ x: jd, y: wd }); //坐标转换为wgs 
                                this.locationData.x = _util.formatDegree(wgsPoint.x);
                                this.locationData.y = _util.formatDegree(wgsPoint.y);
                                break;
                        }

                        var inhtml;
                        if (typeof this.locationFormat === 'function') {
                            //回调方法 
                            inhtml = this.locationFormat(this.locationData);
                        } else {
                            inhtml = _util.template(this.locationFormat, this.locationData);
                        }
                        this._domContent.html(inhtml);
                    }
                }, {
                    key: 'updaeCamera',
                    value: function updaeCamera() {
                        if (!this._visible) return;

                        this.locationData.height = this.viewer.camera.positionCartographic.height.toFixed(1);
                        this.locationData.heading = Cesium.Math.toDegrees(this.viewer.camera.heading).toFixed(0);
                        this.locationData.pitch = Cesium.Math.toDegrees(this.viewer.camera.pitch).toFixed(0);

                        if (this.locationData.x == null) return;

                        var inhtml;
                        if (typeof this.locationFormat === 'function') {
                            //回调方法 
                            inhtml = this.locationFormat(this.locationData);
                        } else {
                            inhtml = _util.template(this.locationFormat, this.locationData);
                        }

                        this._domContent.html(inhtml);
                    }
                }, {
                    key: 'css',
                    value: function css(style) {
                        this._dom.css(style);
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        //相机移动结束事件
                        this.viewer.scene.camera.changed.removeEventListener(this.updaeCamera, this);

                        if (this.options.fps) {
                            this.viewer.scene.debugShowFramesPerSecond = false;
                        }

                        if (this.handler) {
                            this.handler.destroy();
                            delete this.handler;
                        }

                        this._dom.remove();
                    }
                }, {
                    key: 'show',
                    get: function get() {
                        return this._visible;
                    },
                    set: function set(value) {
                        this._visible = value;

                        if (value) this._dom.show(); else this._dom.hide();
                    }
                }]);

                return Location;
            }();

            /***/
}),
/* 114 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MouseZoomStyle = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            var point = _interopRequireWildcard(_point);

            var _util2 = __webpack_require__(1);

            var _util = _interopRequireWildcard(_util2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //鼠标旋转、放大时的美化图标
            var MouseZoomStyle = exports.MouseZoomStyle = function () {
                //========== 构造方法 ========== 
                function MouseZoomStyle(viewer, options) {
                    var _this = this;

                    _classCallCheck(this, MouseZoomStyle);

                    this.viewer = viewer;
                    this.options = options || {};

                    var containerid = viewer._container.id + '-mapv3d-mousezoom';
                    (0, _zepto.zepto)("#" + viewer._container.id).append('<div id="' + containerid + '" class="mapv3d-mousezoom"><div class="zoomimg"/></div>');
                    this._dom = (0, _zepto.zepto)('#' + containerid);

                    this.enable = Cesium.defaultValue(this.options.enable, true);

                    var timetik = -1;
                    var that = this;
                    var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
                    handler.setInputAction(function (evnet) {
                        if (!_this._enable) return;
                        _this._dom.addClass('mapv3d-mousezoom-visible');
                        clearTimeout(timetik);
                        timetik = setTimeout(function () {
                            that._dom.removeClass('mapv3d-mousezoom-visible');
                        }, 200);
                    }, Cesium.ScreenSpaceEventType.WHEEL);

                    handler.setInputAction(function (evnet) {
                        if (!_this._enable) return;
                        var position = point.getCurrentMousePosition(viewer.scene, evnet.position);
                        if (!position) return;

                        if (viewer.camera.positionCartographic.height > viewer.scene.screenSpaceCameraController.minimumCollisionTerrainHeight) return;

                        handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                        clearTimeout(timetik);
                        _this._dom.css({
                            top: evnet.position.y + 'px',
                            left: evnet.position.x + 'px'
                        });
                        _this._dom.addClass('mapv3d-mousezoom-visible');
                    }, Cesium.ScreenSpaceEventType.MIDDLE_DOWN);

                    handler.setInputAction(function (evnet) {
                        _this._dom.removeClass('mapv3d-mousezoom-visible');
                        handler.setInputAction(function (evnet) {
                            that._dom.css({
                                top: evnet.endPosition.y + 'px',
                                left: evnet.endPosition.x + 'px'
                            });
                        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                    }, Cesium.ScreenSpaceEventType.MIDDLE_UP);

                    this.handler = handler;
                }

                //========== 对外属性 ==========  

                //是否显示


                _createClass(MouseZoomStyle, [{
                    key: 'destroy',


                    //========== 方法 ==========  

                    value: function destroy() {
                        if (this.handler) {
                            this.handler.destroy();
                            delete this.handler;
                        }

                        this._dom.remove();
                        delete this._dom;
                        delete this.viewer;
                    }
                }, {
                    key: 'enable',
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(val) {
                        this._enable = val;
                        if (val) this._dom.show(); else this._dom.hide();
                    }
                }]);

                return MouseZoomStyle;
            }();

            /***/
}),
/* 115 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GaodePOIGeocoder = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //高德POI查询 类
            var GaodePOIGeocoder = exports.GaodePOIGeocoder = function () {
                //========== 构造方法 ========== 
                function GaodePOIGeocoder(options) {
                    _classCallCheck(this, GaodePOIGeocoder);

                    options = options || {};
                    this.citycode = options.citycode || '';
                    //内置高德地图服务key，建议后期修改为自己申请的
                    this.gaodekey = options.key || ["f2fedb9b08ae13d22f1692cd472d345e", "81825d9f2bafbb14f235d2779be90c0f", "b185732970a4487de104fa71ef575f29", "2e6ca4aeb6867fb637a5bee8333e5d3a", "027187040fa924e56048468aaa77b62c"];
                }

                //========== 对外属性 ==========  
                // //裁剪距离 
                // get distance() {
                //     return this._distance || 0;
                // }
                // set distance(val) {
                //     this._distance = val; 
                // }

                //========== 方法 ========== 

                _createClass(GaodePOIGeocoder, [{
                    key: 'getOneKey',
                    value: function getOneKey() {
                        var arr = this.gaodekey;
                        var n = Math.floor(Math.random() * arr.length + 1) - 1;
                        return arr[n];
                    }
                }, {
                    key: 'geocode',
                    value: function geocode(query, geocodeType) {
                        var that = this;

                        var key = this.getOneKey();

                        var resource = new Cesium.Resource({
                            url: 'http://restapi.amap.com/v3/place/text',
                            queryParameters: {
                                key: key,
                                city: this.citycode,
                                //citylimit: true,
                                keywords: query
                            }
                        });

                        return resource.fetchJson().then(function (results) {
                            if (results.status == 0) {
                                (0, _util.msg)("请求失败(" + results.infocode + ")：" + results.info);
                                return;
                            }
                            if (results.pois.length === 0) {
                                (0, _util.msg)("未查询到“" + query + "”相关数据！");
                                return;
                            }

                            var height = 3000;
                            if (that.viewer.camera.positionCartographic.height < height) height = that.viewer.camera.positionCartographic.height;

                            return results.pois.map(function (resultObject) {
                                var arrjwd = resultObject.location.split(",");
                                arrjwd = pointconvert.gcj2wgs(arrjwd); //纠偏
                                var lnglat = that.viewer.mapv.point2map({ x: arrjwd[0], y: arrjwd[1] });

                                return {
                                    displayName: resultObject.name,
                                    destination: Cesium.Cartesian3.fromDegrees(lnglat.x, lnglat.y, height)
                                };
                            });
                        });
                    }
                }]);

                return GaodePOIGeocoder;
            }();

            /***/
}),
/* 116 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FloodByEntity = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            var _Attr = __webpack_require__(19);

            var polygonAttr = _interopRequireWildcard(_Attr);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //淹没分析(平面)类
            var FloodByEntity = exports.FloodByEntity = function () {
                //========== 构造方法 ========== 
                function FloodByEntity(viewer) {
                    _classCallCheck(this, FloodByEntity);

                    this.viewer = viewer;
                }

                //========== 对外属性 ==========  
                //高度


                _createClass(FloodByEntity, [{
                    key: 'start',


                    //========== 方法 ========== 


                    //开发分析
                    value: function start(entity, options) {
                        this.stop();

                        this.entity = entity;
                        this.options = options;

                        var that = this;

                        this._last_depthTestAgainstTerrain = this.viewer.scene.globe.depthTestAgainstTerrain;
                        this.viewer.scene.globe.depthTestAgainstTerrain = true;

                        this.extrudedHeight = options.height;
                        this.entity.polygon.extrudedHeight = new Cesium.CallbackProperty(function (time) {
                            return that.extrudedHeight;
                        }, false);

                        //修改高度值
                        var positions = polygonAttr.getPositions(this.entity);
                        positions = (0, _point.setPositionsHeight)(positions, options.height);
                        this.entity.polygon.hierarchy = new Cesium.PolygonHierarchy(positions);

                        this.timeIdx = setInterval(function () {
                            if (that.extrudedHeight > that.options.maxHeight) {
                                if (options.onStop) options.onStop();

                                that.stop();
                                return;
                            }
                            that.extrudedHeight += that.options.speed;

                            if (options.onChange) options.onChange(that.extrudedHeight);
                        }, 100);
                    }
                    //停止分析

                }, {
                    key: 'stop',
                    value: function stop() {
                        clearInterval(this.timeIdx);
                    }

                    //清除分析

                }, {
                    key: 'clear',
                    value: function clear() {
                        this.stop();
                        if (this._last_depthTestAgainstTerrain !== null) this.viewer.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
                        this.entity = null;
                    }

                    //更新高度

                }, {
                    key: 'updateHeight',
                    value: function updateHeight(height) {
                        this.extrudedHeight = height;
                    }
                }, {
                    key: 'height',
                    get: function get() {
                        return this.extrudedHeight;
                    },
                    set: function set(val) {
                        this.extrudedHeight = val;
                    }
                }]);

                return FloodByEntity;
            }();

            /***/
}),
/* 117 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FloodByTerrain = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //地形淹没（材质）分析 类
            var FloodByTerrain = exports.FloodByTerrain = function () {
                //========== 构造方法 ========== 
                function FloodByTerrain(viewer, options) {
                    _classCallCheck(this, FloodByTerrain);

                    this.viewer = viewer;
                    options = options || {};

                    var defaultOpts = {
                        floodVar: [0, 0, 0, 500], //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
                        ym_pos_x: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        ym_pos_y: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        ym_pos_z: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        rect_flood: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
                        floodSpeed: 1, //淹没速度
                        ym_max_index: 0, //点选点的个数
                        globe: true, //是否全球淹没
                        showElseArea: true //是否显示非淹没区域
                    };

                    this.minHeight = Cesium.defaultValue(options.minHeight, Cesium.clone(defaultOpts.minHeight));
                    this.maxHeight = Cesium.defaultValue(options.maxHeight, Cesium.clone(defaultOpts.maxHeight));
                    this._positions = Cesium.defaultValue(options.positions, Cesium.clone(defaultOpts.positions));
                    if (!this._checkArgs()) return;

                    this.floodVar = Cesium.defaultValue(options.floodVar, Cesium.clone(defaultOpts.floodVar));
                    this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, Cesium.clone(defaultOpts.ym_pos_x));
                    this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, Cesium.clone(defaultOpts.ym_pos_y));
                    this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, Cesium.clone(defaultOpts.ym_pos_z));
                    this.rect_flood = Cesium.defaultValue(options.rect_flood, Cesium.clone(defaultOpts.rect_flood));
                    this.ym_max_index = Cesium.defaultValue(options.ym_max_index, Cesium.clone(defaultOpts.ym_max_index));
                    this._globe = Cesium.defaultValue(options.globe, Cesium.clone(defaultOpts.globe));
                    this._speed = Cesium.defaultValue(options.speed, Cesium.clone(defaultOpts.floodSpeed));
                    this._visibleOutArea = Cesium.defaultValue(options.visibleOutArea, Cesium.clone(defaultOpts.showElseArea));
                    this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
                    this.defaultShow = Cesium.defaultValue(options.show, true);
                    this.onStop = Cesium.defaultValue(options.onStop, null);
                    this.height = Cesium.defaultValue(options.height, null);
                    this._init();
                }

                //========== 对外属性 ==========  
                //分析参数


                _createClass(FloodByTerrain, [{
                    key: "_checkArgs",

                    //========== 方法 ========== 

                    //检查参数
                    value: function _checkArgs() {
                        if (this.minHeight == undefined || this.maxHeight == undefined) {
                            console.log("请确认高度值为数值！");
                            return false;
                        }
                        if (this.minHeight > this.maxHeight) {
                            //互相交换数据
                            var temp = this.minHeight;
                            this.minHeight = this.maxHeight;
                            this.maxHeight = temp;
                        }
                        return true;
                    }
                    //初始化

                }, {
                    key: "_init",
                    value: function _init() {
                        if (!this._positions || this._positions.length == 0) return;
                        this._prepareFlood(this._positions);
                        this._setFloodVar();
                        this._startFlood();
                        this._activeFloodSpeed();
                    }

                    //初始化没传顶点，后面设置顶点

                }, {
                    key: "setPositions",
                    value: function setPositions(positions) {
                        if (!positions || positions.length == 0) return;
                        this._prepareFlood(positions);
                        this._setFloodVar();
                        this._startFlood();
                        this._activeFloodSpeed();
                    }

                    //激活淹没动画

                }, {
                    key: "_activeFloodSpeed",
                    value: function _activeFloodSpeed() {
                        var that = this;
                        if (!this.activeFlooding) {
                            this.activeFlooding = function () {
                                if (that.height) {
                                    that.floodVar[1] = that.height();
                                } else {
                                    that.floodVar[1] += that.speed / 50; //50帧每秒
                                }
                                if (that.floodVar[1] > that.floodVar[2]) {
                                    that.floodVar[1] = that.floodVar[2];
                                    that.cancelFloodSpeed();
                                    that.onStop && that.onStop();
                                }
                                if (that.floodVar[1] < that.floodVar[0]) {
                                    that.floodVar[1] = that.floodVar[0];
                                    that.cancelFloodSpeed();
                                    that.onStop && that.onStop();
                                }
                                that.floodAnalysis.floodVar[1] = that.floodVar[1];
                            };
                            this.viewer.clock.onTick.addEventListener(this.activeFlooding);
                        }
                    }

                    //暂停淹没动画

                }, {
                    key: "cancelFloodSpeed",
                    value: function cancelFloodSpeed() {
                        this.viewer.clock.onTick.removeEventListener(this.activeFlooding);
                        this.activeFlooding = null;
                    }
                    //重新淹没

                }, {
                    key: "reFlood",
                    value: function reFlood() {
                        this.floodVar[1] = this.floodVar[0];
                        this._activeFloodSpeed();
                    }
                }, {
                    key: "_switchShow",
                    value: function _switchShow() {
                        if (this.show) {
                            this.viewer.scene.globe.material = Cesium.Material.fromType('YanMo');
                        } else {
                            this.viewer.scene.globe.material = null;
                        }
                    }

                    //与处理顶点数组

                }, {
                    key: "_prepareFlood",
                    value: function _prepareFlood(arr) {
                        this.ym_pos_arr = arr;
                        var len = arr.length;
                        if (len == 0) return;
                        this.ym_max_index = len;
                        var minX = 99999999;
                        var minY = 99999999;
                        var minZ = 99999999;
                        var maxX = -99999999;
                        var maxY = -99999999;
                        var maxZ = -99999999;
                        for (var i = 0; i < len; i++) {
                            if (arr[i]) {
                                this.ym_pos_x[i] = arr[i].x;
                                this.ym_pos_y[i] = arr[i].y;
                                this.ym_pos_z[i] = arr[i].z;

                                if (arr[i].x > maxX) {
                                    maxX = arr[i].x;
                                }
                                if (arr[i].x < minX) {
                                    minX = arr[i].x;
                                }

                                if (arr[i].y > maxY) {
                                    maxY = arr[i].y;
                                }
                                if (arr[i].y < minY) {
                                    minY = arr[i].y;
                                }

                                if (arr[i].z > maxZ) {
                                    maxZ = arr[i].z;
                                }
                                if (arr[i].z < minZ) {
                                    minZ = arr[i].z;
                                }
                            } else {
                                this.ym_pos_x[i] = 0.0;
                                this.ym_pos_y[i] = 0.0;
                                this.ym_pos_z[i] = 0.0;
                            }
                        }
                        var chaNum = this.boundingSwell;
                        this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
                    }
                    //设置淹没高度

                }, {
                    key: "_setFloodVar",
                    value: function _setFloodVar() {
                        this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
                    }
                    //开始淹没

                }, {
                    key: "_startFlood",
                    value: function _startFlood() {
                        this.floodAnalysis.floodVar[0] = this.floodVar[0];
                        this.floodAnalysis.floodVar[1] = this.floodVar[1];
                        this.floodAnalysis.ym_pos_x = this.ym_pos_x;
                        this.floodAnalysis.ym_pos_y = this.ym_pos_y;
                        this.floodAnalysis.ym_pos_z = this.ym_pos_z;
                        this.floodAnalysis.rect_flood = this.rect_flood;
                        this.floodAnalysis.ym_pos_arr = this.ym_pos_arr;
                        this.floodAnalysis.floodSpeed = this.speed;
                        this.floodAnalysis.ym_max_index = this.ym_max_index;
                        this.floodAnalysis.globe = this.globe = false;
                        this.floodAnalysis.showElseArea = this.visibleOutArea;
                        this.viewer.scene.globe.material = Cesium.Material.fromType('YanMo');
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        if (this.viewer) {
                            this.viewer.scene.globe.material = null;
                            this.cancelFloodSpeed();
                        }
                        this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();

                        delete this.activeFlooding;
                        delete this.viewer;
                        delete this.ym_max_height;
                        delete this.ym_pos_x;
                        delete this.ym_pos_y;
                        delete this.ym_pos_z;
                        delete this.ym_pos_arr;
                        delete this.speed;
                        delete this.ym_max_index;
                        delete this.globe;
                        delete this.maxDepthOfWater;
                        delete this.rect_flood;
                    }
                }, {
                    key: "floodAnalysis",
                    get: function get() {
                        return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
                    }

                    //显示非淹没区域

                }, {
                    key: "visibleOutArea",
                    get: function get() {
                        return this._visibleOutArea;
                    },
                    set: function set(val) {
                        this._visibleOutArea = val;
                        this.floodAnalysis.showElseArea = val;
                    }

                    //全球淹没

                }, {
                    key: "globe",
                    get: function get() {
                        return this._globe;
                    },
                    set: function set(val) {
                        this._globe = val;
                        this.floodAnalysis.globe = val;
                    }

                    //淹没速度

                }, {
                    key: "speed",
                    get: function get() {
                        return this._speed;
                    },
                    set: function set(val) {
                        this._speed = Number(val);
                    }
                    //点集合的包围盒膨胀数值

                }, {
                    key: "boundingSwell",
                    get: function get() {
                        return this._boundingSwell;
                    },
                    set: function set(num) {
                        var rect = this._base_rect;
                        this._boundingSwell = Number(num);
                        this.rect_flood = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] - this.boundingSwell, rect[4] - this.boundingSwell, rect[5] - this.boundingSwell, 0, 0, 0];
                        this.floodAnalysis.rect_flood = this.rect_flood;
                    }

                    //显示和隐藏

                }, {
                    key: "show",
                    get: function get() {
                        return this.defaultShow;
                    },
                    set: function set(val) {
                        this.defaultShow = Boolean(val);
                        this._switchShow();
                    }
                }]);

                return FloodByTerrain;
            }();

            /***/
}),
/* 118 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Measure = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(4);

            var _EventType = __webpack_require__(18);

            var DrawEventType = _interopRequireWildcard(_EventType);

            var _Util = __webpack_require__(7);

            var _Attr = __webpack_require__(16);

            var _util = __webpack_require__(1);

            var util = _interopRequireWildcard(_util);

            var _point = __webpack_require__(2);

            var _matrix = __webpack_require__(17);

            var _polygon = __webpack_require__(12);

            var _polyline = __webpack_require__(33);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //提供测量长度、面积等 [绘制基于draw]

            var Measure = function Measure(opts) {
                var viewer = opts.viewer;

                //显示测量结果文本的字体
                var _labelAttr = (0, _Util.getDefStyle)("label", {
                    "color": "#ffffff",
                    "font_size": 20,
                    "border": true,
                    "border_color": "#000000",
                    "border_width": 3,
                    "background": true,
                    "background_color": "#000000",
                    "background_opacity": 0.5,
                    "scaleByDistance": true,
                    "scaleByDistance_far": 800000,
                    "scaleByDistance_farValue": 0.5,
                    "scaleByDistance_near": 1000,
                    "scaleByDistance_nearValue": 1,
                    "pixelOffset": [0, -15],
                    "visibleDepth": false // disableDepthTestDistance: Number.POSITIVE_INFINITY,//一直显示，不被地形等遮挡
                });
                if (Cesium.defined(opts.label)) {
                    for (var key in opts.label) {
                        _labelAttr[key] = opts.label[key];
                    }
                }

                var thisType = ""; //当前正在绘制的类别 
                var drawControl = new _Draw.Draw(viewer, { hasEdit: false, removeScreenSpaceEvent: opts.removeScreenSpaceEvent });

                var entity;

                //事件监听
                drawControl.on(DrawEventType.DrawAddPoint, function (e) {
                    entity = e.entity;
                    switch (thisType) {
                        case "length":
                        case "section":
                            workLength.showAddPointLength(entity);
                            break;
                        case "area":
                            workArea.showAddPointLength(entity);
                            break;
                        case "height":
                            workHeight.showAddPointLength(entity);
                            break;
                        case "super_height":
                            workSuperHeight.showAddPointLength(entity);
                            break;
                        case "angle":
                            workAngle.showAddPointLength(entity);
                            break;

                    }
                });
                drawControl.on(DrawEventType.DrawRemovePoint, function (e) {
                    switch (thisType) {
                        case "length":
                        case "section":
                            workLength.showRemoveLastPointLength(e);
                            break;
                        case "area":
                            workArea.showRemoveLastPointLength(e);
                            break;
                        case "height":
                            workHeight.showRemoveLastPointLength(e);
                            break;
                        case "super_height":
                            workSuperHeight.showRemoveLastPointLength(e);
                            break;
                        case "angle":
                            workAngle.showRemoveLastPointLength(e);
                            break;
                    }
                });
                drawControl.on(DrawEventType.DrawMouseMove, function (e) {
                    entity = e.entity;
                    switch (thisType) {
                        case "length":
                        case "section":
                            workLength.showMoveDrawing(entity);
                            break;
                        case "area":
                            workArea.showMoveDrawing(entity);
                            break;
                        case "height":
                            workHeight.showMoveDrawing(entity);
                            break;
                        case "super_height":
                            workSuperHeight.showMoveDrawing(entity);
                            break;
                        case "angle":
                            workAngle.showMoveDrawing(entity);
                            break;
                    }
                });

                drawControl.on(DrawEventType.DrawCreated, function (e) {
                    entity = e.entity;
                    switch (thisType) {
                        case "length":
                        case "section":
                            workLength.showDrawEnd(entity);
                            break;
                        case "area":
                            workArea.showDrawEnd(entity);
                            break;
                        case "height":
                            workHeight.showDrawEnd(entity);
                            break;
                        case "super_height":
                            workSuperHeight.showDrawEnd(entity);
                            break;
                        case "angle":
                            workAngle.showDrawEnd(entity);
                            break;
                        case "point":
                            workPoint.showDrawEnd(entity);
                            break;

                    }
                    entity = null;
                });

                var dataSource = drawControl.getDataSource();

                /*长度测量*/
                function measuerLength(options) {
                    endLastDraw();

                    thisType = "length";
                    options = options || {};
                    options.type = thisType;
                    options.terrain = Cesium.defaultValue(options.terrain, true);

                    workLength.start(options);
                }

                /*剖面分析*/
                function measureSection(options) {
                    endLastDraw();

                    thisType = "section";
                    options = options || {};
                    options.type = thisType;
                    options.terrain = true;
                    options.splitNum = Cesium.defaultValue(options.splitNum, 200);

                    workLength.start(options);
                }

                /*面积测量*/
                function measureArea(options) {
                    endLastDraw();

                    thisType = "area";
                    options = options || {};
                    options.type = thisType;
                    options.terrain = Cesium.defaultValue(options.terrain, false);

                    workArea.start(options);
                };

                /*高度测量*/
                function measureHeight(options) {
                    endLastDraw();

                    options = options || {};

                    if (options.hasOwnProperty("isSuper") && !options.isSuper) {
                        thisType = "height";
                        options.type = thisType;
                        workHeight.start(options);
                    } else {
                        thisType = "super_height";
                        options.type = thisType;
                        workSuperHeight.start(options);
                    }
                };

                /*角度测量*/
                function measureAngle(options) {
                    endLastDraw();

                    thisType = "angle";
                    options = options || {};
                    options.type = thisType;

                    workAngle.start(options);
                };

                /*坐标测量*/
                function measurePoint(options) {
                    endLastDraw();

                    thisType = "point";
                    options = options || {};
                    options.type = thisType;

                    workPoint.start(options);
                };

                //如果上次未完成绘制就单击了新的，清除之前未完成的。
                function endLastDraw() {
                    workLength.clearLastNoEnd();
                    workArea.clearLastNoEnd();
                    workHeight.clearLastNoEnd();
                    workSuperHeight.clearLastNoEnd();
                    workAngle.clearLastNoEnd();
                    workPoint.clearLastNoEnd();

                    drawControl.stopDraw();
                }

                //外部控制，完成绘制，比如手机端无法双击结束 
                function endDraw() {
                    if (entity == null) return;

                    switch (thisType) {
                        case "length":
                        case "section":
                            workLength.showMoveDrawing(entity);
                            break;
                        case "area":
                            workArea.showMoveDrawing(entity);
                            break;
                        case "height":
                            workHeight.showMoveDrawing(entity);
                            break;
                        case "super_height":
                            workSuperHeight.showMoveDrawing(entity);
                            break;
                        case "angle":
                            workAngle.showMoveDrawing(entity);
                            break;
                    }

                    drawControl.endDraw();
                    entity = null;
                }

                /*清除测量*/
                function clearMeasure() {
                    thisType = "";
                    endLastDraw();

                    //dataSource.entities.removeAll();
                    drawControl.deleteAll();
                };

                /** 更新量测结果的单位  */
                function updateUnit(thisType, unit) {
                    var arr = dataSource.entities.values;
                    for (var i in arr) {
                        var entity = arr[i];
                        if (entity.label && entity.isMapVMeasureLabel && entity.attribute && entity.attribute.value) {
                            if (entity.attribute.type != thisType) continue;
                            if (thisType == "area") {
                                entity.label.text._value = (entity.attribute.textEx || "") + util.formatArea(entity.attribute.value, unit);
                            } else {
                                entity._label.text._value = (entity.attribute.textEx || "") + util.formatLength(entity.attribute.value, unit);
                            }
                        }
                    }
                }

                var workLength = {
                    options: null,
                    arrLables: [], //各线段label
                    totalLable: null, //总长label 
                    disTerrainScale: 1.2, //贴地时的概略比例
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        if (Cesium.defined(this.totalLable)) dataSource.entities.remove(this.totalLable);
                        if (Cesium.defined(this.arrLables) && this.arrLables.length > 0) {
                            var arrLables = this.arrLables;
                            if (arrLables && arrLables.length > 0) {
                                for (var i in arrLables) {
                                    dataSource.entities.remove(arrLables[i]);
                                }
                            }
                        }
                        this.totalLable = null;
                        this.arrLables = [];
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        //总长label 
                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: false
                        });

                        this.totalLable = dataSource.entities.add({
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });
                        this.arrLables = [];

                        drawControl.startDraw({
                            type: "polyline",
                            config: {
                                addHeight: options.addHeight
                            },
                            style: options.style || {
                                "lineType": "glow",
                                "color": "#ebe12c",
                                "width": 9,
                                "glowPower": 0.1,
                                "clampToGround": this.options.type == "section" || this.options.terrain, //是否贴地 
                                "depthFailMaterial": new Cesium.Color.fromCssColorString("#ebe12c").withAlpha(0.4)
                            }
                        });
                    },
                    //绘制增加一个点后，显示该分段的长度
                    showAddPointLength: function showAddPointLength(entity) {
                        var positions = drawControl.getPositions(entity);

                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: true
                        });

                        var tempSingleLabel = dataSource.entities.add({
                            position: positions[positions.length - 1],
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        if (positions.length == 1) {
                            tempSingleLabel.label.text = "起点";
                            //tempSingleLabel.attribute.value = 0;
                        } else {
                            var distance = util.getLength(positions);
                            var distancestr = util.formatLength(distance, this.options.unit);

                            tempSingleLabel.label.text = distancestr;
                            tempSingleLabel.attribute.value = distance;

                            //屏蔽比较小的数值
                            if (util.getLength([positions[positions.length - 2], positions[positions.length - 1]]) < 5) tempSingleLabel.show = false;
                        }
                        this.arrLables.push(tempSingleLabel);
                    },
                    showRemoveLastPointLength: function showRemoveLastPointLength(e) {
                        var label = this.arrLables.pop();
                        dataSource.entities.remove(label);

                        this.showMoveDrawing(e.entity);
                        this.totalLable.position = e.position;
                    },
                    //绘制过程移动中，动态显示长度信息
                    showMoveDrawing: function showMoveDrawing(entity) {
                        var positions = drawControl.getPositions(entity);
                        if (positions.length < 2) {
                            this.totalLable.label.show = false;
                            return;
                        }

                        var distance = util.getLength(positions);
                        var distancestr = util.formatLength(distance, this.options.unit);

                        this.totalLable.position = positions[positions.length - 1];
                        this.totalLable.label.text = "总长:" + distancestr;
                        this.totalLable.label.show = true;

                        this.totalLable.attribute.value = distance;
                        this.totalLable.attribute.textEx = "总长:";

                        if (this.options.calback) this.options.calback(distancestr, distance);
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        var positions = drawControl.getPositions(entity);
                        var count = this.arrLables.length - positions.length;
                        if (count >= 0) {
                            for (var i = this.arrLables.length - 1; i >= positions.length - 1; i--) {
                                dataSource.entities.remove(this.arrLables[i]);
                            }
                            this.arrLables.splice(positions.length - 1, count + 1);
                        }
                        entity._totalLable = this.totalLable;
                        entity._arrLables = this.arrLables;

                        this.totalLable = null;
                        this.arrLables = [];

                        if (entity.polyline == null) return;

                        if (this.options.type == "section") this.updateSectionForTerrain(entity); else if (this.options.terrain) this.updateLengthForTerrain(entity);

                        if (this.options.onEnd) {
                            this.options.onEnd(entity);
                        }
                    },
                    //计算贴地线
                    updateLengthForTerrain: function updateLengthForTerrain(entity) {
                        var that = this;
                        var positions = entity.polyline.positions.getValue(viewer.clock.currentTime);
                        var arrLables = entity._arrLables;
                        var totalLable = entity._totalLable;
                        var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

                        if (this.options.onStart) this.options.onStart();

                        var index = 0;
                        var all_distance = 0;

                        function getLineFD() {
                            index++;

                            if (index >= positions.length && totalLable) {
                                var distancestr = util.formatLength(all_distance, unit);

                                totalLable.label.text = "总长:" + distancestr;
                                totalLable.attribute.value = all_distance;

                                if (that.options.calback) that.options.calback(distancestr, all_distance);
                                if (that.options.onStop) that.options.onStop();
                                return;
                            }

                            var arr = [positions[index - 1], positions[index]];
                            (0, _polyline.computeSurfaceLine)({
                                viewer: viewer,
                                positions: arr,
                                splitNum: that.options.splitNum,
                                calback: function calback(raisedPositions, noHeight) {
                                    var distance = util.getLength(raisedPositions);
                                    if (noHeight) {
                                        distance = distance * that.disTerrainScale; //求高度失败，概略估算值
                                    }

                                    var thisLabel = arrLables[index];
                                    if (thisLabel) {
                                        var distancestr = util.formatLength(distance, unit);

                                        thisLabel.label.text = distancestr;
                                        thisLabel.attribute.value = distance;
                                    }

                                    all_distance += distance;
                                    getLineFD();
                                }
                            });
                        }
                        getLineFD();
                    },

                    //计算剖面
                    updateSectionForTerrain: function updateSectionForTerrain(entity) {
                        var positions = entity.polyline.positions.getValue(viewer.clock.currentTime);
                        if (positions.length < 2) return;

                        var arrLables = entity._arrLables;
                        var totalLable = entity._totalLable;
                        var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

                        var index = 0;
                        var positionsNew = [];

                        var alllen = 0;
                        var arrLen = [];
                        var arrHB = [];
                        var arrLX = [];
                        var arrPoint = [];

                        if (this.options.onStart) this.options.onStart();

                        var that = this;
                        function getLineFD() {
                            index++;

                            var arr = [positions[index - 1], positions[index]];
                            (0, _polyline.computeSurfaceLine)({
                                viewer: viewer,
                                positions: arr,
                                splitNum: that.options.splitNum,
                                calback: function calback(raisedPositions, noHeight) {
                                    if (noHeight) {
                                        if (index == 1) positionsNew = positionsNew.concat(arr); else positionsNew = positionsNew.concat([positions[index]]);
                                    } else {
                                        positionsNew = positionsNew.concat(raisedPositions);
                                    }

                                    var h1 = Cesium.Cartographic.fromCartesian(positions[index - 1]).height;
                                    var h2 = Cesium.Cartographic.fromCartesian(positions[index]).height;
                                    var hstep = (h2 - h1) / raisedPositions.length;

                                    for (var i = 0; i < raisedPositions.length; i++) {
                                        //长度
                                        if (i != 0) {
                                            alllen += Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
                                        }
                                        arrLen.push(Number(alllen.toFixed(1)));

                                        //海拔高度
                                        var point = (0, _point.formatPosition)(raisedPositions[i]);
                                        arrHB.push(point.z);
                                        arrPoint.push(point);

                                        //路线高度
                                        var fxgd = Number((h1 + hstep * i).toFixed(1));
                                        arrLX.push(fxgd);
                                    }

                                    if (index >= positions.length - 1) {
                                        if (totalLable) {
                                            var distance = util.getLength(positionsNew);
                                            var distancestr = util.formatLength(distance, unit);

                                            totalLable.label.text = "总长:" + distancestr;
                                            totalLable.attribute.value = distance;
                                        }
                                        if (that.options.calback) that.options.calback({
                                            distancestr: distancestr,
                                            distance: distance,
                                            arrLen: arrLen,
                                            arrLX: arrLX,
                                            arrHB: arrHB,
                                            arrPoint: arrPoint
                                        });
                                        if (that.options.onStop) that.options.onStop();
                                    } else {
                                        var distance = util.getLength(raisedPositions);
                                        var distancestr = util.formatLength(distance, unit);

                                        var thisLabel = arrLables[index];
                                        thisLabel.label.text = distancestr;
                                        thisLabel.attribute.value = distance;

                                        getLineFD();
                                    }
                                }
                            });
                        }
                        getLineFD();
                    }

                };

                var workArea = {
                    options: null,
                    totalLable: null, //面积label
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        if (this.totalLable != null) dataSource.entities.remove(this.totalLable);
                        this.totalLable = null;
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: false
                        });

                        this.totalLable = dataSource.entities.add({
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        drawControl.startDraw({
                            type: "polygon",
                            style: options.style || {
                                color: "#00fff2",
                                outline: true,
                                outlineColor: "#fafa5a",
                                outlineWidth: 1,
                                opacity: 0.4,
                                clampToGround: true //贴地
                            }
                        });
                    },
                    //绘制增加一个点后，显示该分段的长度
                    showAddPointLength: function showAddPointLength(entity) {
                        this.showMoveDrawing(entity); //兼容手机端
                    },
                    //绘制中删除了最后一个点
                    showRemoveLastPointLength: function showRemoveLastPointLength(e) {
                        var positions = drawControl.getPositions(e.entity);
                        if (positions.length < 3) {
                            this.totalLable.label.show = false;
                        }
                    },
                    //绘制过程移动中，动态显示长度信息
                    showMoveDrawing: function showMoveDrawing(entity) {
                        var positions = drawControl.getPositions(entity);
                        if (positions.length < 3) {
                            this.totalLable.label.show = false;
                            return;
                        }
                        var area = util.getArea(positions);
                        var areastr = util.formatArea(area, this.options.unit);

                        //求中心点  
                        var ptcenter = (0, _point.centerOfMass)(positions);

                        this.totalLable.position = ptcenter;
                        this.totalLable.label.text = "面积:" + areastr;
                        this.totalLable.label.show = true;

                        this.totalLable.attribute.value = area;
                        this.totalLable.attribute.textEx = "面积:";

                        if (this.options.calback) this.options.calback(areastr, area);
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        if (entity.polygon == null) return;

                        entity._totalLable = this.totalLable;
                        this.totalLable = null;

                        if (this.options.terrain) {
                            this.updateAreaForTerrain(entity);
                        }
                        if (this.options.onEnd) {
                            this.options.onEnd(entity);
                        }
                    },
                    //计算贴地面
                    updateAreaForTerrain: function updateAreaForTerrain(entity) {
                        var that = this;

                        var positions = drawControl.getPositions(entity);
                        var resultInter = (0, _polygon.interPolygon)({
                            scene: viewer.scene,
                            positions: positions,
                            splitNum: this.options.splitNum
                        });

                        if (this.options.onInterEnd) this.options.onInterEnd(resultInter);

                        // var totalTY = 0;    //总面积(横截面/投影底面)
                        var area = 0; //总面积(贴地三角面) 
                        for (var i = 0, len = resultInter.list.length; i < len; i++) {
                            var item = resultInter.list[i];
                            var pt1 = item.point1;
                            var pt2 = item.point2;
                            var pt3 = item.point3;

                            //求面积
                            // totalTY += util.getAreaOfTriangle(pt1.point, pt2.point, pt3.point); 
                            area += util.getAreaOfTriangle(pt1.pointDM, pt2.pointDM, pt3.pointDM);
                        }

                        //更新lable等
                        var totalLable = entity._totalLable;
                        var unit = totalLable && totalLable.attribute && totalLable.attribute.unit;

                        var areastr = util.formatArea(area, unit);

                        totalLable.attribute.value = area;
                        totalLable.label.text = totalLable.attribute.textEx + areastr;

                        if (this.options.calback) this.options.calback(areastr, area);
                    }
                };

                var workHeight = {
                    options: null,
                    totalLable: null, //高度label  
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        if (this.totalLable != null) dataSource.entities.remove(this.totalLable);
                        this.totalLable = null;
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: false
                        });

                        this.totalLable = dataSource.entities.add({
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        drawControl.startDraw({
                            type: "polyline",
                            config: { maxPointNum: 2 },
                            style: options.style || {
                                "lineType": "glow",
                                "color": "#ebe12c",
                                "width": 9,
                                "glowPower": 0.1,
                                "depthFailMaterial": new Cesium.Color.fromCssColorString("#ebe12c").withAlpha(0.4)
                            }
                        });
                    },
                    //绘制增加一个点后，显示该分段的长度
                    showAddPointLength: function showAddPointLength(entity) {
                        this.showMoveDrawing(entity); //兼容手机端
                    },
                    //绘制中删除了最后一个点
                    showRemoveLastPointLength: function showRemoveLastPointLength(e) {
                        if (this.totalLable) this.totalLable.label.show = false;
                    },
                    //绘制过程移动中，动态显示长度信息
                    showMoveDrawing: function showMoveDrawing(entity) {
                        var positions = drawControl.getPositions(entity);
                        if (positions.length < 2) {
                            this.totalLable.label.show = false;
                            return;
                        }

                        var cartographic = Cesium.Cartographic.fromCartesian(positions[0]);
                        var cartographic1 = Cesium.Cartographic.fromCartesian(positions[1]);
                        var height = Math.abs(cartographic1.height - cartographic.height);
                        var heightstr = util.formatLength(height, this.options.unit);

                        this.totalLable.position = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                        this.totalLable.label.text = "高度差:" + heightstr;
                        this.totalLable.label.show = true;

                        this.totalLable.attribute.value = height;
                        this.totalLable.attribute.textEx = "高度差:";

                        if (this.options.calback) this.options.calback(heightstr, height);
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        entity._totalLable = this.totalLable;
                        this.totalLable = null;

                        if (this.options.onEnd) {
                            this.options.onEnd(entity);
                        }
                    }
                };

                var workSuperHeight = {
                    options: null,
                    totalLable: null, //高度差label
                    xLable: null, //水平距离label
                    hLable: null, //水平距离label
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        if (this.totalLable != null) dataSource.entities.remove(this.totalLable);
                        if (this.xLable != null) dataSource.entities.remove(this.xLable);
                        if (this.hLable != null) dataSource.entities.remove(this.hLable);

                        this.totalLable = null;
                        this.xLable = null;
                        this.hLable = null;
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
                            verticalOrigin: Cesium.VerticalOrigin.CENTER,
                            show: false
                        });
                        this.totalLable = dataSource.entities.add({
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        var entityattr2 = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: false
                        });
                        entityattr2.pixelOffset = new Cesium.Cartesian2(0, 0);
                        this.xLable = dataSource.entities.add({
                            label: entityattr2,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        this.hLable = dataSource.entities.add({
                            label: entityattr2,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        drawControl.startDraw({
                            type: "polyline",
                            //minMaxPoints: { min: 2, max: 2, isSuper: true },
                            config: { maxPointNum: 2 },
                            style: options.style || {
                                "lineType": "glow",
                                "color": "#ebe12c",
                                "width": 9,
                                "glowPower": 0.1,
                                "depthFailMaterial": new Cesium.Color.fromCssColorString("#ebe12c").withAlpha(0.4)
                            }
                        });
                    },
                    //绘制增加一个点后，显示该分段的长度
                    showAddPointLength: function showAddPointLength(entity) {
                        var lonlats = drawControl.getPositions(entity);
                        if (lonlats.length == 4) {
                            var mouseEndPosition = lonlats[3].clone();
                            lonlats.pop();
                            lonlats.pop();
                            lonlats.pop();
                            lonlats.push(mouseEndPosition);
                        }

                        if (lonlats.length == 2) {
                            var zCartesian = this.getZHeightPosition(lonlats[0], lonlats[1]);
                            var hDistance = this.getHDistance(lonlats[0], lonlats[1]);
                            if (hDistance > 3.0) {
                                lonlats.push(zCartesian);
                                lonlats.push(lonlats[0]);
                            }
                        }

                        this.showSuperHeight(lonlats);
                    },
                    //绘制中删除了最后一个点 
                    showRemoveLastPointLength: function showRemoveLastPointLength(e) {
                        var lonlats = drawControl.getPositions(e.entity);
                        if (lonlats.length == 2) {
                            lonlats.pop();
                            lonlats.pop();

                            this.totalLable.label.show = false;
                            this.hLable.label.show = false;
                            this.xLable.label.show = false;
                        }
                    },
                    //绘制过程移动中，动态显示长度信息
                    showMoveDrawing: function showMoveDrawing(entity) {
                        var lonlats = drawControl.getPositions(entity);
                        if (lonlats.length == 4) {
                            var mouseEndPosition = lonlats[3].clone();
                            lonlats.pop();
                            lonlats.pop();
                            lonlats.pop();
                            lonlats.push(mouseEndPosition);
                        }

                        if (lonlats.length == 2) {
                            var zCartesian = this.getZHeightPosition(lonlats[0], lonlats[1]);
                            var hDistance = this.getHDistance(lonlats[0], lonlats[1]);
                            if (hDistance > 3.0) {
                                lonlats.push(zCartesian);
                                lonlats.push(lonlats[0]);
                            }
                        }
                        this.showSuperHeight(lonlats);
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        entity._arrLables = [this.totalLable, this.hLable, this.xLable];

                        this.totalLable = null;
                        this.hLable = null;
                        this.xLable = null;

                        if (this.options.onEnd) {
                            this.options.onEnd(entity);
                        }
                    },

                    /**
                     * 超级 高程测量
                     * 由4个点形成的三角形（首尾点相同），计算该三角形三条线段的长度
                     * @param {Array} positions 4个点形成的点数组
                     */
                    showSuperHeight: function showSuperHeight(positions) {
                        var vLength; //垂直距离
                        var hLength; //水平距离
                        var lLength; //长度
                        var height;
                        if (positions.length == 4) {
                            var midLPoint = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                            var midXPoint, midHPoint;
                            var cartographic0 = Cesium.Cartographic.fromCartesian(positions[0]);
                            var cartographic1 = Cesium.Cartographic.fromCartesian(positions[1]);
                            var cartographic2 = Cesium.Cartographic.fromCartesian(positions[2]);
                            var tempHeight = cartographic1.height - cartographic2.height;
                            height = cartographic1.height - cartographic0.height;
                            lLength = Cesium.Cartesian3.distance(positions[0], positions[1]);
                            if (height > -1 && height < 1) {
                                midHPoint = positions[1];
                                this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", height);
                                this.updateSuperHeightLabel(this.hLable, midLPoint, "", lLength);
                            } else {
                                if (tempHeight > -0.1 && tempHeight < 0.1) {
                                    midXPoint = Cesium.Cartesian3.midpoint(positions[2], positions[1], new Cesium.Cartesian3());
                                    midHPoint = Cesium.Cartesian3.midpoint(positions[2], positions[3], new Cesium.Cartesian3());
                                    hLength = Cesium.Cartesian3.distance(positions[1], positions[2]);
                                    vLength = Cesium.Cartesian3.distance(positions[3], positions[2]);
                                } else {
                                    midHPoint = Cesium.Cartesian3.midpoint(positions[2], positions[1], new Cesium.Cartesian3());
                                    midXPoint = Cesium.Cartesian3.midpoint(positions[2], positions[3], new Cesium.Cartesian3());
                                    hLength = Cesium.Cartesian3.distance(positions[3], positions[2]);
                                    vLength = Cesium.Cartesian3.distance(positions[1], positions[2]);
                                }
                                this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", vLength);
                                this.updateSuperHeightLabel(this.xLable, midXPoint, "", hLength);
                                this.updateSuperHeightLabel(this.hLable, midLPoint, "", lLength);
                            }
                        } else if (positions.length == 2) {
                            vLength = Cesium.Cartesian3.distance(positions[1], positions[0]);
                            var midHPoint = Cesium.Cartesian3.midpoint(positions[0], positions[1], new Cesium.Cartesian3());
                            if (this.xLable.label.show) {
                                this.xLable.label.show = false;
                                this.hLable.label.show = false;
                            }
                            this.updateSuperHeightLabel(this.totalLable, midHPoint, "高度差:", vLength);
                        }

                        var heightstr = util.formatLength(vLength, this.options.unit);
                        if (this.options.calback) this.options.calback(heightstr, vLength);
                    },
                    /**
                     * 超级 高程测量 显示标签
                     * @param {Cesium.Label} currentLabel 显示标签
                     * @param {Cesium.Cartesian3} postion 坐标位置
                     * @param {String} type 类型("高度差"，"水平距离"，"长度")
                     * @param {Object} value 值
                     */
                    updateSuperHeightLabel: function updateSuperHeightLabel(currentLabel, postion, type, value) {
                        if (currentLabel == null) return;

                        currentLabel.position = postion;
                        currentLabel.label.text = type + util.formatLength(value, this.options.unit);
                        currentLabel.label.show = true;

                        currentLabel.attribute.value = value;
                        currentLabel.attribute.textEx = type;
                    },

                    /**
                       * 带有高度差的两点，判断其直角点 
                       */
                    getZHeightPosition: function getZHeightPosition(cartesian1, cartesian2) {
                        var carto1 = Cesium.Cartographic.fromCartesian(cartesian1);
                        var lng1 = Number(Cesium.Math.toDegrees(carto1.longitude));
                        var lat1 = Number(Cesium.Math.toDegrees(carto1.latitude));
                        var height1 = Number(carto1.height.toFixed(2));

                        var carto2 = Cesium.Cartographic.fromCartesian(cartesian2);
                        var lng2 = Number(Cesium.Math.toDegrees(carto2.longitude));
                        var lat2 = Number(Cesium.Math.toDegrees(carto2.latitude));
                        var height2 = Number(carto2.height.toFixed(2));

                        if (height1 > height2) return Cesium.Cartesian3.fromDegrees(lng2, lat2, height1); else return Cesium.Cartesian3.fromDegrees(lng1, lat1, height2);
                    },

                    /**
                     * 带有高度差的两点，计算两点间的水平距离 
                     */
                    getHDistance: function getHDistance(cartesian1, cartesian2) {
                        var zCartesian = this.getZHeightPosition(cartesian1, cartesian2);

                        var carto1 = Cesium.Cartographic.fromCartesian(cartesian2);
                        var cartoZ = Cesium.Cartographic.fromCartesian(zCartesian);

                        var hDistance = Cesium.Cartesian3.distance(cartesian1, zCartesian);

                        if (Math.abs(Number(cartoZ.height) - Number(carto1.height)) < 0.01) {
                            hDistance = Cesium.Cartesian3.distance(cartesian2, zCartesian);
                        }

                        return hDistance;
                    }

                };

                var workAngle = {
                    options: null,
                    totalLable: null, //角度label  
                    exLine: null, //辅助线
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        if (this.totalLable != null) dataSource.entities.remove(this.totalLable);
                        this.totalLable = null;

                        if (this.exLine != null) dataSource.entities.remove(this.exLine);
                        this.exLine = null;
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        var entityattr = (0, _Attr.style2Entity)(_labelAttr, {
                            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            show: false
                        });

                        this.totalLable = dataSource.entities.add({
                            label: entityattr,
                            isMapVMeasureLabel: true,
                            _noMousePosition: true,
                            attribute: {
                                unit: this.options.unit,
                                type: this.options.type
                            }
                        });

                        drawControl.startDraw({
                            type: "polyline",
                            config: { maxPointNum: 2 },
                            style: options.style || {
                                "lineType": "arrow",
                                "color": "#ebe967",
                                "width": 9,
                                "clampToGround": true,
                                "depthFailMaterial": new Cesium.Color.fromCssColorString("#ebe12c").withAlpha(0.4)
                            }
                        });
                    },
                    //绘制增加一个点后，显示该分段的长度
                    showAddPointLength: function showAddPointLength(entity) {
                        this.showMoveDrawing(entity); //兼容手机端
                    },
                    //绘制中删除了最后一个点
                    showRemoveLastPointLength: function showRemoveLastPointLength(e) {
                        if (this.exLine) {
                            this.exLine.polyline.show = false;
                        }
                        if (this.totalLable) this.totalLable.label.show = false;
                    },
                    //绘制过程移动中，动态显示长度信息
                    showMoveDrawing: function showMoveDrawing(entity) {
                        var positions = drawControl.getPositions(entity);
                        if (positions.length < 2) {
                            this.totalLable.label.show = false;
                            return;
                        }

                        //求长度
                        var len = Cesium.Cartesian3.distance(positions[0], positions[1]);

                        //求方位角
                        var bearing = util.getAngle(positions[0], positions[1]);;

                        //求参考点  
                        var new_position = (0, _matrix.getRotateCenterPoint)(positions[0], positions[1], -bearing);
                        this.updateExLine([positions[0], new_position]); //参考线


                        this.totalLable.position = positions[1];
                        this.totalLable.label.text = "角度:" + bearing + "°\n距离:" + util.formatLength(len);
                        this.totalLable.label.show = true;

                        this.totalLable.attribute.value = bearing;
                        this.totalLable.attribute.textEx = "角度:";

                        if (this.options.calback) this.options.calback(bearing + '°', bearing);
                    },
                    updateExLine: function updateExLine(positions) {
                        if (this.exLine) {
                            // this.exLine.polyline.show = true;
                            this.exLine._positions = positions;
                        } else {
                            var exLine = dataSource.entities.add({
                                polyline: {
                                    positions: new Cesium.CallbackProperty(function (time) {
                                        return exLine._positions;
                                    }, false),
                                    width: 3,
                                    clampToGround: true,
                                    material: new Cesium.PolylineDashMaterialProperty({
                                        color: Cesium.Color.RED
                                    })
                                }
                            });
                            exLine._positions = positions;
                            this.exLine = exLine;
                        }
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        entity._totalLable = this.totalLable;
                        this.totalLable = null;
                        this.exLine = null;

                        if (this.options.onEnd) {
                            this.options.onEnd(entity);
                        }
                    }

                };

                var workPoint = {
                    options: null,
                    totalLable: null, //角度label   
                    //清除未完成的数据
                    clearLastNoEnd: function clearLastNoEnd() {
                        viewer.mapv.popup.close();
                    },
                    //开始绘制
                    start: function start(options) {
                        this.options = options;

                        drawControl.startDraw({
                            type: "point",
                            style: options.style || {
                                "visibleDepth": false
                            }
                        });
                    },
                    //绘制完成后
                    showDrawEnd: function showDrawEnd(entity) {
                        var positions = drawControl.getPositions(entity)[0];

                        var point = (0, _point.formatPosition)(positions);
                        var x2 = util.formatDegree(point.x);
                        var y2 = util.formatDegree(point.y);

                        var html = '<div class="mapv-popup-titile">\u5750\u6807\u6D4B\u91CF</div>\n                        <div class="mapv-popup-content">\n                            <div><label>\u7ECF\u5EA6</label>' + point.x + '&nbsp;&nbsp;' + x2 + '</div>\n                            <div><label>\u7EAC\u5EA6</label>' + point.y + '&nbsp;&nbsp;&nbsp;&nbsp;' + y2 + '</div>\n                            <div><label>\u6D77\u62D4</label>' + point.z + '\u7C73</div>\n                        </div>';

                        entity.popup = {
                            html: html,
                            anchor: [0, -15]
                        };
                        viewer.mapv.popup.show(entity);

                        if (this.options.onEnd) {
                            this.options.onEnd(entity, point);
                        }
                    }

                };

                return {
                    measuerLength: measuerLength,
                    measureHeight: measureHeight,
                    measureArea: measureArea,
                    measureAngle: measureAngle,

                    measureSection: measureSection,
                    measurePoint: measurePoint,

                    updateUnit: updateUnit,
                    clearMeasure: clearMeasure,

                    formatArea: util.formatArea,
                    formatLength: util.formatLength,

                    draw: function draw() {
                        return drawControl;
                    },

                    stopDraw: endLastDraw, //取消并停止绘制
                    endDraw: endDraw //外部控制，完成绘制，比如手机端无法双击结束 
                };
            };

            exports.Measure = Measure;

            /***/
}),
/* 119 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MeasureVolume = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            var _util = __webpack_require__(1);

            var _polygon = __webpack_require__(12);

            var _Attr = __webpack_require__(16);

            var _Attr2 = __webpack_require__(19);

            var _Draw = __webpack_require__(4);

            var _Util = __webpack_require__(7);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //方量分析(体积分析)
            var MeasureVolume = exports.MeasureVolume = function () {
                //========== 构造方法 ========== 
                function MeasureVolume(viewer, options) {
                    _classCallCheck(this, MeasureVolume);

                    this.viewer = viewer;
                    options = Cesium.defaultValue(options, {});
                    this.options = options;

                    this._last_depthTestAgainstTerrain = this.viewer.scene.globe.depthTestAgainstTerrain;
                    this.viewer.scene.globe.depthTestAgainstTerrain = true;
                    this.onStart = options.onStart;
                    this.onStop = options.onStop;

                    this._heightLabel = Cesium.defaultValue(options.heightLabel, true);
                    this._offsetLabel = Cesium.defaultValue(options.offsetLabel, false);

                    //显示测量结果文本的字体
                    var _labelAttr = {
                        "color": "#ffffff",
                        "font_family": "楷体",
                        "font_size": 20,
                        "border": true,
                        "border_color": "#000000",
                        "border_width": 3,
                        "background": true,
                        "background_color": "#000000",
                        "background_opacity": 0.3,
                        "scaleByDistance": true,
                        "scaleByDistance_far": 800000,
                        "scaleByDistance_farValue": 0.5,
                        "scaleByDistance_near": 1000,
                        "scaleByDistance_nearValue": 1,
                        "pixelOffset": [0, -15],
                        "visibleDepth": false
                    };
                    if (Cesium.defined(options.label)) {
                        for (var key in options.label) {
                            _labelAttr[key] = options.label[key];
                        }
                    }
                    this._labelAttr = _labelAttr;

                    var _labelHeightAttr = {
                        "color": "#ffffff",
                        "font_family": "楷体",
                        "font_size": 15,
                        "border": true,
                        "border_color": "#000000",
                        "border_width": 3,
                        "background": false,
                        "scaleByDistance": true,
                        "scaleByDistance_far": 800000,
                        "scaleByDistance_farValue": 0.5,
                        "scaleByDistance_near": 1000,
                        "scaleByDistance_nearValue": 1,
                        "pixelOffset": [0, -15],
                        "visibleDepth": false
                    };
                    if (Cesium.defined(options.labelEx)) {
                        for (var key in options.labelEx) {
                            _labelHeightAttr[key] = options.labelEx[key];
                        }
                    }
                    this._labelHeightAttr = _labelHeightAttr;

                    //面的样式
                    var _polygonStyle = (0, _Util.getDefStyle)("polygon", {
                        color: "#00fff2",
                        opacity: 0.4
                    });
                    if (Cesium.defined(options.polygon)) {
                        for (var key in options.polygon) {
                            _polygonStyle[key] = options.polygon[key];
                        }
                    }
                    this._polygonStyle = _polygonStyle;

                    //基准面的样式
                    var _polygonJzmStyle = (0, _Util.getDefStyle)("polygon", {
                        "color": "#00ff00",
                        "opacity": 0.3
                    });
                    if (Cesium.defined(options.polygonJzm)) {
                        for (var key in options.polygonJzm) {
                            _polygonJzmStyle[key] = options.polygonJzm[key];
                        }
                    }
                    this._polygonJzmStyle = _polygonJzmStyle;

                    this.drawControl = new _Draw.Draw(this.viewer, {
                        hasEdit: false,
                        removeScreenSpaceEvent: true
                    });
                }

                //========== 对外属性 ==========  


                _createClass(MeasureVolume, [{
                    key: 'startDraw',


                    //========== 方法 ==========  
                    value: function startDraw() {
                        this.clear();

                        this._polygonStyle.clampToGround = true; //贴地

                        var that = this;
                        this.drawControl.startDraw({
                            type: "polygon",
                            style: this._polygonStyle,
                            success: function success(entity) {
                                if (entity.polygon == null) return;

                                var positions = that.drawControl.getPositions(entity);

                                if (that.onStart) that.onStart(positions);

                                setTimeout(function () {
                                    that.start(positions);
                                    that.drawControl.deleteEntity(entity);
                                }, 500);
                            }
                        });
                    }
                }, {
                    key: 'start',
                    value: function start(positions) {
                        this.positions = positions;

                        //计算各点的贴地高度和贴地点
                        var tdHeights = [];
                        var tdposs = [];
                        for (var i = 0; i < positions.length; i++) {
                            var cartographic = Cesium.Cartographic.fromCartesian(positions[i]);
                            var height = this.viewer.scene.globe.getHeight(cartographic);
                            tdHeights.push(height);
                            tdposs.push(Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, height));
                        }
                        this.tdHeights = tdHeights;
                        this.tdposs = tdposs;

                        //计算体积
                        this.squareResult = (0, _polygon.computeVolume)({
                            positions: positions,
                            scene: this.viewer.scene,
                            splitNum: this.options.splitNum //插值次数
                        });

                        // this.resetLabels();
                        var maxHeight = this.squareResult.maxHeight;
                        //求中心点 
                        this.ptcenter = (0, _point.centerOfMass)(positions, maxHeight + 10);

                        this._maxHeight = maxHeight;
                        this._minHeight = this.squareResult.minHeight;
                        this.jzmHeight = this.squareResult.minHeight;
                        this.resetLabels();

                        // 显示基准面
                        var dataSource = this.drawControl.dataSource;
                        var that = this;
                        if (!this.entityPQM) {
                            var entityattr = (0, _Attr2.style2Entity)(this._polygonJzmStyle, {
                                hierarchy: new Cesium.PolygonHierarchy(positions),
                                height: new Cesium.CallbackProperty(function (time, result) {
                                    return that.jzmHeight;
                                }, false)
                            });
                            delete entityattr.perPositionHeight;

                            this.entityPQM = dataSource.entities.add({
                                polygon: entityattr
                            });
                        }

                        // 显示立体边界
                        delete this._polygonStyle.clampToGround;
                        var entityattr = (0, _Attr2.style2Entity)(this._polygonStyle, {
                            hierarchy: new Cesium.PolygonHierarchy(positions),
                            extrudedHeight: new Cesium.CallbackProperty(function (time, result) {
                                return that.maxHeight;
                            }, false),
                            closeTop: false,
                            closeBottom: false
                        });
                        this.entityWell = dataSource.entities.add({
                            polygon: entityattr
                        });
                        this.measureFill(this.squareResult.minHeight, true);
                    }
                }, {
                    key: 'resetLabels',
                    value: function resetLabels() {
                        if (this.tdLabels && this.tdLabels.length) {
                            for (var e = 0; e < this.tdLabels.length; e++) {
                                this.drawControl.deleteEntity(this.tdLabels[e]);
                            }
                        }

                        if (!this.heightLabel && !this.offsetLabel) return;

                        var arr = [];
                        for (var e = 0, len = this.tdHeights.length; e < len; e++) {
                            var height = this.tdHeights[e];

                            var text = "";
                            if (this.heightLabel) {
                                text += "海拔：" + height.toFixed(2) + "米";
                            }
                            if (this.offsetLabel) {
                                var offset = (this.height || 0) - height;
                                if (this.heightLabel) text += "\n";
                                text += "离地：" + offset.toFixed(2) + "米";
                            }

                            //各点的文本
                            var entityattr = (0, _Attr.style2Entity)(this._labelHeightAttr, {
                                text: text,
                                horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                                verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                            });

                            var l = this.drawControl.dataSource.entities.add({
                                position: this.tdposs[e],
                                label: entityattr
                            });
                            arr.push(l);
                        }
                        this.tdLabels = arr;
                    }
                }, {
                    key: 'formatNum',
                    value: function formatNum(num) {
                        //格式化数值
                        if (num > 10000) {
                            return (num / 10000).toFixed(2) + "万";
                        }
                        return num.toFixed(2);
                    }
                }, {
                    key: 'measureFill',
                    value: function measureFill(height, hasCalback) {
                        var fillV = (0, _polygon.updateVolume)(this.squareResult, height);
                        if (!fillV) return;

                        if (!this.ptcenter) return;
                        var dataSource = this.drawControl.dataSource;

                        if (this.entitieLbl) {
                            dataSource.entities.remove(this.entitieLbl);
                        }
                        var fillText = '';
                        if (fillV.fillVolume > 0) {
                            fillText += '填方体积：' + this.formatNum(fillV.fillVolume) + "立方米\n";
                        }
                        if (fillV.digVolume > 0) {
                            fillText += "挖方体积：" + this.formatNum(fillV.digVolume) + "立方米\n";
                        }
                        fillText += '投影面积：' + (0, _util.formatArea)(fillV.totalArea);

                        //添加文字
                        var entityattr = (0, _Attr.style2Entity)(this._labelAttr, {
                            text: fillText,
                            horizontalOrigin: Cesium.HorizontalOrigin.LEFT,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                        });
                        this.entitieLbl = dataSource.entities.add({
                            position: this.ptcenter,
                            label: entityattr
                        });
                        if (hasCalback && this.onStop) this.onStop(fillV);
                    }
                }, {
                    key: 'clear',
                    value: function clear() {
                        this.drawControl.clearDraw();
                        this.entitieLbl && this.drawControl.dataSource.entities.remove(this.entitieLbl);
                        this.entityPQM && this.drawControl.dataSource.entities.remove(this.entityPQM);
                        this.entityWell && this.drawControl.dataSource.entities.remove(this.entityWell);
                        delete this.entitieLbl;
                        delete this.entityPQM;
                        delete this.entityWell;

                        delete this.tdHeights;
                        delete this.tdposs;
                    }
                }, {
                    key: 'resetFillV',
                    value: function resetFillV() {
                        //重置挖方
                        var newFillV = (0, _polygon.updateVolume)(this.squareResult, this.jzmHeight);
                        var dataSource = this.drawControl.dataSource;
                        if (this.entitieLbl) {
                            dataSource.entities.remove(this.entitieLbl);
                        }

                        var fillText = '投影面积：' + (0, _util.formatArea)(newFillV.totalArea);
                        if (newFillV.fillVolume > 0) {
                            fillText += '\n填方体积：' + this.formatNum(newFillV.fillVolume) + "立方米";
                        }
                        if (newFillV.digVolume > 0) {
                            fillText += "\n挖方体积：" + this.formatNum(newFillV.digVolume) + "立方米";
                        }

                        //添加文字
                        var entityattr = (0, _Attr.style2Entity)(this._labelAttr, {
                            text: fillText,
                            horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM
                        });
                        this.entitieLbl = dataSource.entities.add({
                            position: this.ptcenter,
                            label: entityattr
                        });
                    }
                }, {
                    key: 'selecteHeight',
                    value: function selecteHeight() {
                        //拾取高度
                        if (!this.entityPQM || !this.entityWell) return;

                        var that = this;
                        this.drawControl.startDraw({
                            type: "point",
                            style: {
                                color: "#00fff2"
                            },
                            success: function success(entity) {
                                if (!entity.point) return;

                                var pos = entity._position._value;
                                var height = Cesium.Cartographic.fromCartesian(pos).height;
                                that.height = height;

                                that.drawControl.dataSource.entities.remove(entity);
                            }
                        });
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.viewer.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
                        this.clear();
                        this.drawControl.destroy();
                        delete this.viewer;
                        delete this.jzmHeight;
                        delete this.drawControl;
                        delete this.squareResult;
                        delete this.ptcenter;
                        delete this.positions;
                        delete this.onStop;
                        delete this._last_depthTestAgainstTerrain;
                    }
                }, {
                    key: 'resultInter',
                    get: function get() {
                        return this.squareResult;
                    }
                    //高度

                }, {
                    key: 'height',
                    get: function get() {
                        return this.jzmHeight;
                    },
                    set: function set(val) {
                        this.jzmHeight = val;
                        if (val > this.maxHeight) this.maxHeight = val;

                        if (!this.entityPQM || !this.entityWell) return;
                        this.resetFillV();
                        this.measureFill(val);
                        this.resetLabels();
                    }
                }, {
                    key: 'minHeight',
                    get: function get() {
                        return this._minHeight;
                    },
                    set: function set(val) {
                        this._minHeight = val;
                        if (this.squareResult) this.squareResult.minHeight = val;
                    }
                }, {
                    key: 'maxHeight',
                    get: function get() {
                        return this._maxHeight;
                    },
                    set: function set(val) {
                        this._maxHeight = val;
                        if (this.squareResult) this.squareResult.maxHeight = val;
                    }
                }, {
                    key: 'heightLabel',
                    get: function get() {
                        return this._heightLabel;
                    },
                    set: function set(val) {
                        this._heightLabel = val;
                        this.resetLabels();
                    }
                }, {
                    key: 'offsetLabel',
                    get: function get() {
                        return this._offsetLabel;
                    },
                    set: function set(val) {
                        this._offsetLabel = val;
                        this.resetLabels();
                    }
                }]);

                return MeasureVolume;
            }();

            /***/
}),
/* 120 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Skyline = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Skyline = __webpack_require__(121);

            var _Skyline2 = _interopRequireDefault(_Skyline);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //天际线 类
            var Skyline = exports.Skyline = function () {
                function Skyline(viewer, options) {
                    _classCallCheck(this, Skyline);

                    if (!options) options = {};

                    var defaultOpts = {
                        tjxWidth: 2, //天际线宽度
                        strokeType: new Cesium.Cartesian3(true, false, false), //天际线，物体描边，全描边
                        tjxColor: new Cesium.Color(1.0, 0.0, 0.0), //边际线颜色
                        bjColor: new Cesium.Color(0.0, 0.0, 1.0), //物体描边颜色
                        mbDis: 500 //物体描边距离
                    };

                    this.viewer = viewer;
                    this.tjxWidth = Cesium.defaultValue(options.tjxWidth, defaultOpts.tjxWidth);
                    this.strokeType = Cesium.defaultValue(options.strokeType, defaultOpts.strokeType);
                    this.tjxColor = Cesium.defaultValue(options.tjxColor, defaultOpts.tjxColor);
                    this.bjColor = Cesium.defaultValue(options.bjColor, defaultOpts.bjColor);
                    this.mbDis = Cesium.defaultValue(options.mbDis, defaultOpts.mbDis);
                    this.init();
                }

                _createClass(Skyline, [{
                    key: "init",
                    value: function init() {
                        this.addPostStage();
                    }
                }, {
                    key: "addPostStage",
                    value: function addPostStage() {
                        var that = this;
                        this.postProcess = new Cesium.PostProcessStage({
                            fragmentShader: _Skyline2.default,
                            uniforms: {
                                height: function height() {
                                    var pos = Cesium.Cartographic.fromCartesian(that.viewer.scene.camera.position);
                                    return pos.height;
                                },
                                lineWidth: function lineWidth() {
                                    return that.tjxWidth;
                                },
                                strokeType: function strokeType() {
                                    return that.strokeType;
                                },
                                tjxColor: function tjxColor() {
                                    return that.tjxColor;
                                },
                                bjColor: function bjColor() {
                                    return that.bjColor;
                                },
                                cameraPos: function cameraPos() {
                                    return that.viewer.scene.camera.position;
                                },
                                mbDis: function mbDis() {
                                    return that.mbDis;
                                }
                            }
                        });
                        this.viewer.scene.postProcessStages.add(this.postProcess);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        delete this.viewer;
                        delete this.tjxWidth;
                        delete this.strokeType;
                        delete this.tjxColor;
                        delete this.bjColor;
                        delete this.mbDis;
                        delete this.postProcess;
                    }
                }]);

                return Skyline;
            }();

            /***/
}),
/* 121 */
/***/ (function (module, exports) {

            module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float lineWidth;\r\nuniform float height;\r\nuniform bvec3 strokeType;\r\nuniform vec3 tjxColor;\r\nuniform vec3 bjColor;\r\nuniform vec3 cameraPos;\r\nuniform float mbDis;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nbool isTJX(vec2 uv,float lw){\r\n    vec2 pixelSize = lw / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n\r\n    vec2 currUV = uv + vec2(dx0, dy0);\r\n    vec4 currDepth = texture2D(depthTexture, currUV);\r\n    float depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, 0.0);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(0.0, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    currUV = uv + vec2(dx1, dy1);\r\n    currDepth = texture2D(depthTexture, currUV);\r\n    depth = getDepth(currDepth);\r\n    if(depth>=1.0)return true;\r\n\r\n    return false;\r\n}\r\nvoid main(){\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    if(height>14102.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    if(strokeType.y||strokeType.z){\r\n        vec4 wp = czm_inverseView * positionEC;\r\n        if(distance(wp.xyz,cameraPos)>mbDis){\r\n            gl_FragColor = color;\r\n        }else{\r\n            float dotNum = abs(dot(normal,normalize(positionEC.xyz)));\r\n            if(dotNum<0.05){\r\n                gl_FragColor = vec4(bjColor,1.0);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if(strokeType.x||strokeType.z){\r\n        bool tjx = isTJX(v_textureCoordinates,lineWidth);\r\n        if(tjx){\r\n            gl_FragColor = vec4(tjxColor,1.0);\r\n            return;\r\n        }\r\n    }\r\n    gl_FragColor = color;\r\n}"

            /***/
}),
/* 122 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TerrainClip = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CustomPlaneGeometry = __webpack_require__(70);

            var _WellNoBottom = __webpack_require__(71);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //地形开挖 类 (基于地形)
            var TerrainClip = exports.TerrainClip = function () {
                //========== 构造方法 ========== 
                function TerrainClip(viewer, options) {
                    _classCallCheck(this, TerrainClip);

                    if (!viewer) return;
                    this.viewer = viewer;
                    options = options || {};

                    if (!this.viewer.scene.highDynamicRange) {
                        this.viewer.scene.highDynamicRange = true;
                        this._hasChangeHighDynamicRange = true;
                    }

                    var defaultOpts = {
                        splitNum: 30, //每两点之间插值个数
                        showSelfOnly: false, //是否只显示自己
                        dig_pos_x: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        dig_pos_y: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        dig_pos_z: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        rect_dig: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
                        dig_max_index: 0, //点选点的个数
                        excavateHeight: 0, //挖掘深度
                        excavateMinHeight: 9999, //最低挖掘海拔值
                        excavatePerPoint: false //是否按插值点挖掘
                    };

                    this._positions = Cesium.defaultValue(options.positions, defaultOpts.positions);
                    this.bottomImg = Cesium.defaultValue(options.bottomImg, defaultOpts.bottomImg);
                    this.wallImg = Cesium.defaultValue(options.wallImg, defaultOpts.wallImg);
                    this.splitNum = Cesium.defaultValue(options.splitNum, defaultOpts.splitNum);
                    this.excavateDig = Cesium.defaultValue(options.excavateDig, defaultOpts.excavateDig);
                    this.dig_pos_x = Cesium.defaultValue(options.dig_pos_x, defaultOpts.dig_pos_x);
                    this.dig_pos_y = Cesium.defaultValue(options.dig_pos_y, defaultOpts.dig_pos_y);
                    this.dig_pos_z = Cesium.defaultValue(options.dig_pos_z, defaultOpts.dig_pos_z);
                    this.rect_dig = Cesium.defaultValue(options.rect_dig, defaultOpts.rect_dig);
                    this.excavateMinHeight = Cesium.defaultValue(options.excavateMinHeight, defaultOpts.excavateMinHeight);
                    this.excavatePerPoint = Cesium.defaultValue(options.excavatePerPoint, defaultOpts.excavatePerPoint);
                    this.dig_max_index = Cesium.defaultValue(options.dig_max_index, defaultOpts.dig_max_index);
                    this.defaultShowSelfOnly = Cesium.defaultValue(options.showSelfOnly, defaultOpts.showSelfOnly);
                    this._height = Cesium.defaultValue(options.height, defaultOpts.excavateHeight);
                    this.defaultShow = Cesium.defaultValue(options.show, true);
                    this.defaultBoundingSwell = Cesium.defaultValue(options.boundingSwell, 20);

                    this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall

                    this._init();
                }

                //========== 对外属性 ========== 
                //参数


                _createClass(TerrainClip, [{
                    key: "_init",


                    //========== 方法 ========== 

                    value: function _init() {
                        if (!this._positions || this._positions.length == 0) return;
                        this._startExcavate(this._positions);
                        this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');
                        this.viewer.scene.globe.depthTestAgainstTerrain = true;
                        this._effectExcavate();
                    }
                    //初始化没传顶点，后面设置顶点

                }, {
                    key: "setPositions",
                    value: function setPositions(positions) {
                        if (!positions || positions.length == 0) return;
                        this._startExcavate(positions);
                        this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');
                        this.viewer.scene.globe.depthTestAgainstTerrain = true;
                        this._effectExcavate();
                    }

                    //准备井数据

                }, {
                    key: "_prepareWell",
                    value: function _prepareWell(arr) {
                        var splitNum = this.splitNum;
                        var len = arr.length;
                        if (len == 0) return;
                        var targetHeight = this.excavateMinHeight - this.height;
                        this.targetHeight = targetHeight;
                        var no_height_top = [];
                        var bottom_pos = [];
                        var lerp_pos = [];
                        for (var i = 0; i < len; i++) {
                            var static_i = i == len - 1 ? 0 : i + 1;
                            var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
                            var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
                            var pos1 = [currRad.longitude, currRad.latitude];
                            var pos2 = [nextRad.longitude, nextRad.latitude];
                            // if (i == 0) {
                            //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
                            //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
                            //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
                            // }
                            for (var j = 0; j < splitNum; j++) {
                                var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
                                var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
                                // if (!(i == len - 1 && j == splitNum)) {
                                lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
                                bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
                                no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
                                // }
                            }
                        }
                        this.wellData = {
                            lerp_pos: lerp_pos,
                            bottom_pos: bottom_pos,
                            no_height_top: no_height_top
                        };
                    }
                    //创建井

                }, {
                    key: "_createWell",
                    value: function _createWell(options) {
                        var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
                        if (hasTerrain) {
                            var self = this;
                            this._createBottomSurface(options.bottom_pos);
                            var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
                            var maxHeight = -9999;
                            Cesium.when(promise, function (updatedPositions) {
                                var len = updatedPositions.length;
                                var top_pos = [];
                                var top_heights = [];
                                for (var k = 0; k < len; k++) {
                                    top_heights.push(updatedPositions[k].height);
                                    if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
                                    var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
                                    top_pos.push(top_car);
                                }
                                self.maxHeight = maxHeight;
                                self.top_heights = top_heights;
                                self._createWellWall(options.bottom_pos, top_pos);
                                self.viewer.scene.primitives.add(self.wellWall);
                            });
                        } else {
                            this._createBottomSurface(options.bottom_pos);
                            this._createWellWall(options.bottom_pos, options.no_height_top);
                            this.viewer.scene.primitives.add(this.wellWall);
                        }
                    }
                    //创建井壁

                }, {
                    key: "_createWellWall",
                    value: function _createWellWall(bottom, top) {
                        var geo = new _WellNoBottom.WellNoBottom({
                            minimumArr: bottom,
                            maximumArr: top
                        });
                        geo = geo.createGeometry(geo, this);
                        var _material = new Cesium.Material({
                            fabric: {
                                type: 'Image',
                                uniforms: {
                                    image: this.wallImg
                                }
                            }
                        });
                        var _appearance = new Cesium.MaterialAppearance({
                            translucent: false,
                            flat: true,
                            material: _material
                        });
                        this.wellWall = new Cesium.Primitive({
                            geometryInstances: new Cesium.GeometryInstance({
                                geometry: geo,
                                attributes: {
                                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
                                },
                                id: 'PitWall'
                            }),
                            appearance: _appearance,
                            asynchronous: false
                        });
                    }
                    //创建井底

                }, {
                    key: "_createBottomSurface",
                    value: function _createBottomSurface(bottom_pos) {
                        if (!bottom_pos.length) {
                            return;
                        }
                        var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
                            pos_arr: bottom_pos
                        });
                        geo = geo.createGeometry(geo);
                        var _material = new Cesium.Material({
                            fabric: {
                                type: 'Image',
                                uniforms: {
                                    image: this.bottomImg
                                }
                            }
                        });
                        var _appearance = new Cesium.MaterialAppearance({
                            translucent: false,
                            flat: true,
                            material: _material
                        });
                        this.bottomSurface = new Cesium.Primitive({
                            geometryInstances: new Cesium.GeometryInstance({
                                geometry: geo
                            }),
                            appearance: _appearance,
                            asynchronous: false
                        });
                    }
                    //准备挖掘

                }, {
                    key: "_prepareExcavate",
                    value: function _prepareExcavate(arr) {
                        var len = arr.length;
                        if (len == 0) return;
                        this.dig_max_index = len;

                        var minX = 99999999;
                        var minY = 99999999;
                        var minZ = 99999999;
                        var maxX = -99999999;
                        var maxY = -99999999;
                        var maxZ = -99999999;
                        for (var i = 0; i < len; i++) {
                            if (arr[i]) {
                                this.dig_pos_x[i] = arr[i].x;
                                this.dig_pos_y[i] = arr[i].y;
                                this.dig_pos_z[i] = arr[i].z;
                                var rad = Cesium.Cartographic.fromCartesian(arr[i]);
                                this.excavateMinHeight = this.excavateMinHeight > rad.height ? rad.height : this.excavateMinHeight;
                                if (arr[i].x > maxX) {
                                    maxX = arr[i].x;
                                }
                                if (arr[i].x < minX) {
                                    minX = arr[i].x;
                                }

                                if (arr[i].y > maxY) {
                                    maxY = arr[i].y;
                                }
                                if (arr[i].y < minY) {
                                    minY = arr[i].y;
                                }

                                if (arr[i].z > maxZ) {
                                    maxZ = arr[i].z;
                                }
                                if (arr[i].z < minZ) {
                                    minZ = arr[i].z;
                                }
                            } else {
                                this.dig_pos_x[i] = 0.0;
                                this.dig_pos_y[i] = 0.0;
                                this.dig_pos_z[i] = 0.0;
                            }
                        }
                        var chaNum = this.boundingSwell;
                        this._base_rect = this.rect_dig = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
                    }
                    //开始挖掘

                }, {
                    key: "_startExcavate",
                    value: function _startExcavate(arr) {
                        this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');
                        this._prepareExcavate(arr);

                        if (this._showWall) {
                            this._prepareWell(arr);
                            if (!this.wellData) return;
                            this._createWell(this.wellData);
                        }
                    }
                    //更新挖掘深度

                }, {
                    key: "_updateExcavateDepth",
                    value: function _updateExcavateDepth(depth) {
                        if (depth == undefined || depth == null) return;
                        this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
                        this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);
                        var lerp_pos = this.wellData.lerp_pos;
                        var bottom_pos = [];
                        var len = lerp_pos.length;
                        for (var i = 0; i < len; i++) {
                            bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
                        }
                        this.wellData.bottom_pos = bottom_pos;
                        this._createWell(this.wellData);

                        if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);

                        if (this.wellWall) this.viewer.scene.primitives.add(this.wellWall);
                    }
                    //挖掘生效

                }, {
                    key: "_effectExcavate",
                    value: function _effectExcavate() {
                        this.excavateAnalysis.dig_pos_x = this.dig_pos_x;
                        this.excavateAnalysis.dig_pos_y = this.dig_pos_y;
                        this.excavateAnalysis.dig_pos_z = this.dig_pos_z;
                        this.excavateAnalysis.excavateDig = this.excavateDig;
                        this.excavateAnalysis.dig_max_index = this.dig_max_index;
                        this.excavateAnalysis.showSelfOnly = this.showSelfOnly;
                        this.excavateAnalysis.rect_dig = this.rect_dig;

                        if (this.bottomSurface) this.viewer.scene.primitives.add(this.bottomSurface);
                    }
                    //切换挖掘显隐

                }, {
                    key: "_switchShow",
                    value: function _switchShow(val) {
                        if (val) {
                            this.viewer.scene.globe.material = Cesium.Material.fromType('WaJue');

                            if (this._showWall) {
                                this.wellWall.show = true;
                                this.bottomSurface.show = true;
                            }
                        } else {
                            this.viewer.scene.globe.material = null;

                            if (this._showWall) {
                                this.wellWall.show = false;
                                this.bottomSurface.show = false;
                            }
                        }
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        if (this._hasChangeHighDynamicRange) {
                            this.viewer.scene.highDynamicRange = false;
                            this._hasChangeHighDynamicRange = false;
                        }

                        this.viewer.scene.globe.material = null;
                        this.viewer.scene.globe._surface.tileProvider.resetExcavateAnalysis();

                        if (this.bottomSurface) {
                            this.viewer.scene.primitives.remove(this.bottomSurface);
                            delete this.bottomSurface;
                        }

                        if (this.wellWall) {
                            this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);
                            delete this.wellWall;
                        }

                        delete this.viewer;
                        delete this._positions;
                        delete this.bottomImg;
                        delete this.wallImg;
                        delete this.dig_pos_x;
                        delete this.dig_pos_y;
                        delete this.dig_pos_z;
                        delete this.dig_max_index;
                        delete this.excavatePerPoint;
                        delete this.splitNum;
                        delete this.excavateDig;
                        delete this.rect_dig;
                        delete this._height;
                        delete this.defaultShow;
                        delete this.defaultShowSelfOnly;
                        delete this.excavateMinHeight;
                        delete this.wellData;
                        delete this._base_rect;
                    }
                }, {
                    key: "excavateAnalysis",
                    get: function get() {
                        return this.viewer.scene.globe._surface.tileProvider.excavateAnalysis;
                    }

                    //仅显示自己

                }, {
                    key: "showSelfOnly",
                    get: function get() {
                        return this.defaultShowSelfOnly;
                    },
                    set: function set(val) {
                        this.defaultShowSelfOnly = val;
                        this.excavateAnalysis.showSelfOnly = val;
                    }

                    //挖掘深度

                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    },
                    set: function set(val) {
                        this._height = val;

                        if (this._showWall) {
                            this._updateExcavateDepth(val);
                        }
                    }
                    //显示和隐藏

                }, {
                    key: "show",
                    get: function get() {
                        return this.defaultShow;
                    },
                    set: function set(val) {
                        this.defaultShow = Boolean(val);
                        this._switchShow(Boolean(val));
                    }

                    //点集合的包围盒膨胀数值

                }, {
                    key: "boundingSwell",
                    get: function get() {
                        return this.defaultBoundingSwell;
                    },
                    set: function set(num) {
                        var rect = this._base_rect;
                        this.defaultBoundingSwell = Number(num);
                        this.rect_dig = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] + this.boundingSwell, rect[4] + this.boundingSwell, rect[5] + this.boundingSwell, 0, 0, 0];
                        this.excavateAnalysis.rect_dig = this.rect_dig;
                    }
                }]);

                return TerrainClip;
            }();

            /***/
}),
/* 123 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TerrainClipPlan = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CustomPlaneGeometry = __webpack_require__(70);

            var _WellNoBottom = __webpack_require__(71);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //地形开挖 类（平面 Plan原生）
            var TerrainClipPlan = exports.TerrainClipPlan = function () {
                //========== 构造方法 ========== 
                function TerrainClipPlan(viewer, options) {
                    _classCallCheck(this, TerrainClipPlan);

                    this.viewer = viewer;
                    this.options = options || {};

                    this._positions = options.positions;
                    this._height = this.options.height || 0;

                    this._showWall = Cesium.defaultValue(options.wall, true); //是否显示挖掘的底部和wall
                    this.bottomImg = options.bottomImg;
                    this.wallImg = options.wallImg;
                    this.splitNum = Cesium.defaultValue(options.splitNum, 50);

                    if (this._positions && this._positions.length > 0) {
                        this.updateData(this._positions);
                    }
                }

                //========== 对外属性 ==========  
                //挖掘深度


                _createClass(TerrainClipPlan, [{
                    key: "updateData",


                    //========== 方法 ========== 

                    // 创建裁剪面
                    value: function updateData(points, opts) {
                        opts = opts || {};

                        this.clear();

                        if (!points || points.length < 3) {
                            console.log("挖地坐标数据存在问题！");
                            return;
                        }

                        var clippingPlanes = [];
                        var pointsLength = points.length;

                        var unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切

                        //是否顺时针 
                        var startAngle = (0, _util.getAngle)(points[0], points[1]);
                        var endAngle = (0, _util.getAngle)(points[0], points[2]);
                        var direction = startAngle < endAngle;
                        if (unionClippingRegions) direction = !direction;

                        this.excavateMinHeight = 9999;

                        for (var i = 0; i < pointsLength; ++i) {
                            var nextIndex = (i + 1) % pointsLength;
                            var midpoint = Cesium.Cartesian3.midpoint(points[i], points[nextIndex], new Cesium.Cartesian3());

                            var tempCarto = Cesium.Cartographic.fromCartesian(points[i]);
                            var heightTerrain = this.viewer.scene.globe.getHeight(tempCarto) || tempCarto.height; //地形高度 
                            if (heightTerrain < this.excavateMinHeight) {
                                this.excavateMinHeight = heightTerrain;
                            }

                            // newArr.push(points[i]);
                            // newArr.push(midpoint);

                            var up = Cesium.Cartesian3.normalize(midpoint, new Cesium.Cartesian3());
                            var right;
                            if (direction) {
                                //顺时针
                                right = Cesium.Cartesian3.subtract(points[i], midpoint, new Cesium.Cartesian3());
                            } else {
                                right = Cesium.Cartesian3.subtract(points[nextIndex], midpoint, new Cesium.Cartesian3());
                            }
                            right = Cesium.Cartesian3.normalize(right, right);
                            var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
                            normal = Cesium.Cartesian3.normalize(normal, normal);
                            var originCenteredPlane = new Cesium.Plane(normal, 0.0);
                            var distance = Cesium.Plane.getPointDistance(originCenteredPlane, midpoint);
                            clippingPlanes.push(new Cesium.ClippingPlane(normal, distance));
                        }

                        this.viewer.scene.globe.clippingPlanes = new Cesium.ClippingPlaneCollection({
                            planes: clippingPlanes,
                            edgeWidth: Cesium.defaultValue(opts.edgeWidth, 1.0),
                            edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
                            enabled: true,
                            unionClippingRegions: unionClippingRegions
                        });
                        // this.addClippingImageMaterial(newArr);

                        if (this._showWall) {
                            this._prepareWell(points);
                            this._createWell(this.wellData);
                        }
                    }

                    //清除裁剪面

                }, {
                    key: "clear",
                    value: function clear() {
                        if (this.viewer.scene.globe.clippingPlanes) {
                            this.viewer.scene.globe.clippingPlanes.enabled = false;
                            this.viewer.scene.globe.clippingPlanes.removeAll();
                            if (!this.viewer.scene.globe.clippingPlanes.isDestroyed()) this.viewer.scene.globe.clippingPlanes.destroy();
                        }
                        this.viewer.scene.globe.clippingPlanes = undefined;

                        this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
                        this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);

                        delete this.bottomSurface;
                        delete this.wellWall;
                        delete this.wellData;

                        this.viewer.scene.render();

                        // if (this._last_depthTestAgainstTerrain !== null)
                        //     this.viewer.scene.globe.depthTestAgainstTerrain = this._last_depthTestAgainstTerrain;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.clear();
                    }

                    //准备井数据

                }, {
                    key: "_prepareWell",
                    value: function _prepareWell(arr) {
                        var splitNum = this.splitNum;
                        var len = arr.length;
                        if (len == 0) return;
                        var targetHeight = this.excavateMinHeight - this.height;
                        this.targetHeight = targetHeight;
                        var no_height_top = [];
                        var bottom_pos = [];
                        var lerp_pos = [];
                        for (var i = 0; i < len; i++) {
                            var static_i = i == len - 1 ? 0 : i + 1;
                            var currRad = Cesium.Cartographic.fromCartesian(arr[i]);
                            var nextRad = Cesium.Cartographic.fromCartesian(arr[static_i]);
                            var pos1 = [currRad.longitude, currRad.latitude];
                            var pos2 = [nextRad.longitude, nextRad.latitude];
                            // if (i == 0) {
                            //     lerp_pos.push(new Cesium.Cartographic(pos1[0], pos1[1]));
                            //     bottom_pos.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], targetHeight));
                            //     no_height_top.push(Cesium.Cartesian3.fromRadians(pos1[0], pos1[1], 0));
                            // }
                            for (var j = 0; j < splitNum; j++) {
                                var curr_pos_lon = Cesium.Math.lerp(pos1[0], pos2[0], j / splitNum);
                                var curr_pos_lat = Cesium.Math.lerp(pos1[1], pos2[1], j / splitNum);
                                // if (!(i == len - 1 && j == splitNum)) {
                                lerp_pos.push(new Cesium.Cartographic(curr_pos_lon, curr_pos_lat));
                                bottom_pos.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, targetHeight));
                                no_height_top.push(Cesium.Cartesian3.fromRadians(curr_pos_lon, curr_pos_lat, 0));
                                // }
                            }
                        }
                        this.wellData = {
                            lerp_pos: lerp_pos,
                            bottom_pos: bottom_pos,
                            no_height_top: no_height_top
                        };
                    }
                    //创建井

                }, {
                    key: "_createWell",
                    value: function _createWell(options) {
                        var hasTerrain = Boolean(this.viewer.terrainProvider._layers);
                        if (hasTerrain) {
                            var self = this;
                            this._createBottomSurface(options.bottom_pos);
                            var promise = Cesium.sampleTerrainMostDetailed(this.viewer.terrainProvider, options.lerp_pos);
                            var maxHeight = -9999;
                            Cesium.when(promise, function (updatedPositions) {
                                var len = updatedPositions.length;
                                var top_pos = [];
                                var top_heights = [];
                                for (var k = 0; k < len; k++) {
                                    top_heights.push(updatedPositions[k].height);
                                    if (updatedPositions[k].height > maxHeight) maxHeight = updatedPositions[k].height;
                                    var top_car = Cesium.Cartesian3.fromRadians(updatedPositions[k].longitude, updatedPositions[k].latitude, updatedPositions[k].height);
                                    top_pos.push(top_car);
                                }
                                self.maxHeight = maxHeight;
                                self.top_heights = top_heights;
                                self._createWellWall(options.bottom_pos, top_pos);
                                self.viewer.scene.primitives.add(self.wellWall);
                            });
                        } else {
                            this._createBottomSurface(options.bottom_pos);
                            this._createWellWall(options.bottom_pos, options.no_height_top);
                            this.viewer.scene.primitives.add(this.wellWall);
                        }
                    }
                    //创建井壁

                }, {
                    key: "_createWellWall",
                    value: function _createWellWall(bottom, top) {
                        var geo = new _WellNoBottom.WellNoBottom({
                            minimumArr: bottom,
                            maximumArr: top
                        });
                        geo = geo.createGeometry(geo, this);
                        var _material = new Cesium.Material({
                            fabric: {
                                type: 'Image',
                                uniforms: {
                                    image: this.wallImg
                                }
                            }
                        });
                        var _appearance = new Cesium.MaterialAppearance({
                            translucent: false,
                            flat: true,
                            material: _material
                        });
                        this.wellWall = new Cesium.Primitive({
                            geometryInstances: new Cesium.GeometryInstance({
                                geometry: geo,
                                attributes: {
                                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.GREY)
                                },
                                id: 'PitWall'
                            }),
                            appearance: _appearance,
                            asynchronous: false
                        });
                        this.viewer.scene.primitives.add(this.wellWall);
                    }
                    //创建井底

                }, {
                    key: "_createBottomSurface",
                    value: function _createBottomSurface(bottom_pos) {
                        if (!bottom_pos.length) {
                            return;
                        }
                        var geo = new _CustomPlaneGeometry.CustomPlaneGeometry({
                            pos_arr: bottom_pos
                        });
                        geo = geo.createGeometry(geo);
                        var _material = new Cesium.Material({
                            fabric: {
                                type: 'Image',
                                uniforms: {
                                    image: this.bottomImg
                                }
                            }
                        });
                        var _appearance = new Cesium.MaterialAppearance({
                            translucent: false,
                            flat: true,
                            material: _material
                        });
                        this.bottomSurface = new Cesium.Primitive({
                            geometryInstances: new Cesium.GeometryInstance({
                                geometry: geo
                            }),
                            appearance: _appearance,
                            asynchronous: false
                        });
                        this.viewer.scene.primitives.add(this.bottomSurface);
                    }

                    //切换挖掘显隐

                }, {
                    key: "_switchExcavate",
                    value: function _switchExcavate(val) {
                        if (val) {
                            if (this.wellWall) this.wellWall.show = true;
                            if (this.bottomSurface) this.bottomSurface.show = true;
                        } else {
                            if (this.wellWall) this.wellWall.show = false;
                            if (this.bottomSurface) this.bottomSurface.show = false;
                        }
                    }

                    //更新挖掘深度

                }, {
                    key: "_updateExcavateDepth",
                    value: function _updateExcavateDepth(depth) {
                        if (!this.wellData) return;

                        this.bottomSurface && this.viewer.scene.primitives.remove(this.bottomSurface);
                        this.wellWall && this.viewer.scene.primitives.remove(this.wellWall);

                        var lerp_pos = this.wellData.lerp_pos;
                        var bottom_pos = [];
                        var len = lerp_pos.length;
                        for (var i = 0; i < len; i++) {
                            bottom_pos.push(Cesium.Cartesian3.fromRadians(lerp_pos[i].longitude, lerp_pos[i].latitude, this.excavateMinHeight - depth));
                        }
                        this.wellData.bottom_pos = bottom_pos;
                        this._createWell(this.wellData);

                        this.viewer.scene.primitives.add(this.bottomSurface);
                        this.viewer.scene.primitives.add(this.wellWall);
                    }
                }, {
                    key: "show",
                    get: function get() {
                        return this._show;
                    },
                    set: function set(val) {
                        this._show = val;

                        if (this.viewer.scene.globe.clippingPlanes) this.viewer.scene.globe.clippingPlanes.enabled = val;

                        if (this._showWall) {
                            this._switchExcavate(val);
                        }
                    }

                    //裁剪距离 

                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    },
                    set: function set(val) {
                        this._height = val;

                        if (this._showWall) {
                            this._updateExcavateDepth(val);
                        }
                    }
                }]);

                return TerrainClipPlan;
            }();

            /***/
}),
/* 124 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Underground = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //地下模式类
            var Underground = exports.Underground = function () {
                //========== 构造方法 ========== 
                function Underground(viewer, options) {
                    _classCallCheck(this, Underground);

                    this.viewer = viewer;

                    var opts = Cesium.defaultValue(options, {});

                    this._depth = Cesium.defaultValue(opts.depth, 500);
                    this._alpha = Cesium.defaultValue(opts.alpha, 0.5);

                    this.enable = Cesium.defaultValue(opts.enable, false);
                }

                //========== 对外属性 ==========  
                //显示和隐藏


                _createClass(Underground, [{
                    key: "_updateImageryLayersAlpha",


                    //========== 方法 ========== 
                    value: function _updateImageryLayersAlpha(alpha) {
                        var _layers = this.viewer.imageryLayers._layers;
                        for (var i = 0, len = _layers.length; i < len; i++) {
                            _layers[i].alpha = alpha;
                        }
                    }

                    //记录历史值，用于还原

                }, {
                    key: "_historyOpts",
                    value: function _historyOpts() {
                        var oldOpts = {};
                        oldOpts.alpha = Cesium.clone(this.viewer.imageryLayers._layers[0] && this.viewer.imageryLayers._layers[0].alpha);
                        oldOpts.highDynamicRange = Cesium.clone(this.viewer.scene.highDynamicRange);
                        oldOpts.skyShow = Cesium.clone(this.viewer.scene.skyAtmosphere.show);
                        oldOpts.skyBoxShow = Cesium.clone(this.viewer.scene.skyBox.show);
                        oldOpts.depthTest = Cesium.clone(this.viewer.scene.globe.depthTestAgainstTerrain);

                        if (this.viewer.scene.globe._surface && this.viewer.scene.globe._surface._tileProvider && this.viewer.scene.globe._surface._tileProvider._renderState) oldOpts.blending = Cesium.clone(this.viewer.scene.globe._surface._tileProvider._renderState.blending);

                        this._oldViewOpts = oldOpts;
                    }
                }, {
                    key: "activate",
                    value: function activate() {
                        if (this._enable) return;
                        this._enable = true;

                        this._historyOpts();
                        this._updateImageryLayersAlpha(this._alpha);

                        var viewer = this.viewer;

                        Cesium.ExpandByMapV.underEarth.cullFace = false;
                        Cesium.ExpandByMapV.underEarth.enable = true;
                        Cesium.ExpandByMapV.underEarth.enableDepth = this._depth;
                        Cesium.ExpandByMapV.underEarth.enableSkirt = true;

                        viewer.scene.globe.depthTestAgainstTerrain = true;
                        viewer.scene.highDynamicRange = false;
                        viewer.scene.skyAtmosphere.show = false;
                        viewer.scene.skyBox.show = false;

                        if (viewer.scene.globe._surface._tileProvider && viewer.scene.globe._surface._tileProvider._renderState && viewer.scene.globe._surface._tileProvider._renderState.blending) {
                            viewer.scene.globe._surface._tileProvider._renderState.blending.enabled = true;

                            viewer.scene.globe._surface._tileProvider._renderState.blending.equationRgb = Cesium.BlendEquation.ADD;
                            viewer.scene.globe._surface._tileProvider._renderState.blending.equationAlpha = Cesium.BlendEquation.ADD;

                            viewer.scene.globe._surface._tileProvider._renderState.blending.functionSourceAlpha = Cesium.BlendFunction.ONE;
                            viewer.scene.globe._surface._tileProvider._renderState.blending.functionSourceRgb = Cesium.BlendFunction.ONE;

                            viewer.scene.globe._surface._tileProvider._renderState.blending.functionDestinationAlpha = Cesium.BlendFunction.ZERO;
                            viewer.scene.globe._surface._tileProvider._renderState.blending.functionDestinationRgb = Cesium.BlendFunction.ZERO;
                        }
                    }
                }, {
                    key: "disable",
                    value: function disable() {
                        if (!this._enable) return;
                        this._enable = false;

                        this._updateImageryLayersAlpha(this._oldViewOpts.alpha);

                        var viewer = this.viewer;

                        Cesium.ExpandByMapV.underEarth.cullFace = undefined;
                        Cesium.ExpandByMapV.underEarth.enable = false;
                        Cesium.ExpandByMapV.underEarth.enableDepth = 0;
                        Cesium.ExpandByMapV.underEarth.enableSkirt = false;

                        viewer.scene.globe.depthTestAgainstTerrain = this._oldViewOpts.depthTest;
                        viewer.scene.skyBox.show = this._oldViewOpts.skyBoxShow;
                        viewer.scene.highDynamicRange = this._oldViewOpts.highDynamicRange;
                        viewer.scene.skyAtmosphere.show = this._oldViewOpts.skyShow;

                        if (this._oldViewOpts.blending != undefined) viewer.scene.globe._surface._tileProvider._renderState.blending = this._oldViewOpts.blending;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.disable();

                        delete this.viewer;
                        delete this._alpha;
                        delete this._depth;
                        delete this._enable;
                        delete this._oldViewOpts;
                    }
                }, {
                    key: "alpha",
                    get: function get() {
                        return this._alpha;
                    },
                    set: function set(val) {
                        this._alpha = Number(val);

                        if (!this._enable) return;
                        this._updateImageryLayersAlpha(this._alpha);
                    }
                }, {
                    key: "depth",
                    get: function get() {
                        return this._depth;
                    },
                    set: function set(val) {
                        this._depth = Number(val);

                        if (!this._enable) return;
                        Cesium.ExpandByMapV.underEarth.enableDepth = this._depth;
                    }
                }, {
                    key: "enable",
                    get: function get() {
                        return this._enable;
                    },
                    set: function set(value) {
                        if (value) this.activate(); else this.disable();
                    }
                }]);

                return Underground;
            }();

            /***/
}),
/* 125 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ViewShed3D = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _ViewFieldFS = __webpack_require__(126);

            var _ViewFieldFS2 = _interopRequireDefault(_ViewFieldFS);

            var _RectangularSensorGraphics = __webpack_require__(72);

            var _point = __webpack_require__(2);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var defaultOpts = {
                cameraPosition: null, //相机位置
                viewPosition: null, //视点位置
                horizontalAngle: 120, //水平张角
                verticalAngle: 90, //垂直张角
                visibleAreaColor: new Cesium.Color(0, 1, 0), //可视颜色
                hiddenAreaColor: new Cesium.Color(1, 0, 0), //不可视颜色
                alpha: 0.5, //混合度
                distance: 100, //距离
                frustum: true, //视椎体显示
                show: true //可视域显示


                //   可视分析 类
            };
            var ViewShed3D = exports.ViewShed3D = function () {
                //========== 构造方法 ========== 
                function ViewShed3D(viewer, options) {
                    _classCallCheck(this, ViewShed3D);

                    if (!viewer) return;
                    if (!options) options = {};

                    this.viewer = viewer;
                    this.cameraPosition = Cesium.defaultValue(options.cameraPosition, defaultOpts.cameraPosition);
                    this.viewPosition = Cesium.defaultValue(options.viewPosition, defaultOpts.viewPosition);
                    this._horizontalAngle = Cesium.defaultValue(options.horizontalAngle, defaultOpts.horizontalAngle);
                    this._verticalAngle = Cesium.defaultValue(options.verticalAngle, defaultOpts.verticalAngle);
                    this._visibleAreaColor = Cesium.defaultValue(options.visibleAreaColor, defaultOpts.visibleAreaColor);
                    this._hiddenAreaColor = Cesium.defaultValue(options.hiddenAreaColor, defaultOpts.hiddenAreaColor);
                    this._alpha = Cesium.defaultValue(options.alpha, defaultOpts.alpha);
                    this._distance = Cesium.defaultValue(options.distance, defaultOpts.distance);
                    this._frustum = Cesium.defaultValue(options.frustum, defaultOpts.frustum);
                    this.calback = options.calback;
                    this.defaultShow = Cesium.defaultValue(options.show, true);
                    this._maximumDistance = Cesium.defaultValue(options.maximumDistance, 5000.0);
                    this._offsetHeight = Cesium.defaultValue(options.offsetHeight, 1.5);

                    this.viewer.terrainShadows = Cesium.ShadowMode.ENABLED;

                    this._defaultColorTexture = new Cesium.Texture({ //默认材质
                        context: this.viewer.scene.context,
                        source: {
                            width: 1,
                            height: 1,
                            arrayBufferView: new Uint8Array([0, 0, 0, 0])
                        },
                        flipY: false
                    });
                    if (this.cameraPosition && this.viewPosition) {
                        this._addToScene();
                        this.calback && this.calback(this._distance, this);
                    } else {
                        this._bindMourseEvent();
                    }
                }

                //========== 对外属性 ========== 
                //水平张角


                _createClass(ViewShed3D, [{
                    key: "_bindMourseEvent",


                    //========== 方法 ========== 

                    //激活绑定事件
                    value: function _bindMourseEvent() {
                        var that = this;
                        var viewer = this.viewer;
                        var handler = new Cesium.ScreenSpaceEventHandler(this.viewer.scene.canvas);
                        handler.setInputAction(function (movement) {
                            var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.position);
                            if (!cartesian) return;

                            if (!that.cameraPosition) {
                                //相机位置 
                                cartesian = (0, _point.addPositionsHeight)(cartesian, that._offsetHeight); //加人的身高等因素，略微抬高一些

                                that.cameraPosition = cartesian;
                            } else if (that.cameraPosition && !that.viewPosition) {
                                that.viewPosition = cartesian;
                                that._addToScene();
                                that._unbindMourseEvent();
                                that.calback && that.calback(that._distance, that);
                            }
                        }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                        handler.setInputAction(function (movement) {
                            var cartesian = (0, _point.getCurrentMousePosition)(viewer.scene, movement.endPosition);
                            if (!cartesian) return;
                            var cp = that.cameraPosition;
                            if (cp) {
                                that.frustumQuaternion = that.getFrustumQuaternion(cp, cartesian);
                                that.distance = Number(Cesium.Cartesian3.distance(cp, cartesian).toFixed(1));
                            }
                        }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                        this._handler = handler;
                    }

                    //解绑事件

                }, {
                    key: "_unbindMourseEvent",
                    value: function _unbindMourseEvent() {
                        if (this._handler == null) return;

                        this._handler.destroy();
                        delete this._handler;
                    }
                    //添加到场景里

                }, {
                    key: "_addToScene",
                    value: function _addToScene() {
                        this.frustumQuaternion = this.getFrustumQuaternion(this.cameraPosition, this.viewPosition);
                        this._createShadowMap(this.cameraPosition, this.viewPosition);
                        this._addPostProcess();
                        !this.radar && this.addRadar(this.cameraPosition, this.frustumQuaternion);
                        this.viewer.scene.primitives.add(this);
                    }

                    //创建ShadowMap

                }, {
                    key: "_createShadowMap",
                    value: function _createShadowMap(cpos, viewPosition, fq) {
                        var camera_pos = cpos;
                        var lookat_pos = viewPosition;
                        var scene = this.viewer.scene;
                        var camera1 = new Cesium.Camera(scene);
                        camera1.position = camera_pos;
                        camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
                        camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));

                        var far = Number(Cesium.Cartesian3.distance(lookat_pos, camera_pos).toFixed(1));
                        this.distance = far;

                        camera1.frustum = new Cesium.PerspectiveFrustum({
                            fov: Cesium.Math.toRadians(120),
                            aspectRatio: scene.canvas.clientWidth / scene.canvas.clientHeight,
                            near: 0.1,
                            far: 5000
                        });

                        var isSpotLight = true;
                        this.viewShadowMap = new Cesium.ShadowMap({
                            lightCamera: camera1,
                            enable: false,
                            isPointLight: !isSpotLight,
                            isSpotLight: isSpotLight,
                            cascadesEnabled: false,
                            context: scene.context,
                            pointLightRadius: far,
                            maximumDistance: this._maximumDistance
                        });
                    }

                    //获取四元数

                }, {
                    key: "getFrustumQuaternion",
                    value: function getFrustumQuaternion(cpos, viewPosition) {
                        //获取相机四元数，用来调整视椎体摆放
                        var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(viewPosition, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                        var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
                        var camera = new Cesium.Camera(this.viewer.scene);
                        camera.position = cpos;
                        camera.direction = direction;
                        camera.up = up;
                        direction = camera.directionWC;
                        up = camera.upWC;
                        var right = camera.rightWC;
                        var scratchRight = new Cesium.Cartesian3();
                        var scratchRotation = new Cesium.Matrix3();
                        var scratchOrientation = new Cesium.Quaternion();

                        // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
                        right = Cesium.Cartesian3.negate(right, scratchRight);
                        var rotation = scratchRotation;
                        Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
                        Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
                        Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
                        //计算视锥姿态
                        var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
                        return orientation;
                    }

                    //添加后处理

                }, {
                    key: "_addPostProcess",
                    value: function _addPostProcess() {
                        var that = this;
                        var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
                        this.postProcess = new Cesium.PostProcessStage({
                            fragmentShader: _ViewFieldFS2.default,
                            uniforms: {
                                czzj: function czzj() {
                                    return that.verticalAngle;
                                },
                                dis: function dis() {
                                    return that.distance;
                                },
                                spzj: function spzj() {
                                    return that.horizontalAngle;
                                },
                                visibleColor: function visibleColor() {
                                    return that.visibleAreaColor;
                                },
                                disVisibleColor: function disVisibleColor() {
                                    return that.hiddenAreaColor;
                                },
                                mixNum: function mixNum() {
                                    return that.alpha;
                                },
                                mapvShadow: function mapvShadow() {
                                    return that.viewShadowMap._shadowMapTexture || that._defaultColorTexture;
                                },
                                _shadowMap_matrix: function _shadowMap_matrix() {
                                    return that.viewShadowMap._shadowMapMatrix;
                                },
                                shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
                                    return that.viewShadowMap._lightPositionEC;
                                },
                                shadowMap_lightPositionWC: function shadowMap_lightPositionWC() {
                                    return that.viewShadowMap._lightCamera.position;
                                },
                                shadowMap_lightDirectionEC: function shadowMap_lightDirectionEC() {
                                    return that.viewShadowMap._lightDirectionEC;
                                },
                                shadowMap_lightUp: function shadowMap_lightUp() {
                                    return that.viewShadowMap._lightCamera.up;
                                },
                                shadowMap_lightDir: function shadowMap_lightDir() {
                                    return that.viewShadowMap._lightCamera.direction;
                                },
                                shadowMap_lightRight: function shadowMap_lightRight() {
                                    return that.viewShadowMap._lightCamera.right;
                                },
                                shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
                                    var texelStepSize = new Cesium.Cartesian2();
                                    texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
                                    texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
                                    return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
                                },
                                shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
                                    return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
                                },
                                depthTexture1: function depthTexture1() {
                                    return that.getSceneDepthTexture(that.viewer);
                                    // return that._defaultDepth;
                                }
                            }
                        });
                        this.show && this.viewer.scene.postProcessStages.add(this.postProcess);
                    }
                }, {
                    key: "getSceneDepthTexture",
                    value: function getSceneDepthTexture(viewer) {
                        var scene = viewer.scene;
                        var environmentState = scene._environmentState;
                        var view = scene._view;
                        var useGlobeDepthFramebuffer = environmentState.useGlobeDepthFramebuffer;
                        var globeFramebuffer = useGlobeDepthFramebuffer ? view.globeDepth.framebuffer : undefined;
                        var sceneFramebuffer = view.sceneFramebuffer.getFramebuffer();
                        var depthTexture = Cesium.defaultValue(globeFramebuffer, sceneFramebuffer).depthStencilTexture; //对的

                        // var depthTexture = scene._view.pickDepths[0]._depthTexture;
                        // var depthTexture = scene._view.pickDepths[0]._textureToCopy;
                        // var depthTexture = scene._view.pickDepths[0]._copyDepthCommand._framebuffer._colorTextures[0];
                        // var depthTexture = this.wyypost&&this.wyypost._depthTexture?this.wyypost._depthTexture:scene.context.uniformState.globeDepthTexture;
                        // var depthTexture = scene.context.uniformState.globeDepthTexture;//对的
                        return depthTexture;
                    }

                    //删除雷达

                }, {
                    key: "removeRadar",
                    value: function removeRadar() {
                        this.viewer.entities.remove(this.radar);
                    }
                    //重置雷达

                }, {
                    key: "resetRadar",
                    value: function resetRadar() {
                        this.removeRadar();
                        this.addRadar(this.cameraPosition, this.frustumQuaternion);
                    }
                    //添加雷达

                }, {
                    key: "addRadar",
                    value: function addRadar(cpos, frustumQuaternion) {
                        var position = cpos;
                        var that = this;
                        this.radar = this.viewer.entities.add({
                            position: position,
                            orientation: frustumQuaternion,
                            show: this.show,
                            rectangularSensor: new _RectangularSensorGraphics.RectangularSensorGraphics({
                                radius: that.distance, //传感器的半径
                                xHalfAngle: Cesium.Math.toRadians(that.horizontalAngle / 2), //传感器水平半角
                                yHalfAngle: Cesium.Math.toRadians(that.verticalAngle / 2), //传感器垂直半角 
                                material: new Cesium.Color(0.0, 1.0, 1.0, 0.4), //目前用的统一材质
                                lineColor: new Cesium.Color(1.0, 1.0, 1.0, 1.0), //线的颜色
                                slice: 8,
                                showScanPlane: false, //是否显示扫描面 
                                showThroughEllipsoid: false, //此参数控制深度检测，为false启用深度检测，可以解决雷达一半在地球背面时显示的问题
                                showLateralSurfaces: false,
                                showDomeSurfaces: false
                            })
                        });
                    }

                    //更新

                }, {
                    key: "update",
                    value: function update(frameState) {
                        this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
                    }
                }, {
                    key: "_switchShow",
                    value: function _switchShow() {
                        if (this.show) {
                            !this.postProcess && this._addPostProcess();
                        } else {
                            this.viewer.scene.postProcessStages.remove(this.postProcess);
                            delete this.postProcess;
                            this.postProcess = null;
                        }
                        this.radar.show = this.show;
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.terrainShadows = Cesium.ShadowMode.DISABLED;
                        this._unbindMourseEvent();

                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.entities.remove(this.radar);

                        delete this.radar;
                        delete this.postProcess;
                        delete this.viewShadowMap;
                        delete this.verticalAngle;
                        delete this.viewer;
                        delete this.horizontalAngle;
                        delete this.visibleAreaColor;
                        delete this.hiddenAreaColor;
                        delete this.distance;
                        delete this.frustumQuaternion;
                        delete this.cameraPosition;
                        delete this.viewPosition;
                        delete this.alpha;
                    }
                }, {
                    key: "horizontalAngle",
                    get: function get() {
                        return this._horizontalAngle;
                    },
                    set: function set(val) {
                        this._horizontalAngle = val;
                        this.resetRadar();
                    }
                    //垂直张角

                }, {
                    key: "verticalAngle",
                    get: function get() {
                        return this._verticalAngle;
                    },
                    set: function set(val) {
                        this._verticalAngle = val;
                        this.resetRadar();
                    }
                    //可视距离

                }, {
                    key: "distance",
                    get: function get() {
                        return this._distance;
                    },
                    set: function set(val) {
                        this._distance = val;
                        this.resetRadar();
                    }
                    //可视区域颜色

                }, {
                    key: "visibleAreaColor",
                    get: function get() {
                        return this._visibleAreaColor;
                    },
                    set: function set(val) {
                        this._visibleAreaColor = val;
                    }
                    //不可视区域颜色

                }, {
                    key: "hiddenAreaColor",
                    get: function get() {
                        return this._hiddenAreaColor;
                    },
                    set: function set(val) {
                        this._hiddenAreaColor = val;
                    }
                    //混合系数0-1

                }, {
                    key: "alpha",
                    get: function get() {
                        return this._alpha;
                    },
                    set: function set(val) {
                        this._alpha = val;
                    }
                    //显示和隐藏

                }, {
                    key: "show",
                    get: function get() {
                        return this.defaultShow;
                    },
                    set: function set(val) {
                        this.defaultShow = Boolean(val);
                        this._switchShow();
                    }
                }]);

                return ViewShed3D;
            }();

            /***/
}),
/* 126 */
/***/ (function (module, exports) {

            module.exports = "uniform float czzj;\r\nuniform float dis;\r\nuniform float spzj;\r\nuniform vec3 visibleColor;\r\nuniform vec3 disVisibleColor;\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D mapvShadow; \r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec3 shadowMap_lightPositionWC;\r\nuniform vec4 shadowMap_lightDirectionEC;\r\nuniform vec3 shadowMap_lightUp;\r\nuniform vec3 shadowMap_lightDir;\r\nuniform vec3 shadowMap_lightRight;\r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n\r\n    // vec4 stcc = texture2D(mapvShadow, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n    // float depth = czm_unpackDepth(texture2D(depthTexture, v_textureCoordinates));\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //坐标与视点位置距离，大于最大距离则舍弃阴影效果\r\n    vec4 lw = vec4(shadowMap_lightPositionWC,1.0);\r\n    vec4 vw = czm_inverseView* vec4(positionEC.xyz, 1.0);\r\n    if(distance(lw.xyz,vw.xyz)>dis){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n\r\n    //水平夹角限制\r\n    vec3 ptOnSP = pointProjectOnPlane(shadowMap_lightUp,lw.xyz,vw.xyz);\r\n    directionEC = ptOnSP - lw.xyz;\r\n    float directionECMO = ptm(directionEC.xyz);\r\n    float shadowMap_lightDirMO = ptm(shadowMap_lightDir.xyz);\r\n    float cosJJ = dot(directionEC,shadowMap_lightDir)/(directionECMO*shadowMap_lightDirMO);\r\n    float degJJ = acos(cosJJ)*(180.0 / PI);\r\n    degJJ = abs(degJJ);\r\n    if(degJJ>spzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    //垂直夹角限制\r\n    vec3 ptOnCZ = pointProjectOnPlane(shadowMap_lightRight,lw.xyz,vw.xyz);\r\n    vec3 dirOnCZ = ptOnCZ - lw.xyz;\r\n    float dirOnCZMO = ptm(dirOnCZ);\r\n    float cosJJCZ = dot(dirOnCZ,shadowMap_lightDir)/(dirOnCZMO*shadowMap_lightDirMO);\r\n    float degJJCZ = acos(cosJJCZ)*(180.0 / PI);\r\n    degJJCZ = abs(degJJCZ);\r\n    if(degJJCZ>czzj/2.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(mapvShadow, shadowParameters); \r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(visibleColor,1.0),mixNum);\r\n    }else{\r\n        // if(abs(shadowPosition.z-0.0)<0.01){\r\n        //     return;\r\n        // }\r\n        gl_FragColor = mix(color,vec4(disVisibleColor,1.0),mixNum);\r\n    }\r\n} "

            /***/
}),
/* 127 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Sightline = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //通视分析 类
            var Sightline = exports.Sightline = function () {
                function Sightline(viewer, options) {
                    _classCallCheck(this, Sightline);

                    this.viewer = viewer;

                    if (!options) options = {};

                    this.lines = [];
                    this._visibleColor = Cesium.defaultValue(options.visibleColor, new Cesium.Color(0, 1, 0, 1)); //可视区域
                    this._hiddenColor = Cesium.defaultValue(options.hiddenColor, new Cesium.Color(1, 0, 0, 1)); //不可视区域
                    this._depthFailColor = Cesium.defaultValue(options.depthFailColor, new Cesium.Color(1, 0, 0, 0.1));

                    if (options.originPoint && options.targetPoint) {
                        this.add(options.originPoint, options.targetPoint);
                    }
                }
                //========== 对外属性 ========== 

                //可视区域颜色


                _createClass(Sightline, [{
                    key: "add",


                    //========== 方法 ==========  
                    value: function add(origin, target, addHeight) {
                        if (addHeight) origin = (0, _point.addPositionsHeight)(origin, addHeight); //加人的身高

                        var currDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(target, origin, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                        var currRay = new Cesium.Ray(origin, currDir);
                        var pickRes = this.viewer.scene.drillPickFromRay(currRay, 2, this.lines);

                        if (Cesium.defined(pickRes) && pickRes.length > 0 && Cesium.defined(pickRes[0]) && Cesium.defined(pickRes[0].position)) {
                            var position = pickRes[0].position;

                            //存在正常分析结果
                            var entity1 = this.viewer.entities.add({
                                polyline: {
                                    positions: [origin, position],
                                    width: 2,
                                    material: this._visibleColor,
                                    depthFailMaterial: this._depthFailColor
                                }
                            });
                            this.lines.push(entity1);

                            var entity2 = this.viewer.entities.add({
                                polyline: {
                                    positions: [position, target],
                                    width: 2,
                                    material: this._hiddenColor,
                                    depthFailMaterial: this._depthFailColor
                                }
                            });
                            this.lines.push(entity2);

                            return [entity1, entity2];
                        } else {
                            var entity1 = this.viewer.entities.add({
                                polyline: {
                                    positions: [origin, target],
                                    width: 2,
                                    material: this._visibleColor,
                                    depthFailMaterial: this._depthFailColor
                                }
                            });
                            this.lines.push(entity1);

                            return [entity1];
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var i = 0, len = this.lines.length; i < len; i++) {
                            this.viewer.entities.remove(this.lines[i]);
                        }
                        this.lines = [];
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.clear();

                        delete this.viewer;
                        delete this._visibleColor;
                        delete this._hiddenColor;
                    }
                }, {
                    key: "visibleColor",
                    get: function get() {
                        return this._visibleColor;
                    },
                    set: function set(val) {
                        this._visibleColor = val;
                    }
                    //不可视区域颜色

                }, {
                    key: "hiddenColor",
                    get: function get() {
                        return this._hiddenColor;
                    },
                    set: function set(val) {
                        this._hiddenColor = val;
                    }

                    //depthFailMaterial颜色，默认为不可视区域颜色

                }, {
                    key: "depthFailColor",
                    get: function get() {
                        return this._depthFailColor;
                    },
                    set: function set(val) {
                        this._depthFailColor = val;
                    }
                }]);

                return Sightline;
            }();

            /***/
}),
/* 128 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.HeightCounterByTerrain = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //等高线分析 类
            var HeightCounterByTerrain = exports.HeightCounterByTerrain = function () {
                //========== 构造方法 ========== 
                function HeightCounterByTerrain(viewer, options) {
                    _classCallCheck(this, HeightCounterByTerrain);

                    this.viewer = viewer;
                    options = options || {};

                    var defaultOpts = {
                        floodVar: [0, 0, 0, 500], //[基础淹没高度，当前淹没高度，最大淹没高度,默认高度差(最大淹没高度 - 基础淹没高度)]
                        ym_pos_x: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        ym_pos_y: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        ym_pos_z: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
                        rect_flood: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], //包围盒[minx,miny,minz,maxx,maxy,maxz,0.0,0.0,0.0]
                        floodSpeed: 1, //淹没速度
                        ym_max_index: 0, //点选点的个数
                        globe: true, //是否全球淹没
                        showElseArea: true //是否显示非淹没区域
                    };

                    this._positions = Cesium.defaultValue(options.positions, Cesium.clone(defaultOpts.positions));

                    this.floodVar = Cesium.defaultValue(options.floodVar, Cesium.clone(defaultOpts.floodVar));
                    this.ym_pos_x = Cesium.defaultValue(options.ym_pos_x, Cesium.clone(defaultOpts.ym_pos_x));
                    this.ym_pos_y = Cesium.defaultValue(options.ym_pos_y, Cesium.clone(defaultOpts.ym_pos_y));
                    this.ym_pos_z = Cesium.defaultValue(options.ym_pos_z, Cesium.clone(defaultOpts.ym_pos_z));
                    this.rect_flood = Cesium.defaultValue(options.rect_flood, Cesium.clone(defaultOpts.rect_flood));
                    this.ym_max_index = Cesium.defaultValue(options.ym_max_index, Cesium.clone(defaultOpts.ym_max_index));
                    this._globe = Cesium.defaultValue(options.globe, Cesium.clone(defaultOpts.globe));
                    this._visibleOutArea = Cesium.defaultValue(options.visibleOutArea, Cesium.clone(defaultOpts.showElseArea));
                    this._boundingSwell = Cesium.defaultValue(options.boundingSwell, 20); //点集合的包围盒膨胀数值
                    this.defaultShow = Cesium.defaultValue(options.show, true);
                    this.onStop = Cesium.defaultValue(options.onStop, null);
                    this.height = Cesium.defaultValue(options.height, null);
                    this._init();
                }

                //========== 对外属性 ==========  
                //分析参数


                _createClass(HeightCounterByTerrain, [{
                    key: "_checkArgs",

                    //========== 方法 ========== 

                    //检查参数
                    value: function _checkArgs() {
                        if (this.minHeight == undefined || this.maxHeight == undefined) {
                            console.log("请确认高度值为数值！");
                            return false;
                        }
                        if (this.minHeight > this.maxHeight) {
                            //互相交换数据
                            var temp = this.minHeight;
                            this.minHeight = this.maxHeight;
                            this.maxHeight = temp;
                        }
                        return true;
                    }
                    //初始化

                }, {
                    key: "_init",
                    value: function _init() {
                        if (!this._positions || this._positions.length == 0) return;
                        this._prepareFlood(this._positions);
                        this._setFloodVar();
                        this._startFlood();
                    }

                    //初始化没传顶点，后面设置顶点

                }, {
                    key: "setPositions",
                    value: function setPositions(positions) {
                        if (!positions || positions.length == 0) return;
                        this._prepareFlood(positions);
                        this._setFloodVar();
                        this._startFlood();
                    }

                    //重新淹没

                }, {
                    key: "reFlood",
                    value: function reFlood() {
                        this.floodVar[1] = this.floodVar[0];
                    }
                }, {
                    key: "_switchShow",
                    value: function _switchShow() {
                        if (this.show) {
                            this.viewer.scene.globe.material = Cesium.Material.fromType('YanMo');
                        } else {
                            this.viewer.scene.globe.material = null;
                        }
                    }

                    //与处理顶点数组

                }, {
                    key: "_prepareFlood",
                    value: function _prepareFlood(arr) {
                        this.ym_pos_arr = arr;
                        var len = arr.length;
                        if (len == 0) return;
                        this.ym_max_index = len;
                        var minX = 99999999;
                        var minY = 99999999;
                        var minZ = 99999999;
                        var maxX = -99999999;
                        var maxY = -99999999;
                        var maxZ = -99999999;
                        for (var i = 0; i < len; i++) {
                            if (arr[i]) {
                                this.ym_pos_x[i] = arr[i].x;
                                this.ym_pos_y[i] = arr[i].y;
                                this.ym_pos_z[i] = arr[i].z;

                                if (arr[i].x > maxX) {
                                    maxX = arr[i].x;
                                }
                                if (arr[i].x < minX) {
                                    minX = arr[i].x;
                                }

                                if (arr[i].y > maxY) {
                                    maxY = arr[i].y;
                                }
                                if (arr[i].y < minY) {
                                    minY = arr[i].y;
                                }

                                if (arr[i].z > maxZ) {
                                    maxZ = arr[i].z;
                                }
                                if (arr[i].z < minZ) {
                                    minZ = arr[i].z;
                                }
                            } else {
                                this.ym_pos_x[i] = 0.0;
                                this.ym_pos_y[i] = 0.0;
                                this.ym_pos_z[i] = 0.0;
                            }
                        }
                        var chaNum = this.boundingSwell;
                        this._base_rect = this.rect_flood = [minX - chaNum, minY - chaNum, minZ - chaNum, maxX + chaNum, maxY + chaNum, maxZ + chaNum, 0.0, 0.0, 0.0];
                    }
                    //设置淹没高度

                }, {
                    key: "_setFloodVar",
                    value: function _setFloodVar() {
                        this.floodVar = [this.minHeight, this.minHeight, this.maxHeight, this.maxHeight - this.minHeight];
                    }
                    //开始淹没

                }, {
                    key: "_startFlood",
                    value: function _startFlood() {
                        this.floodAnalysis.floodVar[0] = this.floodVar[0];
                        this.floodAnalysis.floodVar[1] = this.floodVar[1];
                        this.floodAnalysis.ym_pos_x = this.ym_pos_x;
                        this.floodAnalysis.ym_pos_y = this.ym_pos_y;
                        this.floodAnalysis.ym_pos_z = this.ym_pos_z;
                        this.floodAnalysis.rect_flood = this.rect_flood;
                        this.floodAnalysis.ym_pos_arr = this.ym_pos_arr;
                        this.floodAnalysis.ym_max_index = this.ym_max_index;
                        this.floodAnalysis.globe = this.globe = false;
                        this.floodAnalysis.showElseArea = this.visibleOutArea;
                        this.viewer.scene.globe.material = Cesium.Material.fromType('ElevationContour');
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        if (this.viewer) {
                            this.viewer.scene.globe.material = null;
                        }
                        this.viewer.scene.globe._surface.tileProvider.resetFloodAnalysis();

                        delete this.activeFlooding;
                        delete this.viewer;
                        delete this.ym_max_height;
                        delete this.ym_pos_x;
                        delete this.ym_pos_y;
                        delete this.ym_pos_z;
                        delete this.ym_pos_arr;
                        delete this.ym_max_index;
                        delete this.globe;
                        delete this.maxDepthOfWater;
                        delete this.rect_flood;
                    }
                }, {
                    key: "floodAnalysis",
                    get: function get() {
                        return this.viewer.scene.globe._surface.tileProvider.floodAnalysis;
                    }

                    //显示非淹没区域

                }, {
                    key: "visibleOutArea",
                    get: function get() {
                        return this._visibleOutArea;
                    },
                    set: function set(val) {
                        this._visibleOutArea = val;
                        this.floodAnalysis.showElseArea = val;
                    }

                    //全球

                }, {
                    key: "globe",
                    get: function get() {
                        return this._globe;
                    },
                    set: function set(val) {
                        this._globe = val;
                        this.floodAnalysis.globe = val;
                    }

                    //点集合的包围盒膨胀数值

                }, {
                    key: "boundingSwell",
                    get: function get() {
                        return this._boundingSwell;
                    },
                    set: function set(num) {
                        var rect = this._base_rect;
                        this._boundingSwell = Number(num);
                        this.rect_flood = [rect[0] - this.boundingSwell, rect[1] - this.boundingSwell, rect[2] - this.boundingSwell, rect[3] - this.boundingSwell, rect[4] - this.boundingSwell, rect[5] - this.boundingSwell, 0, 0, 0];
                        this.floodAnalysis.rect_flood = this.rect_flood;
                    }

                    //显示和隐藏

                }, {
                    key: "show",
                    get: function get() {
                        return this.defaultShow;
                    },
                    set: function set(val) {
                        this.defaultShow = Boolean(val);
                        this._switchShow();
                    }
                }]);

                return HeightCounterByTerrain;
            }();

            /***/
}),
/* 129 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Slope = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _matrix = __webpack_require__(17);

            var _util = __webpack_require__(1);

            var _polygon = __webpack_require__(12);

            var _polyline = __webpack_require__(33);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //坡度坡向 类
            var Slope = exports.Slope = function () {
                function Slope(options) {
                    _classCallCheck(this, Slope);

                    this.options = options;

                    //箭头的显示长度（米）
                    this.options.arrow = this.options.arrow || {};
                    this.options.arrow.scale = Cesium.defaultValue(this.options.arrow.scale, 0.3); //箭头长度的比例
                    this.options.arrow.width = Cesium.defaultValue(this.options.arrow.width, 15); //箭头宽度
                    this.options.arrow.color = Cesium.defaultValue(this.options.arrow.color, Cesium.Color.YELLOW);

                    //point点
                    this.options.point = this.options.point || {};
                    this.options.point.show = Cesium.defaultValue(this.options.point.show, true);
                    this.options.point.pixelSize = Cesium.defaultValue(this.options.point.pixelSize, 9);
                    this.options.point.color = Cesium.defaultValue(this.options.point.color, Cesium.Color.RED.withAlpha(0.5));

                    this.viewer = options.viewer;

                    this.arrowPrimitives = [];
                    this.pointInterPrimitives = new Cesium.PointPrimitiveCollection();
                    this.viewer.scene.primitives.add(this.pointInterPrimitives);
                }

                // 计算  传入Cartesian3 数组 ，贴地坐标


                _createClass(Slope, [{
                    key: 'add',
                    value: function add(arr, options) {
                        if (!arr || arr.length < 1) return;

                        options = options || {};

                        if (arr.length > 2) {
                            //传入面边界时
                            var resultInter = (0, _polygon.interPolygon)({
                                scene: viewer.scene,
                                positions: arr,
                                has3dtiles: false,
                                onlyPoint: true, //true时只返回点，不返回三角网
                                splitNum: Cesium.defaultValue(options.splitNum, 8) //splitNum插值分割的个数
                            });
                            this.arrowLength = Cesium.Math.chordLength(resultInter.granularity, this.viewer.scene.globe.ellipsoid.maximumRadius) * this.options.arrow.scale;

                            arr = [];
                            for (var k = 0; k < resultInter.list.length; k++) {
                                arr.push(resultInter.list[k].pointDM);
                            }
                        } else {
                            this.arrowLength = Cesium.defaultValue(this.options.arrow.length, 40);
                        }

                        this.stateAll = arr.length;
                        this.stateOkIndex = 0;
                        this.instances = [];

                        for (var i = 0; i < this.stateAll; i++) {
                            this._fxOnePoint(arr[i], options);
                        }
                    }

                    //分析单个点的对应坡度

                }, {
                    key: '_fxOnePoint',
                    value: function _fxOnePoint(position, options) {
                        if (!position) return;

                        //返回该点的周边2米圆上的8个点
                        var arcPoint = (0, _polygon.getEllipseOuterPositions)({
                            position: position,
                            radius: Cesium.defaultValue(options.radius, 2), //半径
                            count: Cesium.defaultValue(options.count, 2) //共返回8(count*4)个点
                        });
                        arcPoint.push(position);

                        var ellipsoid = this.viewer.scene.globe.ellipsoid;

                        // 求出点的详细高度
                        var that = this;
                        (0, _polyline.computeSurfacePoints)({
                            viewer: viewer,
                            positions: arcPoint,
                            calback: function calback(raisedPositions, noHeight) {
                                if (noHeight) {
                                    console.log("未获取到高度值，贴地高度计算存在误差");
                                }

                                var cartographicArray = ellipsoid.cartesianArrayToCartographicArray(raisedPositions);

                                // 中心点
                                var center = cartographicArray.pop();

                                // 其余圆上点  
                                var maxIndex = 0;
                                var maxHeight = cartographicArray[0].height;
                                var minIndex = 0;
                                var minHeight = cartographicArray[0].height;
                                for (var i = 1; i < cartographicArray.length - 1; i++) {
                                    var item = cartographicArray[i];
                                    if (item.height > maxHeight) {
                                        maxHeight = item.height;
                                        maxIndex = i;
                                    }
                                    if (item.height < minHeight) {
                                        minHeight = item.height;
                                        minIndex = i;
                                    }
                                }

                                var maxPoint = cartographicArray[maxIndex]; //周边最高点
                                var minPoint = cartographicArray[minIndex]; //周边最低点

                                var slopeVal1 = that.getSlope(center, maxPoint);
                                var slopeVal2 = that.getSlope(center, minPoint);

                                if (slopeVal1 > slopeVal2) {
                                    that._fxOnePointOk(center, maxPoint, slopeVal1);
                                } else {
                                    that._fxOnePointOk(center, minPoint, slopeVal2);
                                }
                            }
                        });
                    }

                    //分析单个点的对应坡度完成后添加显示的箭头等

                }, {
                    key: '_fxOnePointOk',
                    value: function _fxOnePointOk(center, maxPoint, slopeVal) {
                        var centerCar = Cesium.Cartographic.toCartesian(center);
                        var maxPointCar = Cesium.Cartographic.toCartesian(maxPoint);
                        maxPointCar = (0, _matrix.getOnLinePointByLen)(centerCar, maxPointCar, this.arrowLength);

                        // 计算圆上的最高点和中心点的高度 判断箭头方向 
                        var arrArrowPt;
                        if (center.height > maxPoint.height) {
                            //中心点高于四周情况下
                            arrArrowPt = [centerCar, maxPointCar];
                        } else {
                            //边缘指向中心 
                            arrArrowPt = [maxPointCar, centerCar];
                        }

                        // 构建箭头
                        var gs = new Cesium.GeometryInstance({
                            geometry: new Cesium.PolylineGeometry({
                                positions: arrArrowPt,
                                width: this.options.arrow.width
                            }),
                            vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT,
                            id: "polylinedashinstance"
                        });
                        this.instances.push(gs);

                        //求方位角
                        var slopeAngle = (0, _util.getAngle)(arrArrowPt[0], arrArrowPt[1]);

                        var slopeValDou = Number((Math.atan(slopeVal) * 100).toFixed(2));

                        // 度数法 【 α(坡度)=arc tan (高程差/水平距离)】 eg: 45°
                        var text1 = slopeValDou.toFixed(2) + "°";
                        // 百分比法 【 坡度 = (高程差/水平距离)x100%】 eg:30%  
                        var text2 = (slopeVal * 100).toFixed(2) + "%";

                        // 添加点 显示坡度
                        if (this.options.point.show) {
                            var primitive = this.pointInterPrimitives.add({
                                position: centerCar,
                                pixelSize: this.options.point.pixelSize,
                                color: this.options.point.color,
                                outlineWidth: this.options.point.outlineWidth,
                                outlineColor: this.options.point.outlineColor,
                                scaleByDistance: this.options.point.scaleByDistance,
                                disableDepthTestDistance: this.options.point.disableDepthTestDistance
                            });

                            primitive.slope = slopeValDou;
                            primitive.click = this.options.click;
                            primitive.tooltip = '\u5761\u5EA6: ' + text1 + '  (' + text2 + ')<br />\u5761\u5411: ' + slopeAngle + '\xB0'; // 显示结果        
                        }

                        // 全部计算完成 
                        this.stateOkIndex++;
                        if (this.stateOkIndex >= this.stateAll) {
                            var arrowPrimitive = this.viewer.scene.primitives.add(new Cesium.Primitive({
                                geometryInstances: this.instances,
                                appearance: new Cesium.PolylineMaterialAppearance({
                                    material: Cesium.Material.fromType('PolylineArrow', {
                                        color: this.options.arrow.color
                                    })
                                })
                            }));
                            this.arrowPrimitives.push(arrowPrimitive);

                            this.instances = [];
                        }
                    }

                    // 两点之间的坡度

                }, {
                    key: 'getSlope',
                    value: function getSlope(c1, c2) {
                        if (!c1 || !c2) return;
                        var differH = Math.abs(c1.height - c2.height); //高度差
                        var differV = Cesium.Cartesian3.distance(Cesium.Cartographic.toCartesian(c1), Cesium.Cartesian3.fromRadians(c2.longitude, c2.latitude, c1.height)); // 水平距离
                        var value = differH / differV;
                        return value;
                    }

                    // 清除

                }, {
                    key: 'clear',
                    value: function clear() {
                        if (this.pointInterPrimitives) this.pointInterPrimitives.removeAll();

                        for (var i = 0, len = this.arrowPrimitives.length; i < len; i++) {
                            this.viewer.scene.primitives.remove(this.arrowPrimitives[i]);
                        }
                        this.arrowPrimitives = [];
                        this.instances = [];
                        this.stateAll = 0;
                        this.stateOkIndex = 0;
                    }

                    //销毁

                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.clear();

                        delete this.pointInterPrimitives;
                        delete this.arrowPrimitives;
                        delete this.viewer;
                    }
                }]);

                return Slope;
            }();

            /***/
}),
/* 130 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.MixedOcclusion = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var fragmentShaderSource = "\n    uniform sampler2D colorTexture;\n    uniform sampler2D mergeTexture; \n    uniform float alpha;\n    varying vec2 v_textureCoordinates;\n    void main(){\n        vec4 color = texture2D(colorTexture, v_textureCoordinates);\n        vec4 mergeColor =  texture2D(mergeTexture, v_textureCoordinates);\n        if(length(mergeColor.rgb)>0.01){\n            gl_FragColor = mix(color,mergeColor,alpha);\n        }else{\n            gl_FragColor = color;\n        }\n    } ";

            // 建筑物混合遮挡 
            // 1.楼块不能遮挡道路、水系、绿地和标注等地图元素；
            // 2.楼快之间，需要实现不透明的实际遮挡效果。

            //原理：自己创建FBO，把收集到的所有瓦片绘制指令，都绘制到这个FBO里，开启深度检测，然后再贴屏

            var MixedOcclusion = exports.MixedOcclusion = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function MixedOcclusion(viewer, options) {
                    _classCallCheck(this, MixedOcclusion);

                    this.viewer = viewer;
                    options = options || {};

                    this._enabled = Cesium.defaultValue(options.enabled, true);
                    this._alpha = Cesium.defaultValue(options.alpha, 0.5);

                    this.init();
                }

                //========== 对外属性 ==========  
                //透明度


                _createClass(MixedOcclusion, [{
                    key: "init",


                    //========== 方法 ========== 

                    value: function init() {
                        var context = this.viewer.scene.context;
                        var width = this.viewer.scene.drawingBufferWidth;
                        var height = this.viewer.scene.drawingBufferHeight;

                        this.width = width;
                        this.height = height;

                        this.tt = new Cesium.Texture({
                            context: context,
                            width: width,
                            height: height,
                            pixelFormat: Cesium.PixelFormat.RGBA,
                            pixelDatatype: Cesium.PixelDatatype.FLOAT,
                            sampler: new Cesium.Sampler({
                                wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                                magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                            })
                        });

                        this.depthStencilTexture = new Cesium.Texture({
                            context: context,
                            width: width,
                            height: height,
                            pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
                        });

                        Cesium.ExpandByMapV.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
                            context: context,
                            colorTextures: [this.tt],
                            depthStencilTexture: this.depthStencilTexture,
                            destroyAttachments: false
                        });

                        Cesium.ExpandByMapV.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
                            color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                            framebuffer: Cesium.ExpandByMapV.mixedOcclusion.tilesFbo,
                            depth: 2.0,
                            stencil: 2.0
                        });

                        this.viewer.scene._preUpdate.addEventListener(this._preUpdateHandler, this);
                        this.setEnabled(this._enabled);
                    }
                }, {
                    key: "_preUpdateHandler",
                    value: function _preUpdateHandler(e) {
                        Cesium.ExpandByMapV.mixedOcclusion.newFrame = true;

                        var newWidth = this.viewer.scene.drawingBufferWidth;
                        var newHeight = this.viewer.scene.drawingBufferHeight;
                        if (newWidth != this.width || newHeight != this.height) {
                            var context = this.viewer.scene.context;
                            var width = newWidth;
                            var height = newHeight;

                            this.width = width;
                            this.height = height;

                            this.DepthTexture && this.DepthTexture.destroy();
                            this.depthStencilTexture && this.depthStencilTexture.destroy();
                            this.tt && this.tt.destroy();
                            Cesium.ExpandByMapV.mixedOcclusion.tilesFbo && Cesium.ExpandByMapV.mixedOcclusion.tilesFbo.destroy();

                            this.tt = new Cesium.Texture({
                                context: context,
                                width: width,
                                height: height,
                                pixelFormat: Cesium.PixelFormat.RGBA,
                                pixelDatatype: Cesium.PixelDatatype.FLOAT,
                                sampler: new Cesium.Sampler({
                                    wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                    wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                    minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                                    magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                                })
                            });

                            this.depthStencilTexture = new Cesium.Texture({
                                context: context,
                                width: width,
                                height: height,
                                pixelFormat: Cesium.PixelFormat.DEPTH_STENCIL,
                                pixelDatatype: Cesium.PixelDatatype.UNSIGNED_INT_24_8
                            });

                            this.DepthTexture = new Cesium.Texture({
                                context: context,
                                width: width,
                                height: height,
                                pixelFormat: Cesium.PixelFormat.RGBA,
                                pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE,
                                sampler: new Cesium.Sampler({
                                    wrapS: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                    wrapT: Cesium.TextureWrap.CLAMP_TO_EDGE,
                                    minificationFilter: Cesium.TextureMinificationFilter.NEAREST,
                                    magnificationFilter: Cesium.TextureMagnificationFilter.NEAREST
                                })
                            });

                            Cesium.ExpandByMapV.mixedOcclusion.tilesFbo = new Cesium.Framebuffer({
                                context: context,
                                colorTextures: [this.tt],
                                depthStencilTexture: this.depthStencilTexture,
                                destroyAttachments: false
                            });
                            Cesium.ExpandByMapV.mixedOcclusion.tilesFboClear = new Cesium.ClearCommand({
                                color: new Cesium.Color(0.0, 0.0, 0.0, 0.0),
                                framebuffer: Cesium.ExpandByMapV.mixedOcclusion.tilesFbo,
                                depth: 2.0,
                                stencil: 2.0
                            });
                        }
                    }
                }, {
                    key: "setEnabled",
                    value: function setEnabled(val) {
                        var that = this;

                        Cesium.ExpandByMapV.mixedOcclusion.enable = val;

                        if (val) {
                            this.postProcess = new Cesium.PostProcessStage({
                                fragmentShader: fragmentShaderSource,
                                uniforms: {
                                    mergeTexture: function mergeTexture() {
                                        return Cesium.ExpandByMapV.mixedOcclusion.tilesFbo._colorTextures[0];
                                    },
                                    alpha: function alpha() {
                                        return that._alpha;
                                    }
                                }
                            });
                            this.viewer.scene.postProcessStages.add(this.postProcess);
                        } else {
                            Cesium.ExpandByMapV.mixedOcclusion.tilesFboClear.execute(this.viewer.scene.context);
                            if (this.postProcess) this.viewer.scene.postProcessStages.remove(this.postProcess);
                        }
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.setEnabled(false);
                        this.viewer.scene._preUpdate.removeEventListener(this._preUpdateHandler, this);

                        delete this.postProcess;

                        if (this.DepthTexture) {
                            this.DepthTexture.destroy();
                            delete this.DepthTexture;
                        }
                        if (this.depthStencilTexture) {
                            this.depthStencilTexture.destroy();
                            delete this.depthStencilTexture;
                        }
                        if (this.tt) {
                            this.tt.destroy();
                            delete this.tt;
                        }
                    }
                }, {
                    key: "alpha",
                    get: function get() {
                        return this._alpha;
                    },
                    set: function set(val) {
                        this._alpha = val;
                    }

                    //开启关闭

                }, {
                    key: "enabled",
                    get: function get() {
                        return this._enabled;
                    },
                    set: function set(val) {
                        this._enabled = val;
                        this.setEnabled(val);
                    }
                }]);

                return MixedOcclusion;
            }();

            /***/
}),
/* 131 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesEditor = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //  移动位置、旋转 3dtiles
            var TilesEditor = exports.TilesEditor = function () {
                //========== 构造方法 ========== 
                function TilesEditor(viewer, options) {
                    _classCallCheck(this, TilesEditor);

                    //必须的参数
                    this.viewer = viewer;
                    this.scene = this.viewer.scene;

                    this.options = options;
                    this.position = options.position;
                    this.heading = options.heading || 0;
                    this.range = options.range || 100;

                    this.dragging = false;
                    this.rotating = false;
                    this.enable = false;

                    this.billboards = this.viewer.scene.primitives.add(new Cesium.BillboardCollection());
                    this.handler = new Cesium.ScreenSpaceEventHandler(this.viewer.canvas);

                    //用来平移位置的指示器
                    this.movep = this.billboards.add({
                        position: this.position,
                        color: new Cesium.Color.fromCssColorString("#FFFF00"),
                        image: options.moveImg,
                        show: false,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY
                    });
                    //用来旋转的指示器
                    this.rotatep = this.billboards.add({
                        position: this.position ? this.rotationPos() : null,
                        color: new Cesium.Color.fromCssColorString("#FFFF00"),
                        image: options.rotateImg,
                        show: false,
                        disableDepthTestDistance: Number.POSITIVE_INFINITY
                    });
                }

                //========== 对外属性 ==========  
                // //裁剪距离 
                // get distance() {
                //     return this._distance || 0;
                // }
                // set distance(val) {
                //     this._distance = val; 
                // }

                //========== 方法 ========== 

                _createClass(TilesEditor, [{
                    key: "update",
                    value: function update(opts) {
                        for (var key in opts) {
                            this[key] = opts[key];
                        }

                        this.movep.position = this.position;
                        this.rotatep.position = this.rotationPos();
                    }

                    //获取当前矩阵

                }, {
                    key: "modelMatrix",
                    value: function modelMatrix() {
                        var mat = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);
                        var rotationX = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromRotationZ(this.heading));
                        Cesium.Matrix4.multiply(mat, rotationX, mat);

                        //比例变换
                        if (this.scale > 0 && this.scale != 1) Cesium.Matrix4.multiplyByUniformScale(mat, this.scale, mat);

                        //垂直轴变换
                        if (this.axis && this.axis != "") {
                            var rightaxis;
                            switch (this.axis.toUpperCase()) {
                                case "Y_UP_TO_Z_UP":
                                    rightaxis = Cesium.Axis.Y_UP_TO_Z_UP;
                                    break;
                                case "Z_UP_TO_Y_UP":
                                    rightaxis = Cesium.Axis.Z_UP_TO_Y_UP;
                                    break;
                                case "X_UP_TO_Z_UP":
                                    rightaxis = Cesium.Axis.X_UP_TO_Z_UP;
                                    break;
                                case "Z_UP_TO_X_UP":
                                    rightaxis = Cesium.Axis.Z_UP_TO_X_UP;
                                    break;
                                case "X_UP_TO_Y_UP":
                                    rightaxis = Cesium.Axis.X_UP_TO_Y_UP;
                                    break;
                                case "Y_UP_TO_X_UP":
                                    rightaxis = Cesium.Axis.Y_UP_TO_X_UP;
                                    break;
                            }
                            if (rightaxis) mat = Cesium.Matrix4.multiplyTransformation(mat, rightaxis, mat);
                        }
                        return mat;
                    }

                    //依据位置和朝向计算 旋转的位置

                }, {
                    key: "rotationPos",
                    value: function rotationPos() {
                        var rotpos = new Cesium.Cartesian3(this.range, 0.0, 0.0);
                        //依据位置和朝向计算 旋转矩阵  
                        var mat = Cesium.Matrix4.getMatrix3(this.modelMatrix(), new Cesium.Matrix3());

                        rotpos = Cesium.Matrix3.multiplyByVector(mat, rotpos, rotpos);
                        rotpos = Cesium.Cartesian3.add(this.position, rotpos, rotpos);
                        return rotpos;
                    }
                }, {
                    key: "pickTerrain",
                    value: function pickTerrain(wndpos) {
                        var ray = this.viewer.camera.getPickRay(wndpos);
                        var pos = this.viewer.scene.globe.pick(ray, this.viewer.scene);
                        return pos;
                    }
                }, {
                    key: "setEnable",
                    value: function setEnable(v) {
                        if (v) {
                            var self = this;
                            this.handler.setInputAction(function (p) {
                                self.handler_onLeafDown(p);
                            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
                            this.handler.setInputAction(function (p) {
                                self.handler_onMouseMove(p);
                            }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                            this.handler.setInputAction(function (p) {
                                self.handler_onLeftUp(p);
                            }, Cesium.ScreenSpaceEventType.LEFT_UP);

                            this.rotatep.show = true;
                            this.movep.show = true;
                        } else {
                            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
                            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                            this.handler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);

                            this.rotatep.show = false;
                            this.movep.show = false;
                        }
                        this._enable = false;
                    }
                }, {
                    key: "handler_onLeafDown",
                    value: function handler_onLeafDown(event) {
                        var pickedObjects = this.scene.drillPick(event.position, 2);

                        for (var i = 0; i < pickedObjects.length; i++) {
                            var pickedObject = pickedObjects[i];

                            if (Cesium.defined(pickedObject) && pickedObject.primitive === this.movep) {
                                this.dragging = true;
                                this.scene.screenSpaceCameraController.enableRotate = false;
                                break;
                            } else if (Cesium.defined(pickedObject) && pickedObject.primitive === this.rotatep) {
                                this.rotating = true;
                                this.scene.screenSpaceCameraController.enableRotate = false;
                                break;
                            }
                        }
                    }
                }, {
                    key: "handler_onMouseMove",
                    value: function handler_onMouseMove(event) {
                        var position = this.pickTerrain(event.endPosition);
                        if (!position) return;

                        if (this.dragging) {
                            this.position = position;
                            this.movep.position = this.position;
                            this.rotatep.position = this.rotationPos();

                            if (this.options.onPosition) {
                                this.options.onPosition(this.position);
                            }
                        } else if (this.rotating) {
                            this.rotatep.position = position;
                            this.range = Cesium.Cartesian3.distance(this.position, position);

                            //获取该位置的默认矩阵 
                            var mat = Cesium.Transforms.eastNorthUpToFixedFrame(this.position);
                            mat = Cesium.Matrix4.getMatrix3(mat, new Cesium.Matrix3());

                            var xaxis = Cesium.Matrix3.getColumn(mat, 0, new Cesium.Cartesian3());
                            var yaxis = Cesium.Matrix3.getColumn(mat, 1, new Cesium.Cartesian3());
                            var zaxis = Cesium.Matrix3.getColumn(mat, 2, new Cesium.Cartesian3());
                            //计算该位置 和  position 的 角度值
                            var dir = Cesium.Cartesian3.subtract(position, this.position, new Cesium.Cartesian3());
                            //z crosss (dirx cross z) 得到在 xy平面的向量
                            dir = Cesium.Cartesian3.cross(dir, zaxis, dir);
                            dir = Cesium.Cartesian3.cross(zaxis, dir, dir);
                            dir = Cesium.Cartesian3.normalize(dir, dir);

                            this.heading = Cesium.Cartesian3.angleBetween(xaxis, dir);

                            var ay = Cesium.Cartesian3.angleBetween(yaxis, dir);
                            if (ay > Math.PI * 0.5) {
                                this.heading = 2 * Math.PI - this.heading;
                            }
                            if (this.options.onHeading) {
                                this.options.onHeading(this.heading);
                            }
                        }
                    }
                }, {
                    key: "handler_onLeftUp",
                    value: function handler_onLeftUp(event) {
                        if (this.dragging || this.rotating) {
                            this.rotating = this.dragging = false;
                            this.scene.screenSpaceCameraController.enableRotate = true;
                            //如果没有这句话 会导致billboards的某些没有刷新，无法再次点击
                            this.billboards._createVertexArray = true;
                        }
                    }
                }, {
                    key: "remove",
                    value: function remove() {
                        //从场景中移除
                        if (this.billboards) {
                            this.scene.primitives.remove(this.billboards);
                            this.billboards = undefined;
                        }
                        this.enable = false;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.remove();
                        this.handler.destroy();
                        this.handler = null;
                        this.viewer = null;
                    }
                }]);

                return TilesEditor;
            }();

            /***/
}),
/* 132 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesClipPlan = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //模型剖切(平面)类
            var TilesClipPlan = exports.TilesClipPlan = function () {
                //========== 构造方法 ========== 
                function TilesClipPlan(tileset, options) {
                    _classCallCheck(this, TilesClipPlan);

                    if (tileset instanceof Cesium.Cesium3DTileset) {
                        this._tileset = tileset;
                    } else {
                        this._tileset = tileset.tileset;
                        options = tileset;
                    }

                    this.options = options || {};

                    if (this.options.type) {
                        this.type = this.options.type;
                    }
                    if (this.options.positions) {
                        this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);
                        this.positions = this.options.positions;
                    }
                    if (this.options.distance) {
                        this.distance = this.options.distance;
                    }
                }

                //========== 对外属性 ========== 


                _createClass(TilesClipPlan, [{
                    key: "clipByType",


                    //========== 方法 ========== 


                    //根据类型 创建裁剪面
                    value: function clipByType(type, opts) {
                        //裁剪面
                        var planes;
                        switch (type) {
                            case TilesClipPlan.Type.Z:
                                //水平切底部 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, 1), 1)];
                                break;
                            case TilesClipPlan.Type.ZR:
                                //水平切顶部 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 0, -1), 1)];
                                break;

                            case TilesClipPlan.Type.X:
                                //东西方向切1 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(1, 0, 0), 1)];
                                break;
                            case TilesClipPlan.Type.XR:
                                //东西方向切2 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(-1, 0, 0), 1)];
                                break;

                            case TilesClipPlan.Type.Y:
                                //南北方向切1 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, 1, 0), 1)];
                                break;
                            case TilesClipPlan.Type.YR:
                                //南北方向切2 
                                planes = [new Cesium.ClippingPlane(new Cesium.Cartesian3(0, -1, 0), 1)];
                                break;
                        }

                        this.setPlanes(planes, opts);
                    }

                    //更新裁剪距离

                }, {
                    key: "updateDistance",
                    value: function updateDistance(val) {
                        if (this.clippingPlanes == null) return;

                        for (var i = 0; i < this.clippingPlanes.length; i++) {
                            var plane = this.clippingPlanes.get(i);
                            plane.distance = val;
                        }
                    }

                    //根据坐标 创建裁剪面

                }, {
                    key: "clipByPoints",
                    value: function clipByPoints(points, opts) {
                        opts = opts || {};
                        opts.unionClippingRegions = Cesium.defaultValue(opts.unionClippingRegions, false); //true时外切


                        if (points.length < 2) return;

                        var planes = [];
                        if (points.length == 2) {
                            //线
                            planes = [this._createPlaneByLine(points[0], points[1])];
                        } else {
                            //面

                            //是否顺时针 
                            var startAngle = (0, _util.getAngle)(points[0], points[1]);
                            var endAngle = (0, _util.getAngle)(points[0], points[2]);
                            var direction = startAngle < endAngle;
                            if (opts.unionClippingRegions) direction = !direction;

                            var plan;
                            for (var i = 0, len = points.length; i < len; ++i) {
                                var nextIndex = (i + 1) % len;

                                if (direction) plan = this._createPlaneByLine(points[nextIndex], points[i]); else plan = this._createPlaneByLine(points[i], points[nextIndex]);

                                planes.push(plan);
                            }
                        }

                        this.setPlanes(planes, opts);
                    }
                }, {
                    key: "_createPlaneByLine",
                    value: function _createPlaneByLine(p1, p2) {
                        // 将仅包含经纬度信息的p1,p2，转换为相应坐标系的cartesian3对象
                        var p1C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p1, new Cesium.Cartesian3(0, 0, 0));
                        var p2C3 = Cesium.Matrix4.multiplyByPoint(this.inverseTransform, p2, new Cesium.Cartesian3(0, 0, 0));

                        // 定义一个垂直向上的向量up
                        var up = new Cesium.Cartesian3(0, 0, 10);
                        //  right 实际上就是由p1指向p2的向量
                        var right = Cesium.Cartesian3.subtract(p2C3, p1C3, new Cesium.Cartesian3());

                        // 计算normal， right叉乘up，得到平面法向量，这个法向量指向right的右侧
                        var normal = Cesium.Cartesian3.cross(right, up, new Cesium.Cartesian3());
                        normal = Cesium.Cartesian3.normalize(normal, normal);

                        //由于已经获得了法向量和过平面的一点，因此可以直接构造Plane,并进一步构造ClippingPlane
                        var planeTmp = Cesium.Plane.fromPointNormal(p1C3, normal);
                        return Cesium.ClippingPlane.fromPlane(planeTmp);
                    }
                }, {
                    key: "getInverseTransform",
                    value: function getInverseTransform() {
                        if (!this._inverseTransform) {
                            var transform = void 0;
                            var tmp = this._tileset.root.transform;
                            if (tmp && tmp.equals(Cesium.Matrix4.IDENTITY) || !tmp) {
                                // 如果root.transform不存在，则3DTiles的原点变成了boundingSphere.center
                                transform = Cesium.Transforms.eastNorthUpToFixedFrame(this._tileset.boundingSphere.center);
                            } else {
                                transform = Cesium.Matrix4.fromArray(this._tileset.root.transform);
                            }
                            this._inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
                        }
                        return this._inverseTransform;
                    }
                }, {
                    key: "setPlanes",
                    value: function setPlanes(planes, opts) {
                        opts = opts || {};

                        this.clear();
                        if (!planes) return;

                        var clippingPlanes = new Cesium.ClippingPlaneCollection({
                            // modelMatrix : Cesium.Transforms.eastNorthUpToFixedFrame(position),
                            planes: planes,
                            edgeWidth: Cesium.defaultValue(opts.edgeWidth, 0.0),
                            edgeColor: Cesium.defaultValue(opts.edgeColor, Cesium.Color.WHITE),
                            unionClippingRegions: Cesium.defaultValue(opts.unionClippingRegions, false)
                        });
                        this.clippingPlanes = clippingPlanes;
                        this._tileset.clippingPlanes = clippingPlanes;
                    }

                    //清除裁剪面

                }, {
                    key: "clear",
                    value: function clear() {
                        if (this._tileset.clippingPlanes) {
                            this._tileset.clippingPlanes.enabled = false;
                            // this._tileset.clippingPlanes = undefined;
                        }

                        if (this.clippingPlanes) {
                            this.clippingPlanes.destroy();
                            delete this.clippingPlanes;
                        }
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.clear();
                        this._inverseTransform = null;

                        delete this._tileset;
                    }
                }, {
                    key: "tileset",
                    get: function get() {
                        return this._tileset;
                    },
                    set: function set(val) {
                        this._tileset = val;
                        this._inverseTransform = null;
                    }

                    //裁剪面

                }, {
                    key: "planes",
                    get: function get() {
                        return this.clippingPlanes;
                    }
                }, {
                    key: "inverseTransform",
                    get: function get() {
                        return this.getInverseTransform();
                    }

                    //裁剪距离 

                }, {
                    key: "distance",
                    get: function get() {
                        return this._distance || 0;
                    },
                    set: function set(val) {
                        this._distance = val;
                        this.updateDistance(val);
                    }

                    //裁剪类型

                }, {
                    key: "type",
                    get: function get() {
                        return this._type;
                    },
                    set: function set(val) {
                        this._type = val;

                        this.clipByType(val);
                    }

                    //裁剪类型

                }, {
                    key: "positions",
                    get: function get() {
                        return this._positions;
                    },
                    set: function set(val) {
                        this._positions = val;

                        this.clipByPoints(val, { unionClippingRegions: this._clipOutSide });
                    }
                }]);

                return TilesClipPlan;
            }();

            /**
            * 裁剪模型 类型 枚举
            *@enum {Number}
            */


            TilesClipPlan.Type = {
                /** z水平面,水平切底部 */
                Z: 1,
                /** z水平面，水平切顶部 */
                ZR: 2,
                /** x垂直面,水平切底部 */
                X: 3,
                /** x垂直面,东西方向切 */
                XR: 4,
                /** y垂直面, 南北方向切 */
                Y: 5,
                /** y垂直面，南北方向切*/
                YR: 6
            };

            /***/
}),
/* 133 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesClip = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _TilesBase2 = __webpack_require__(42);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            // 模型裁剪 类
            var TilesClip = exports.TilesClip = function (_TilesBase) {
                _inherits(TilesClip, _TilesBase);

                //========== 构造方法 ========== 
                function TilesClip(options) {
                    _classCallCheck(this, TilesClip);

                    var _this = _possibleConstructorReturn(this, (TilesClip.__proto__ || Object.getPrototypeOf(TilesClip)).call(this, options));

                    if (!_this.viewer) return _possibleConstructorReturn(_this);

                    _this._clipOutSide = Cesium.defaultValue(options.clipOutSide, false);

                    if (_this.drawCommand) {
                        _this.activeEdit();
                    }
                    return _this;
                }

                //========== 对外属性 ==========  

                _createClass(TilesClip, [{
                    key: "activeEdit",
                    value: function activeEdit() {
                        this.tileset.mapvEditor.fbo = this.fbo;
                        this.tileset.mapvEditor.polygonBounds = this.polygonBounds;
                        this.tileset.mapvEditor.IsYaPing[0] = true;
                        this.tileset.mapvEditor.IsYaPing[2] = true;
                        this.tileset.mapvEditor.editVar[0] = this.clipOutSide;
                        this.viewer.scene.primitives.add(this);
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.primitives.remove(this);
                        _get(TilesClip.prototype.__proto__ || Object.getPrototypeOf(TilesClip.prototype), "destroy", this).call(this);
                        delete this.clipOutSide;
                        delete this.viewer;
                    }
                }, {
                    key: "clipOutSide",
                    get: function get() {
                        return this._clipOutSide;
                    },
                    set: function set(val) {
                        this._clipOutSide = Boolean(val);
                        this.tileset.mapvEditor.editVar[0] = this.clipOutSide;
                    }
                }]);

                return TilesClip;
            }(_TilesBase2.TilesBase);

            /***/
}),
/* 134 */
/***/ (function (module, exports) {

            module.exports = "uniform mat4 myPorjection;\r\nattribute vec3 position;\r\nvarying vec2 depth;\r\nvoid main()\r\n{\r\nvec4 pos = vec4(position.xyz,1.0);\r\ndepth = pos.zw;\r\npos.z = 0.0;\r\ngl_Position = czm_projection*pos;\r\n}"

            /***/
}),
/* 135 */
/***/ (function (module, exports) {

            module.exports = "#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\n#define OES_texture_float_linear\r\n\r\nvarying vec2 depth;\r\n\r\nvec4 packDepth(float depth)\r\n{\r\n    vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * depth;\r\n    enc = fract(enc);\r\n    enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\r\n    return enc;\r\n}\r\n\r\nvoid main()\r\n{\r\n    float fDepth = (depth.x / 5000.0)/2.0 + 0.5;\r\n    gl_FragColor = packDepth(fDepth);\r\n}"

            /***/
}),
/* 136 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesFlat = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _TilesBase2 = __webpack_require__(42);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            //默认压平至所选取的最低点高度，由flatHeight变量控制压平高度的变化
            // 模型压平 类
            var TilesFlat = exports.TilesFlat = function (_TilesBase) {
                _inherits(TilesFlat, _TilesBase);

                //========== 构造方法 ========== 
                function TilesFlat(options) {
                    _classCallCheck(this, TilesFlat);

                    var _this = _possibleConstructorReturn(this, (TilesFlat.__proto__ || Object.getPrototypeOf(TilesFlat)).call(this, options));

                    if (!_this.viewer) return _possibleConstructorReturn(_this);
                    _this._b3dmOffset = options.b3dmOffset || new Cesium.Cartesian2();
                    _this._flatHeight = options.flatHeight || 0;
                    if (_this.drawCommand) {
                        _this.activeEdit();
                    }
                    return _this;
                }

                //========== 对外属性 ==========  

                //偏移量


                _createClass(TilesFlat, [{
                    key: "activeEdit",
                    value: function activeEdit() {
                        this.tileset.mapvEditor.fbo = this.fbo;
                        this.tileset.mapvEditor.polygonBounds = this.polygonBounds;
                        this.tileset.mapvEditor.IsYaPing[0] = true;
                        this.tileset.mapvEditor.IsYaPing[1] = true;
                        this.tileset.mapvEditor.heightVar[0] = this.minLocalPos.z;
                        this.tileset.mapvEditor.heightVar[1] = this.flatHeight;
                        this.viewer.scene.primitives.add(this);
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.primitives.remove(this);
                        _get(TilesFlat.prototype.__proto__ || Object.getPrototypeOf(TilesFlat.prototype), "destroy", this).call(this);
                        delete this.viewer;
                        delete this.flatHeight;
                        delete this._flatHeight;
                    }
                }, {
                    key: "flatHeight",
                    get: function get() {
                        return this._flatHeight;
                    },
                    set: function set(val) {
                        this._flatHeight = Number(val);
                        this.tileset.mapvEditor.heightVar[1] = this._flatHeight;
                    }
                }]);

                return TilesFlat;
            }(_TilesBase2.TilesBase);

            /***/
}),
/* 137 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TilesFlood = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _TilesBase2 = __webpack_require__(42);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            // 模型淹没 类
            var TilesFlood = exports.TilesFlood = function (_TilesBase) {
                _inherits(TilesFlood, _TilesBase);

                //========== 构造方法 ========== 
                function TilesFlood(options) {
                    _classCallCheck(this, TilesFlood);

                    var _this = _possibleConstructorReturn(this, (TilesFlood.__proto__ || Object.getPrototypeOf(TilesFlood)).call(this, options));

                    _this.floodColor = options.floodColor || [0.15, 0.7, 0.95, 0.5];
                    _this.floodSpeed = options.floodSpeed || 5.5; //淹没速度，米/秒（默认刷新频率为55Hz）
                    _this._floodAll = options.floodAll;
                    _this.maxFloodDepth = options.maxFloodDepth || 200;
                    _this.ableFlood = true;
                    if (_this.drawCommand || _this._floodAll) {
                        _this.activeEdit();
                    }
                    return _this;
                }

                //========== 对外属性 ==========  

                _createClass(TilesFlood, [{
                    key: "bindSpeed",
                    value: function bindSpeed() {
                        var that = this;
                        this.speedFun = function () {
                            if (that.ableFlood) {
                                that.tileset.mapvEditor.floodVar[1] += that.floodSpeed / 55;
                                if (that.tileset.mapvEditor.floodVar[1] >= that.tileset.mapvEditor.floodVar[2]) {
                                    that.tileset.mapvEditor.floodVar[1] = that.tileset.mapvEditor.floodVar[2];
                                }
                            }
                        };
                        this.viewer.clock.onTick.addEventListener(this.speedFun);
                    }
                }, {
                    key: "resetFlood",
                    value: function resetFlood() {
                        this.tileset.mapvEditor.floodVar[1] = this.tileset.mapvEditor.floodVar[0];
                    }
                }, {
                    key: "activeEdit",
                    value: function activeEdit() {
                        this.bindSpeed();
                        this.tileset.mapvEditor.fbo = this.fbo;
                        this.tileset.mapvEditor.polygonBounds = this.polygonBounds;
                        this.tileset.mapvEditor.IsYaPing[0] = true;
                        this.tileset.mapvEditor.IsYaPing[3] = true;
                        this.tileset.mapvEditor.floodVar = [this.minLocalPos.z, this.minLocalPos.z, this.minLocalPos.z + this.maxFloodDepth, 200];
                        this.tileset.mapvEditor.floodColor = this.floodColor;
                        this.tileset.mapvEditor.editVar[1] = this.floodAll || false;
                        !this.floodAll && this.viewer.scene.primitives.add(this);
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.clock.onTick.removeEventListener(this.speedFun);
                        this.viewer.scene.primitives.remove(this);
                        _get(TilesFlood.prototype.__proto__ || Object.getPrototypeOf(TilesFlood.prototype), "destroy", this).call(this);
                        delete this.viewer;
                        delete this.floodColor;
                        delete this.floodSpeed;
                        delete this.ableFlood;
                        delete this.speedFun;
                        delete this.floodAll;
                        delete this.maxFloodDepth;
                    }
                }, {
                    key: "floodAll",
                    get: function get() {
                        return this._floodAll;
                    },
                    set: function set(val) {
                        this._floodAll = Boolean(val);
                        this.tileset.mapvEditor.editVar[1] = this.floodAll;
                    }
                }]);

                return TilesFlood;
            }(_TilesBase2.TilesBase);

            /***/
}),
/* 138 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FlyLine = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _point = __webpack_require__(2);

            var _pointconvert = __webpack_require__(3);

            var _polyline = __webpack_require__(33);

            var _matrix = __webpack_require__(17);

            var _index = __webpack_require__(26);

            var drawAttr = _interopRequireWildcard(_index);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var matrix4 = new Cesium.Matrix4();

            var matrix3Scratch = new Cesium.Matrix3();
            var positionScratch = new Cesium.Cartesian3();
            var orientationScratch = new Cesium.Quaternion();

            //参数默认值
            var defVal = {
                "model": { "show": false, "scale": 1, "minimumPixelSize": 50 },
                "label": { "show": false, "color": "#ffffff", "opacity": 1, "font_family": "楷体", "font_size": 20, "border": true, "border_color": "#000000", "border_width": 3, "background": false, "hasPixelOffset": true, "pixelOffsetX": 30, "pixelOffsetY": -30, "scaleByDistance": true, "scaleByDistance_far": 10000000, "scaleByDistance_farValue": 0.4, "scaleByDistance_near": 100000, "scaleByDistance_nearValue": 1 },
                "path": { "show": false, "lineType": "solid", "color": "#3388ff", "opacity": 0.5, "width": 1, "outline": false, "outlineColor": "#ffffff", "outlineWidth": 2 },
                "shadow": { "show": false, "color": "#00ff00", "outline": false, "opacity": 0.3 },
                "camera": { "type": "gs", "followedX": 50, "followedZ": 10 },
                "showGroundHeight": false
            };

            //飞行路线管理类

            var FlyLine = exports.FlyLine = function () {
                //========== 构造方法 ========== 
                function FlyLine(viewer, options) {
                    _classCallCheck(this, FlyLine);

                    this.viewer = viewer;

                    this.id = options.id || 0;
                    this.name = options.name || "";
                    this.points = options.points; //坐标
                    this.speeds = options.speed;

                    //未传入时的属性取默认值的
                    for (var key in defVal) {
                        var val = defVal[key];

                        if (options.hasOwnProperty(key) && _typeof(options[key]) === 'object') {
                            for (var key2 in val) {
                                if (!options[key].hasOwnProperty(key2)) options[key][key2] = val[key2];
                            }
                        } else {
                            options[key] = val;
                        }
                    }
                    this.options = options; //属性

                    //参考系
                    this._fixedFrameTransform = Cesium.defaultValue(this.options.fixedFrameTransform, Cesium.Transforms.eastNorthUpToFixedFrame);

                    this._isStart = false;

                    this._createLine();
                }

                //========== 对外属性 ==========  
                //提示框


                _createClass(FlyLine, [{
                    key: "_createLine",


                    //========== 方法 ==========  
                    value: function _createLine() {
                        //=====================计算飞行时间及坐标====================
                        var property = new Cesium.SampledPositionProperty();
                        var startTime = this.viewer.clock.currentTime; //飞行开始时间
                        var stopTime; //飞行结束时间 

                        var lonlats = this.points;
                        if (lonlats.length < 2) {
                            console.log('路线无坐标数据，无法漫游！');
                            return;
                        }

                        var speeds = this.speeds;
                        var isSpeedArray = !(0, _util.isNumber)(speeds);
                        if (lonlats.length == 2) {
                            //2个点时，需要插值，否则穿地  
                            var centerPt = [(lonlats[0][0] + lonlats[1][0]) / 2, (lonlats[0][1] + lonlats[1][1]) / 2, lonlats[0][2]];
                            lonlats.splice(1, 0, centerPt);
                            if (speeds && isSpeedArray) speeds.splice(1, 0, speeds[0]);
                        }
                        var defSpeed = 100; //无速度值时的 默认速度  单位：千米/小时
                        var speedsNew = [];

                        var alltimes = 0; //总时长,单位：秒
                        var alllen = 0; //总长度,单位：米
                        var stepLen = {}; //每一步的距离长度

                        var lastPoint;
                        var arrLinePoint = [];
                        for (var i = 0, length = lonlats.length; i < length; i++) {
                            var lonlat = lonlats[i];
                            var item = Cesium.Cartesian3.fromDegrees(lonlat[0], lonlat[1], lonlat[2] || 0);
                            item.lonlat = lonlat;

                            if (i == 0) {
                                //起点
                                var sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
                                item.time = sTime;
                                item.second = alltimes;
                                property.addSample(sTime, item);
                            } else {
                                var speed = isSpeedArray ? speeds ? speeds[i - 1] : defSpeed : speeds || defSpeed;
                                speedsNew.push(speed);
                                var len = Cesium.Cartesian3.distance(item, lastPoint);
                                var stepTime = Math.round(len / speed * 3.6);
                                if (stepTime < 0.5) stepTime = 0.5; //限定为最小值，防止速度值设置太大时，为0.5
                                alltimes += stepTime;
                                alllen += len;

                                var sTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());
                                item.time = sTime;
                                item.second = alltimes;
                                property.addSample(sTime, item);
                            }
                            lastPoint = item;
                            arrLinePoint.push(item);

                            stepLen[i] = alllen;
                        }
                        this.speeds = speedsNew;

                        this.arrLinePoint = arrLinePoint;
                        stopTime = Cesium.JulianDate.addSeconds(startTime, alltimes, new Cesium.JulianDate());

                        this.alltimes = alltimes;
                        this.alllen = alllen;
                        this.stepLen = stepLen;

                        this.startTime = startTime;
                        this.stopTime = stopTime;
                        this.property = property;

                        //插值，使折线边平滑 ,并且长距离下不穿地
                        if (this.options.interpolation) {
                            this.property.setInterpolationOptions({
                                interpolationDegree: this.options.interpolationDegree || 2,
                                interpolationAlgorithm: Cesium.LagrangePolynomialApproximation //HermitePolynomialApproximation
                            });
                        }
                    }
                }, {
                    key: "_createEntity",
                    value: function _createEntity() {
                        this.options.label.text = this.name;

                        var modelAttr = drawAttr.model.style2Entity(this.options.model);
                        var labelAttr = drawAttr.label.style2Entity(this.options.label);
                        var pathAttr = drawAttr.polyline.style2Entity(this.options.path, {});
                        if (!pathAttr.isAll) {
                            pathAttr.leadTime = 0; //只显示飞过的路线 
                            pathAttr.trailTime = this.alltimes * 10;
                        }

                        var velocityOrientation = new Cesium.VelocityOrientationProperty(this.property); //基于移动位置自动计算方位
                        this.velocityOrientation = velocityOrientation;

                        if (this.entity) {
                            this.viewer.entities.remove(this.entity);
                            delete this.entity;
                        }
                        this.entity = this.viewer.entities.add({
                            // id: this.id,
                            availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
                                start: this.startTime,
                                stop: this.stopTime
                            })]),
                            position: this.property,
                            orientation: velocityOrientation,
                            model: modelAttr,
                            label: labelAttr,
                            path: pathAttr,
                            point: { //必须有对象，否则viewer.trackedEntity无法跟随(无model时使用)
                                show: !modelAttr.show,
                                color: new Cesium.Color.fromCssColorString('#ffffff').withAlpha(0.01),
                                pixelSize: 1
                            },
                            popup: this._popup
                        });
                    }

                    //计算贴地线

                }, {
                    key: "clampToGround",
                    value: function clampToGround(onEnd, opts) {
                        opts = opts || {};
                        var that = this;
                        var lonlats = this.points;
                        var speeds = this.speeds;

                        var viewer = this.viewer;

                        var index = 0;
                        var lonlatsNew = [];
                        var speedsNew = [];

                        function getLineFD() {
                            index++;

                            var itemLast = Cesium.Cartesian3.fromDegrees(lonlats[index - 1][0], lonlats[index - 1][1], lonlats[index - 1][2] || 0);
                            var item = Cesium.Cartesian3.fromDegrees(lonlats[index][0], lonlats[index][1], lonlats[index][2] || 0);

                            var speed = speeds[index - 1];

                            var arr = [itemLast, item];
                            (0, _polyline.computeSurfaceLine)({
                                viewer: viewer,
                                positions: arr,
                                has3dtiles: opts.has3dtiles,
                                splitNum: opts.splitNum,
                                offset: opts.offset,
                                calback: function calback(raisedPositions, noHeight) {

                                    if (noHeight) {
                                        if (index == 1) lonlatsNew.push(lonlats[0]);
                                        lonlatsNew.push(lonlats[index]);
                                        speedsNew.push(speed);
                                    } else {
                                        for (var i = 0; i < raisedPositions.length; i++) {
                                            var position = raisedPositions[i];
                                            var carto = Cesium.Cartographic.fromCartesian(position);

                                            lonlatsNew.push([Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude), carto.height]);
                                            speedsNew.push(speed);
                                        }
                                    }

                                    if (index >= lonlats.length - 1) {
                                        that.points = lonlatsNew;
                                        that.speeds = speedsNew;

                                        that._createLine();

                                        if (onEnd) {
                                            onEnd({
                                                lonlats: lonlatsNew,
                                                speeds: speedsNew
                                            });
                                        }
                                    } else {
                                        getLineFD();
                                    }
                                }
                            });
                        }
                        getLineFD();
                    }
                }, {
                    key: "updateConfig",
                    value: function updateConfig(params) {
                        return this.updateStyle(params);
                    }
                }, {
                    key: "updateStyle",
                    value: function updateStyle(params) {
                        for (var i in params) {
                            if (_typeof(params[i]) === 'object' && this.options[i]) {
                                for (var key2 in params[i]) {
                                    this.options[i][key2] = params[i][key2];
                                }
                            } else {
                                this.options[i] = params[i];
                            }
                        }
                    }
                }, {
                    key: "updateAngle",
                    value: function updateAngle(isAuto, opts) {
                        if (isAuto) {
                            this.entity.orientation = this.velocityOrientation; //基于移动位置自动计算方位
                        } else {
                            opts = opts || {};

                            var position = this.position; //当前点 
                            var _orientation = this.orientation; //获取当前角度  
                            if (!position || !_orientation) return null;

                            var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);

                            //重新赋值新角度
                            var heading = autoHpr.heading;
                            var pitch = Cesium.Math.toRadians(Number(opts.pitch || 0.0));
                            var roll = Cesium.Math.toRadians(Number(opts.roll || 0.0));

                            this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(position, new Cesium.HeadingPitchRoll(heading, pitch, roll), this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
                        }
                    }
                }, {
                    key: "start",
                    value: function start(endfun) {
                        if (!Cesium.defined(this.arrLinePoint) || this.arrLinePoint.length == 0) {
                            console.log("没有坐标数据，飞行路线启动失败");
                            return;
                        }

                        this.endfun = endfun;

                        if (this._isStart) this.stop();
                        this._isStart = true;

                        this._createEntity();

                        //=====================绑定clock timeline====================  
                        this._bak_multiplier = this.viewer.clock.multiplier;
                        this.viewer.clock.multiplier = this.options.multiplier || 1; //飞行速度 
                        this.viewer.clock.shouldAnimate = true;

                        this.viewer.clock.currentTime = this.startTime.clone();

                        if (this.options.clockLoop) {
                            //循环播放
                            this._bak_clockRange = this.viewer.clock.clockRange;
                            this._bak_startTime = this.viewer.clock.startTime;
                            this._bak_stopTime = this.viewer.clock.stopTime;

                            this.viewer.clock.clockRange = Cesium.ClockRange.LOOP_STOP; //到达终止时间后循环     
                            this.viewer.clock.startTime = this.startTime.clone();
                            this.viewer.clock.stopTime = this.stopTime.clone();

                            if (this.viewer.timeline) this.viewer.timeline.zoomTo(this.startTime, this.stopTime);
                        }

                        //投影 
                        if (this.options.shadow.show) {
                            if (this.options.shadow.type == "wall") this.addWallShading(); else if (this.options.shadow.type == "cylinder") this.addCylinderShading();
                        }

                        this._flyok_point_index = 0; //优化查询效率，飞行过的点id

                        this.viewer.scene.preRender.addEventListener(this.preRender_eventHandler, this);
                    }

                    //实时监控事件

                }, {
                    key: "preRender_eventHandler",
                    value: function preRender_eventHandler(e) {
                        if (!this._isStart || this.entity == null) return;

                        if (Cesium.JulianDate.greaterThanOrEquals(this.viewer.clock.currentTime, this.stopTime)) {
                            this._flyok_point_index = this.arrLinePoint.length - 1;

                            if (this.endfun) this.endfun();
                            this.endfun = null;
                        }

                        //当前点
                        var _position = this.position;
                        if (Cesium.defined(_position)) {
                            switch (this.options.camera.type) {//视角处理
                                default:
                                    //无 
                                    if (this.viewer.trackedEntity != undefined) {
                                        this.viewer.trackedEntity = undefined;
                                        this.flyTo(this.options.camera);
                                    }
                                    break;
                                case "gs":
                                    //跟随视角
                                    if (this.viewer.trackedEntity != this.entity) {
                                        this.viewer.trackedEntity = this.entity;
                                        this.flyTo(this.options.camera);
                                    }
                                    break;
                                case "dy":
                                    //锁定第一视角
                                    if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

                                    var matrix = this.getModelMatrix();

                                    var transformX = this.options.camera.followedX; //距离运动点的距离（后方） 
                                    var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
                                    this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-transformX, 0, transformZ));

                                    break;
                                case "sd":
                                    //锁定上帝视角 
                                    if (this.viewer.trackedEntity != this.entity) this.viewer.trackedEntity = this.entity;

                                    var matrix = this.getModelMatrix();

                                    var transformZ = this.options.camera.followedZ; //距离运动点的高度（上方）
                                    this.viewer.scene.camera.lookAtTransform(matrix, new Cesium.Cartesian3(-1, 0, transformZ));
                                    break;
                            }

                            //实时监控
                            this.realTime(_position);
                        }
                    }
                    //获取已飞行完成的点的位置

                }, {
                    key: "getCurrIndex",
                    value: function getCurrIndex() {
                        var lineLength = this.arrLinePoint.length;
                        if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, this.arrLinePoint[0].time) <= 0) {
                            this._flyok_point_index = 0;
                        }
                        if (this._flyok_point_index < 0 || this._flyok_point_index >= lineLength) this._flyok_point_index = 0;

                        for (var i = this._flyok_point_index; i < lineLength; i++) {
                            var item = this.arrLinePoint[i];
                            if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, item.time) <= 0) {
                                return i - 1;
                            }
                        }
                        for (var i = 0; i < lineLength; i++) {
                            var item = this.arrLinePoint[i];
                            if (Cesium.JulianDate.compare(this.viewer.clock.currentTime, item.time) <= 0) {
                                return i - 1;
                            }
                        }
                        return lineLength - 1;
                    }
                }, {
                    key: "realTime",
                    value: function realTime(position) {
                        var time = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.startTime); //已飞行时间
                        var point = (0, _point.formatPosition)(position);

                        this._flyok_point_index = this.getCurrIndex();

                        var lineLength = this.arrLinePoint.length;
                        if (this._flyok_point_index < 0 || this._flyok_point_index >= lineLength) this._flyok_point_index = 0;

                        var thislen = this.stepLen[this._flyok_point_index];

                        var lastPosition = this.arrLinePoint[this._flyok_point_index];
                        if (Cesium.defined(lastPosition)) thislen += Cesium.Cartesian3.distance(position, lastPosition);

                        if (thislen >= this.alllen) {
                            this._flyok_point_index = lineLength - 1;
                            thislen = this.alllen;
                        }

                        // console.log('已飞行过点：' + this._flyok_point_index);

                        this.timeinfo = {
                            time: time, //已飞行时间
                            len: thislen, //已飞行距离
                            x: point.x,
                            y: point.y,
                            z: point.z
                        };

                        if (this.options.shadow.show && this.options.shadow.type == "wall") {
                            //投影 
                            var flyOkPoints = this.arrLinePoint.slice(0, this._flyok_point_index + 1);
                            flyOkPoints.push(position);
                            this.updateWallShading(flyOkPoints);
                        }

                        //求概略的 地面海拔 和 离地高度
                        var carto = Cesium.Cartographic.fromCartesian(position);
                        var heightTerrain = this.viewer.scene.globe.getHeight(carto); //地形高度
                        if (heightTerrain != null && heightTerrain > 0) {
                            this.timeinfo.hbgd = heightTerrain;
                            this.timeinfo.ldgd = point.z - heightTerrain;
                        }

                        //求准确的 地面海拔 和 离地高度 (没有此需求时可以关闭，提高效率)
                        if (this.options.showGroundHeight) {
                            var that = this;
                            (0, _polyline.computeSurfaceLine)({
                                viewer: that.viewer,
                                positions: [position, position],
                                calback: function calback(raisedPositions, noHeight) {
                                    if (raisedPositions == null || raisedPositions.length == 0 || noHeight) {
                                        return;
                                    }

                                    var hbgd = (0, _point.formatPosition)(raisedPositions[0]).z; //地面高程      
                                    var ldgd = point.z - hbgd; //离地高度

                                    this.timeinfo.hbgd = hbgd;
                                    this.timeinfo.ldgd = ldgd;

                                    if (this.entity.label) {
                                        var fxgd_str = (0, _util.formatLength)(this.timeinfo.z);
                                        var ldgd_str = (0, _util.formatLength)(this.timeinfo.ldgd);
                                        this.entity.label.text = this.name + "\n" + "漫游高程：" + fxgd_str + "\n离地距离：" + ldgd_str;
                                    }
                                }
                            });
                        }
                    }

                    //锁定视角计算

                }, {
                    key: "getModelMatrix",
                    value: function getModelMatrix() {
                        var entity = this.entity;
                        var time = this.viewer.clock.currentTime;

                        var position = Cesium.Property.getValueOrUndefined(entity.position, time, positionScratch);
                        if (!Cesium.defined(position)) {
                            return undefined;
                        }
                        var result;
                        var orientation = Cesium.Property.getValueOrUndefined(entity.orientation, time, orientationScratch);
                        if (!Cesium.defined(orientation)) {
                            result = this._fixedFrameTransform(position, undefined, matrix4);
                        } else {
                            result = Cesium.Matrix4.fromRotationTranslation(Cesium.Matrix3.fromQuaternion(orientation, matrix3Scratch), position, matrix4);
                        }
                        return result;
                    }

                    //wall投影

                }, {
                    key: "addWallShading",
                    value: function addWallShading() {
                        this._wall_positions = [];
                        this._wall_minimumHeights = [];
                        this._wall_maximumHeights = [];

                        var that = this;
                        var wallattr = drawAttr.wall.style2Entity(this.options.shadow);
                        wallattr.minimumHeights = new Cesium.CallbackProperty(function (time) {
                            return that._wall_minimumHeights;
                        }, false);
                        wallattr.maximumHeights = new Cesium.CallbackProperty(function (time) {
                            return that._wall_maximumHeights;
                        }, false);
                        wallattr.positions = new Cesium.CallbackProperty(function (time) {
                            return that._wall_positions;
                        }, false);

                        this.wallEntity = this.viewer.entities.add({
                            wall: wallattr
                        });
                    }
                }, {
                    key: "updateWallShading",
                    value: function updateWallShading(positions) {
                        var newposition = [];
                        var minimumHeights = [];
                        var maximumHeights = [];
                        for (var i = 0; i < positions.length; i++) {
                            var point = positions[i].clone();
                            if (!point) continue;

                            newposition.push(point);
                            var carto = Cesium.Cartographic.fromCartesian(point);
                            minimumHeights.push(0);
                            maximumHeights.push(carto.height);
                        }
                        this._wall_positions = newposition;
                        this._wall_minimumHeights = minimumHeights;
                        this._wall_maximumHeights = maximumHeights;
                    }

                    //圆锥 投影

                }, {
                    key: "addCylinderShading",
                    value: function addCylinderShading() {
                        var bottomRadiusNow = 100;
                        var lengthNow = 100;

                        var property = this.property;

                        var wallattr = drawAttr.wall.style2Entity(this.options.shadow); //主要是颜色值等属性
                        wallattr.length = new Cesium.CallbackProperty(function (time) {
                            return lengthNow;
                        }, false);
                        wallattr.topRadius = 0;
                        wallattr.bottomRadius = new Cesium.CallbackProperty(function (time) {
                            return bottomRadiusNow;
                        }, false);
                        wallattr.numberOfVerticalLines = 0;

                        this.cylinderEntity = this.viewer.entities.add({
                            position: new Cesium.CallbackProperty(function (time) {
                                var position = Cesium.Property.getValueOrUndefined(property, time, new Cesium.Cartesian3());
                                var car = Cesium.Cartographic.fromCartesian(position);
                                var newPoint = Cesium.Cartesian3.fromRadians(car.longitude, car.latitude, car.height / 2);

                                lengthNow = car.height;
                                bottomRadiusNow = lengthNow * 0.3; //地面圆半径

                                return newPoint;
                            }, false),
                            cylinder: wallattr
                        });
                    }

                    //获取剖面数据

                }, {
                    key: "getTerrainHeight",
                    value: function getTerrainHeight(_calback) {
                        var that = this;
                        var positions = this.arrLinePoint;

                        var alllen = 0;
                        var arrLength = [];
                        var arrHbgd = [];
                        var arrFxgd = [];
                        var arrPoint = [];

                        var index = 0;
                        function getLineFD() {
                            index++;

                            var arr = [positions[index - 1], positions[index]];
                            (0, _polyline.computeSurfaceLine)({
                                viewer: that.viewer,
                                positions: arr,
                                calback: function calback(raisedPositions, noHeight) {

                                    var h1 = positions[index - 1].lonlat[2];
                                    var h2 = positions[index].lonlat[2];
                                    var hstep = (h2 - h1) / raisedPositions.length;

                                    for (var i = 0; i < raisedPositions.length; i++) {
                                        //已飞行长度
                                        if (i != 0) {
                                            alllen += Cesium.Cartesian3.distance(raisedPositions[i], raisedPositions[i - 1]);
                                        }
                                        arrLength.push(Number(alllen.toFixed(1)));

                                        //坐标
                                        var point = (0, _point.formatPosition)(raisedPositions[i]);
                                        arrPoint.push(point);

                                        //海拔高度
                                        var hbgd = noHeight ? 0 : point.z;
                                        arrHbgd.push(hbgd);

                                        //飞行高度
                                        var fxgd = Number((h1 + hstep * i).toFixed(1));
                                        arrFxgd.push(fxgd);
                                    }

                                    if (index >= positions.length - 1) {
                                        _calback({
                                            arrLength: arrLength,
                                            arrFxgd: arrFxgd,
                                            arrHbgd: arrHbgd,
                                            arrPoint: arrPoint
                                        });
                                    } else {
                                        getLineFD();
                                    }
                                }
                            });
                        }
                        getLineFD();
                    }
                }, {
                    key: "toGeoJSON",
                    value: function toGeoJSON() {
                        return this.options;
                    }
                }, {
                    key: "toCZML",
                    value: function toCZML() {
                        var attr = this.options;

                        //时间
                        var currentTime = this.startTime.toString();
                        var stopTime = this.stopTime.toString();

                        //路径位置点
                        var cartographicDegrees = [];
                        var arrLinePoint = this.arrLinePoint;
                        for (var i = 0, length = arrLinePoint.length; i < length; i++) {
                            var item = arrLinePoint[i];

                            cartographicDegrees.push(item.second);
                            cartographicDegrees = cartographicDegrees.concat(item.lonlat);
                        }

                        var czmlLine = {
                            "id": this.name,
                            "description": this.options.remark,
                            "availability": currentTime + "/" + stopTime,
                            "orientation": { //方向
                                "velocityReference": "#position"
                            },
                            "position": { //位置 
                                "epoch": currentTime,
                                "cartographicDegrees": cartographicDegrees,
                                "interpolationAlgorithm": "LAGRANGE", //插值时使用的插值算法,有效值为“LINEAR”，“LAGRANGE”和“HERMITE”。
                                "interpolationDegree": 2 //插值时使用的插值程度。
                            }
                        };

                        if (this.options.label.show) {
                            //是否显示注记
                            czmlLine.label = {
                                "show": true,
                                "outlineWidth": 2,
                                "text": this.name,
                                "font": "12pt 微软雅黑 Console",
                                "outlineColor": { "rgba": [0, 0, 0, 255] },
                                "horizontalOrigin": "LEFT",
                                "fillColor": { "rgba": [213, 255, 0, 255] }
                            };
                        }
                        if (this.options.path.show) {
                            //是否显示路线
                            czmlLine.path = { //路线
                                "show": true,
                                "material": { "solidColor": { "color": { "rgba": [255, 0, 0, 255] } } },
                                "width": 5,
                                "resolution": 1,
                                "leadTime": 0,
                                "trailTime": this.alltimes
                            };
                        }
                        //漫游对象(模型)
                        if (this.options.model.show) {
                            //是否显示模型
                            czmlLine.model = this.options.model;
                        }

                        var czml = [{
                            "version": "1.0",
                            "id": "document",
                            "clock": {
                                "interval": currentTime + "/" + stopTime,
                                "currentTime": currentTime,
                                "multiplier": 1
                            }
                        }, czmlLine];
                        return czml;
                    }

                    //视角定位[路线范围]

                }, {
                    key: "centerAt",
                    value: function centerAt(opts) {
                        opts = opts || {};

                        var rectangle = (0, _point.getRectangle)((0, _pointconvert.lonlats2cartesians)(this.points));
                        this.viewer.camera.flyTo({
                            duration: Cesium.defaultValue(opts.duration, 0),
                            destination: rectangle
                        });
                        return rectangle;
                    }

                    //视角定位[目标点] 

                }, {
                    key: "flyTo",
                    value: function flyTo(opts) {
                        var _this = this;

                        opts = opts || {};

                        this.viewer.clock.shouldAnimate = false;
                        setTimeout(function () {
                            var viewer = _this.viewer;
                            var position = _this.position;
                            if (!position) return;

                            var heading = Cesium.Math.toDegrees(_this.hdr.heading) + Cesium.defaultValue(opts.heading, 0);

                            viewer.mapv.centerPoint(position, {
                                radius: Cesium.defaultValue(opts.radius, Cesium.defaultValue(opts.distance, 500)), //距离目标点的距离
                                heading: heading,
                                pitch: Cesium.defaultValue(opts.pitch, -50),
                                duration: 0.1,
                                complete: function complete() {
                                    viewer.clock.shouldAnimate = true;
                                }
                            });
                        }, 500);
                    }

                    //暂停

                }, {
                    key: "pause",
                    value: function pause() {
                        this.viewer.clock.shouldAnimate = false;
                    }
                    //继续

                }, {
                    key: "proceed",
                    value: function proceed() {
                        this.viewer.clock.shouldAnimate = true;
                    }

                    //停止，结束漫游

                }, {
                    key: "stop",
                    value: function stop() {
                        this.viewer.trackedEntity = undefined;
                        this.viewer.scene.preRender.removeEventListener(this.preRender_eventHandler, this);

                        if (this.entity) {
                            this.viewer.entities.remove(this.entity);
                            delete this.entity;
                        }

                        if (this._bak_startTime) {
                            this.viewer.clock.startTime = this._bak_startTime;
                            delete this._bak_startTime;
                        }
                        if (this._bak_stopTime) {
                            this.viewer.clock.stopTime = this._bak_stopTime;
                            delete this._bak_stopTime;
                        }
                        if (this._bak_multiplier) {
                            this.viewer.clock.multiplier = this._bak_multiplier;
                            delete this._bak_multiplier;
                        }
                        if (this._bak_clockRange) {
                            this.viewer.clock.clockRange = this._bak_clockRange;
                            delete this._bak_clockRange;
                        }

                        this._flyok_point_index = 0;
                        this._isStart = false;
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.stop();

                        if (this.entity) {
                            this.viewer.entities.remove(this.entity);
                            delete this.entity;
                        }
                        if (this.wallEntity) {
                            this.viewer.entities.remove(this.wallEntity);
                            delete this.wallEntity;
                        }
                        if (this.cylinderEntity) {
                            this.viewer.entities.remove(this.cylinderEntity);
                            delete this.cylinderEntity;
                        }
                    }
                }, {
                    key: "popup",
                    get: function get() {
                        return this._popup;
                    },
                    set: function set(value) {
                        this._popup = value;

                        if (this.entity) this.entity.popup = value;
                    }
                    //当前信息

                }, {
                    key: "info",
                    get: function get() {
                        return this.timeinfo;
                    }

                    //已经飞行过的点index

                }, {
                    key: "indexForFlyOK",
                    get: function get() {
                        return this._flyok_point_index;
                    }

                    // 当前点

                }, {
                    key: "position",
                    get: function get() {
                        var position = Cesium.Property.getValueOrUndefined(this.property, this.viewer.clock.currentTime, positionScratch);
                        return position;
                    }

                    // 获取当前角度 

                }, {
                    key: "orientation",
                    get: function get() {
                        var _orientation = Cesium.Property.getValueOrUndefined(this.velocityOrientation, this.viewer.clock.currentTime, orientationScratch);
                        return _orientation;
                    }

                    // 获取当前hdr角度 

                }, {
                    key: "hdr",
                    get: function get() {
                        var position = this.position; //当前点 
                        var _orientation = this.orientation; //获取当前角度 
                        if (!position || !_orientation) return null;
                        var autoHpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, _orientation, this.viewer.scene.globe.ellipsoid, this._fixedFrameTransform);
                        return autoHpr;
                    }

                    // 获取当前矩阵

                }, {
                    key: "matrix",
                    get: function get() {
                        return this.getModelMatrix();
                    }
                }]);

                return FlyLine;
            }();

            /***/
}),
/* 139 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _AttackArrow = __webpack_require__(140);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //攻击箭头
            var drawtype = 'attackArrow';

            var attackArrow = new _AttackArrow.AttackArrow();

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                _hasMidPoint: true, //是否可以加点
                hasClosure: false, //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 999, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 140 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.AttackArrow = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _ArrowParent2 = __webpack_require__(34);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            //攻击箭头
            var AttackArrow = exports.AttackArrow = function (_ArrowParent) {
                _inherits(AttackArrow, _ArrowParent);

                function AttackArrow(opt) {
                    _classCallCheck(this, AttackArrow);

                    var _this = _possibleConstructorReturn(this, (AttackArrow.__proto__ || Object.getPrototypeOf(AttackArrow)).call(this));

                    if (!opt) opt = {};
                    //影响因素
                    _this.headHeightFactor = opt.headHeightFactor || 0.18;
                    _this.headWidthFactor = opt.headWidthFactor || 0.3;
                    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
                    _this.headTailFactor = opt.headTailFactor || 0.8;
                    _this.positions = null;
                    _this.plotUtil = _PlotUtil.plotUtil;
                    return _this;
                }

                _createClass(AttackArrow, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;
                        var pnts = pointconvert.cartesians2mercators(positions);

                        var _ref = [pnts[0], pnts[1]],
                            tailLeft = _ref[0],
                            tailRight = _ref[1];

                        if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
                            tailLeft = pnts[1];
                            tailRight = pnts[0];
                        }
                        var midTail = this.plotUtil.Mid(tailLeft, tailRight);
                        var bonePnts = [midTail].concat(pnts.slice(2));
                        var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
                        var _ref2 = [headPnts[0], headPnts[4]],
                            neckLeft = _ref2[0],
                            neckRight = _ref2[1];

                        var tailWidthFactor = this.plotUtil.MathDistance(tailLeft, tailRight) / this.plotUtil.getBaseLength(bonePnts);
                        var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, tailWidthFactor);
                        var count = bodyPnts.length;
                        var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
                        leftPnts.push(neckLeft);
                        var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
                        rightPnts.push(neckRight);
                        leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
                        rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
                        var pList = leftPnts.concat(headPnts, rightPnts.reverse());

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return AttackArrow;
            }(_ArrowParent2.ArrowParent);

            /***/
}),
/* 141 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _AttackArrowPW = __webpack_require__(142);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //攻击箭头(平尾)
            var drawtype = 'attackArrowPW';
            var attackArrow = new _AttackArrowPW.AttackArrowPW();

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                _hasMidPoint: true, //是否可以加点
                hasClosure: false, //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 999, //最多允许点的个数 
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 142 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.AttackArrowPW = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _ArrowParent2 = __webpack_require__(34);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            //攻击箭头（燕尾）
            var AttackArrowPW = exports.AttackArrowPW = function (_ArrowParent) {
                _inherits(AttackArrowPW, _ArrowParent);

                function AttackArrowPW(opt) {
                    _classCallCheck(this, AttackArrowPW);

                    var _this = _possibleConstructorReturn(this, (AttackArrowPW.__proto__ || Object.getPrototypeOf(AttackArrowPW)).call(this));

                    if (!opt) opt = {};
                    //影响因素
                    _this.headHeightFactor = opt.headHeightFactor || 0.18;
                    _this.headWidthFactor = opt.headWidthFactor || 0.3;
                    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
                    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;

                    _this.positions = null;
                    _this.plotUtil = _PlotUtil.plotUtil;
                    return _this;
                }

                _createClass(AttackArrowPW, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;

                        var pnts = pointconvert.cartesians2mercators(positions);

                        var tailPnts = this.getTailPoints(pnts);
                        var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[1]);
                        var neckLeft = headPnts[0];
                        var neckRight = headPnts[4];
                        var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
                        var _count = bodyPnts.length;
                        var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
                        leftPnts.push(neckLeft);
                        var rightPnts = [tailPnts[1]].concat(bodyPnts.slice(_count / 2, _count));
                        rightPnts.push(neckRight);
                        leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
                        rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
                        var pList = leftPnts.concat(headPnts, rightPnts.reverse());

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }, {
                    key: 'getTailPoints',
                    value: function getTailPoints(points) {
                        var allLen = this.plotUtil.getBaseLength(points);
                        var tailWidth = allLen * this.tailWidthFactor;
                        var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
                        var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
                        return [tailLeft, tailRight];
                    }
                }]);

                return AttackArrowPW;
            }(_ArrowParent2.ArrowParent);

            /***/
}),
/* 143 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _AttackArrowYW = __webpack_require__(144);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //攻击箭头
            var drawtype = 'attackArrowYW';
            var attackArrow = new _AttackArrowYW.AttackArrowYW();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                _hasMidPoint: true, //是否可以加点
                hasClosure: false, //是否首尾相连闭合（线不闭合，面闭合），用于处理中间点
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 999, //最多允许点的个数 
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return attackArrow.startCompute(positions);
                }
            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 144 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.AttackArrowYW = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _ArrowParent2 = __webpack_require__(34);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            //攻击箭头（燕尾）
            var AttackArrowYW = exports.AttackArrowYW = function (_ArrowParent) {
                _inherits(AttackArrowYW, _ArrowParent);

                function AttackArrowYW(opt) {
                    _classCallCheck(this, AttackArrowYW);

                    var _this = _possibleConstructorReturn(this, (AttackArrowYW.__proto__ || Object.getPrototypeOf(AttackArrowYW)).call(this));

                    if (!opt) opt = {};
                    //影响因素
                    _this.headHeightFactor = opt.headHeightFactor || 0.18;
                    _this.headWidthFactor = opt.headWidthFactor || 0.3;
                    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
                    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
                    _this.headTailFactor = opt.headTailFactor || 0.8;
                    _this.swallowTailFactor = opt.swallowTailFactor || 1;
                    _this.positions = null;
                    _this.plotUtil = _PlotUtil.plotUtil;
                    return _this;
                }

                _createClass(AttackArrowYW, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;

                        var pnts = pointconvert.cartesians2mercators(positions);

                        var _ref = [pnts[0], pnts[1]],
                            tailLeft = _ref[0],
                            tailRight = _ref[1];

                        if (this.plotUtil.isClockWise(pnts[0], pnts[1], pnts[2])) {
                            tailLeft = pnts[1];
                            tailRight = pnts[0];
                        }
                        var midTail = this.plotUtil.Mid(tailLeft, tailRight);
                        var bonePnts = [midTail].concat(pnts.slice(2));
                        var headPnts = this.getArrowHeadPoints(bonePnts, tailLeft, tailRight);
                        var _ref2 = [headPnts[0], headPnts[4]],
                            neckLeft = _ref2[0],
                            neckRight = _ref2[1];

                        var tailWidth = this.plotUtil.MathDistance(tailLeft, tailRight);
                        var allLen = this.plotUtil.getBaseLength(bonePnts);
                        var len = allLen * this.tailWidthFactor * this.swallowTailFactor;
                        var swallowTailPnt = this.plotUtil.getThirdPoint(bonePnts[1], bonePnts[0], 0, len, true);
                        var factor = tailWidth / allLen;
                        var bodyPnts = this.getArrowBodyPoints(bonePnts, neckLeft, neckRight, factor);
                        var count = bodyPnts.length;
                        var leftPnts = [tailLeft].concat(bodyPnts.slice(0, count / 2));
                        leftPnts.push(neckLeft);
                        var rightPnts = [tailRight].concat(bodyPnts.slice(count / 2, count));
                        rightPnts.push(neckRight);
                        leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
                        rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
                        var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [swallowTailPnt, leftPnts[0]]);

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return AttackArrowYW;
            }(_ArrowParent2.ArrowParent);

            /***/
}),
/* 145 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _CloseCurve = __webpack_require__(146);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //闭合曲面(3个点)
            var drawtype = 'closeVurve';
            var closeCurve = new _CloseCurve.CloseCurve();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                _hasMidPoint: true, //是否可以加点
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return closeCurve.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 999, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return closeCurve.startCompute(positions);
                }

            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 146 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CloseCurve = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //闭合曲面
            var CloseCurve = exports.CloseCurve = function () {
                function CloseCurve(opt) {
                    _classCallCheck(this, CloseCurve);

                    if (!opt) opt = {};
                    //影响因素
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(CloseCurve, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        var pnts = pointconvert.cartesians2mercators(positions);
                        pnts.push(pnts[0], pnts[1]);

                        var normals = [];
                        var pList = [];
                        for (var i = 0; i < pnts.length - 2; i++) {
                            var normalPoints = this.plotUtil.getBisectorNormals(0.3, pnts[i], pnts[i + 1], pnts[i + 2]);
                            normals = normals.concat(normalPoints);
                        }
                        var count = normals.length;
                        normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
                        for (var _i = 0; _i < pnts.length - 2; _i++) {
                            var pnt1 = pnts[_i];
                            var pnt2 = pnts[_i + 1];
                            pList.push(pnt1);
                            for (var t = 0; t <= 100; t++) {
                                var pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
                                pList.push(pnt);
                            }
                            pList.push(pnt2);
                        }

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return CloseCurve;
            }();

            /***/
}),
/* 147 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _DoubleArrow = __webpack_require__(148);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //双箭头（钳击）
            var drawtype = 'doubleArrow';
            var doubleArrow = new _DoubleArrow.DoubleArrow();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    var pnts = doubleArrow.startCompute(positions);
                    return pnts;
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 5, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                getShowPositions: function getShowPositions(positions) {
                    var pnts = doubleArrow.startCompute(positions);
                    return pnts;
                }
            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 148 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DoubleArrow = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //计算钳击箭头坐标
            var DoubleArrow = exports.DoubleArrow = function () {
                function DoubleArrow(opt) {
                    _classCallCheck(this, DoubleArrow);

                    if (!opt) opt = {};
                    //影响因素
                    this.headHeightFactor = opt.headHeightFactor || 0.25;
                    this.headWidthFactor = opt.headWidthFactor || 0.3;
                    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    this.neckWidthFactor = opt.neckWidthFactor || 0.15;
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(DoubleArrow, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;

                        var pnts = pointconvert.cartesians2mercators(positions);

                        var _ref = [pnts[0], pnts[1], pnts[2]];
                        var pnt1 = _ref[0];
                        var pnt2 = _ref[1];
                        var pnt3 = _ref[2];
                        var count = this.positions.length;
                        var tempPoint4;
                        var connPoint;
                        if (count === 3) {
                            tempPoint4 = this.getTempPoint4(pnt1, pnt2, pnt3);
                            connPoint = this.plotUtil.Mid(pnt1, pnt2);
                        } else if (count === 4) {
                            tempPoint4 = pnts[3];
                            connPoint = this.plotUtil.Mid(pnt1, pnt2);
                        } else {
                            tempPoint4 = pnts[3];
                            connPoint = pnts[4];
                        }
                        var leftArrowPnts = undefined,
                            rightArrowPnts = undefined;

                        if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
                            leftArrowPnts = this.getArrowPoints(pnt1, connPoint, tempPoint4, false);
                            rightArrowPnts = this.getArrowPoints(connPoint, pnt2, pnt3, true);
                        } else {
                            leftArrowPnts = this.getArrowPoints(pnt2, connPoint, pnt3, false);
                            rightArrowPnts = this.getArrowPoints(connPoint, pnt1, tempPoint4, true);
                        }
                        var m = leftArrowPnts.length;
                        var t = (m - 5) / 2;
                        var llBodyPnts = leftArrowPnts.slice(0, t);
                        var lArrowPnts = leftArrowPnts.slice(t, t + 5);
                        var lrBodyPnts = leftArrowPnts.slice(t + 5, m);
                        var rlBodyPnts = rightArrowPnts.slice(0, t);
                        var rArrowPnts = rightArrowPnts.slice(t, t + 5);
                        var rrBodyPnts = rightArrowPnts.slice(t + 5, m);
                        rlBodyPnts = this.plotUtil.getBezierPoints(rlBodyPnts);
                        var bodyPnts = this.plotUtil.getBezierPoints(rrBodyPnts.concat(llBodyPnts.slice(1)));
                        lrBodyPnts = this.plotUtil.getBezierPoints(lrBodyPnts);
                        var newPnts = rlBodyPnts.concat(rArrowPnts, bodyPnts, lArrowPnts, lrBodyPnts);

                        var returnArr = pointconvert.mercators2cartesians(newPnts);
                        return returnArr;
                    }
                }, {
                    key: 'getTempPoint4',
                    value: function getTempPoint4(linePnt1, linePnt2, point) {
                        var midPnt = this.plotUtil.Mid(linePnt1, linePnt2);
                        var len = this.plotUtil.MathDistance(midPnt, point);
                        var angle = this.plotUtil.getAngleOfThreePoints(linePnt1, midPnt, point);
                        var symPnt = undefined,
                            distance1 = undefined,
                            distance2 = undefined,
                            mid = undefined;

                        if (angle < Math.PI / 2) {
                            distance1 = len * Math.sin(angle);
                            distance2 = len * Math.cos(angle);
                            mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
                            symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
                        } else if (angle >= Math.PI / 2 && angle < Math.PI) {
                            distance1 = len * Math.sin(Math.PI - angle);
                            distance2 = len * Math.cos(Math.PI - angle);
                            mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, false);
                            symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
                        } else if (angle >= Math.PI && angle < Math.PI * 1.5) {
                            distance1 = len * Math.sin(angle - Math.PI);
                            distance2 = len * Math.cos(angle - Math.PI);
                            mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
                            symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, true);
                        } else {
                            distance1 = len * Math.sin(Math.PI * 2 - angle);
                            distance2 = len * Math.cos(Math.PI * 2 - angle);
                            mid = this.plotUtil.getThirdPoint(linePnt1, midPnt, Math.PI / 2, distance1, true);
                            symPnt = this.plotUtil.getThirdPoint(midPnt, mid, Math.PI / 2, distance2, false);
                        }
                        return symPnt;
                    }
                }, {
                    key: 'getArrowPoints',
                    value: function getArrowPoints(pnt1, pnt2, pnt3, clockWise) {
                        var midPnt = this.plotUtil.Mid(pnt1, pnt2);
                        var len = this.plotUtil.MathDistance(midPnt, pnt3);
                        var midPnt1 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.3, true);
                        var midPnt2 = this.plotUtil.getThirdPoint(pnt3, midPnt, 0, len * 0.5, true);
                        midPnt1 = this.plotUtil.getThirdPoint(midPnt, midPnt1, Math.PI / 2, len / 5, clockWise);
                        midPnt2 = this.plotUtil.getThirdPoint(midPnt, midPnt2, Math.PI / 2, len / 4, clockWise);
                        var points = [midPnt, midPnt1, midPnt2, pnt3];
                        var arrowPnts = this.getArrowHeadPoints(points);
                        if (arrowPnts && Array.isArray(arrowPnts) && arrowPnts.length > 0) {
                            var _ref2 = [arrowPnts[0], arrowPnts[4]],
                                neckLeftPoint = _ref2[0],
                                neckRightPoint = _ref2[1];

                            var tailWidthFactor = this.plotUtil.MathDistance(pnt1, pnt2) / this.plotUtil.getBaseLength(points) / 2;
                            var bodyPnts = this.getArrowBodyPoints(points, neckLeftPoint, neckRightPoint, tailWidthFactor);
                            if (bodyPnts) {
                                var n = bodyPnts.length;
                                var lPoints = bodyPnts.slice(0, n / 2);
                                var rPoints = bodyPnts.slice(n / 2, n);
                                lPoints.push(neckLeftPoint);
                                rPoints.push(neckRightPoint);
                                lPoints = lPoints.reverse();
                                lPoints.push(pnt2);
                                rPoints = rPoints.reverse();
                                rPoints.push(pnt1);
                                return lPoints.reverse().concat(arrowPnts, rPoints);
                            }
                        } else {
                            throw new Error('插值出错');
                        }
                    }
                }, {
                    key: 'getArrowHeadPoints',
                    value: function getArrowHeadPoints(points) {
                        var len = this.plotUtil.getBaseLength(points);
                        var headHeight = len * this.headHeightFactor;
                        var headPnt = points[points.length - 1];
                        var headWidth = headHeight * this.headWidthFactor;
                        var neckWidth = headHeight * this.neckWidthFactor;
                        var neckHeight = headHeight * this.neckHeightFactor;
                        var headEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, headHeight, true);
                        var neckEndPnt = this.plotUtil.getThirdPoint(points[points.length - 2], headPnt, 0, neckHeight, true);
                        var headLeft = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, false);
                        var headRight = this.plotUtil.getThirdPoint(headPnt, headEndPnt, Math.PI / 2, headWidth, true);
                        var neckLeft = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, false);
                        var neckRight = this.plotUtil.getThirdPoint(headPnt, neckEndPnt, Math.PI / 2, neckWidth, true);
                        return [neckLeft, headLeft, headPnt, headRight, neckRight];
                    }
                }, {
                    key: 'getArrowBodyPoints',
                    value: function getArrowBodyPoints(points, neckLeft, neckRight, tailWidthFactor) {
                        var allLen = this.plotUtil.wholeDistance(points);
                        var len = this.plotUtil.getBaseLength(points);
                        var tailWidth = len * tailWidthFactor;
                        var neckWidth = this.plotUtil.MathDistance(neckLeft, neckRight);
                        var widthDif = (tailWidth - neckWidth) / 2;
                        var tempLen = 0,
                            leftBodyPnts = [],
                            rightBodyPnts = [];

                        for (var i = 1; i < points.length - 1; i++) {
                            var angle = this.plotUtil.getAngleOfThreePoints(points[i - 1], points[i], points[i + 1]) / 2;
                            tempLen += this.plotUtil.MathDistance(points[i - 1], points[i]);
                            var w = (tailWidth / 2 - tempLen / allLen * widthDif) / Math.sin(angle);
                            var left = this.plotUtil.getThirdPoint(points[i - 1], points[i], Math.PI - angle, w, true);
                            var right = this.plotUtil.getThirdPoint(points[i - 1], points[i], angle, w, false);
                            leftBodyPnts.push(left);
                            rightBodyPnts.push(right);
                        }
                        return leftBodyPnts.concat(rightBodyPnts);
                    }
                }]);

                return DoubleArrow;
            }();

            /***/
}),
/* 149 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _FineArrow = __webpack_require__(150);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //直箭头(2个点)
            var drawtype = 'fineArrow';
            var fineArrow = new _FineArrow.FineArrow();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return fineArrow.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return fineArrow.startCompute(positions);
                }

            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 150 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FineArrow = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //计算粗单尖直箭头坐标
            var FineArrow = exports.FineArrow = function () {
                function FineArrow(opt) {
                    _classCallCheck(this, FineArrow);

                    if (!opt) opt = {};
                    //影响因素
                    this.headAngle = opt.headAngle || Math.PI / 8.5;
                    this.neckAngle = opt.neckAngle || Math.PI / 13;
                    this.tailWidthFactor = opt.tailWidthFactor || 0.1;
                    this.neckWidthFactor = opt.neckWidthFactor || 0.2;
                    this.headWidthFactor = opt.headWidthFactor || 0.25;
                    this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(FineArrow, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;

                        var pnts = pointconvert.cartesians2mercators(positions);

                        var _ref = [pnts[0], pnts[1]],
                            pnt1 = _ref[0],
                            pnt2 = _ref[1];
                        var len = this.plotUtil.getBaseLength(pnts);
                        var tailWidth = len * this.tailWidthFactor;
                        var neckWidth = len * this.neckWidthFactor;
                        var headWidth = len * this.headWidthFactor;
                        var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
                        var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
                        var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
                        var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
                        var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
                        var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
                        var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return FineArrow;
            }();

            /***/
}),
/* 151 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _FineArrowYW = __webpack_require__(152);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //直箭头(2个点)
            var drawtype = 'fineArrowYW';
            var fineArrowYW = new _FineArrowYW.FineArrowYW();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return fineArrowYW.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return fineArrowYW.startCompute(positions);
                }

            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 152 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FineArrowYW = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _ArrowParent2 = __webpack_require__(34);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

            function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

            //计算粗单尖直箭头(带燕尾)坐标
            var FineArrowYW = exports.FineArrowYW = function (_ArrowParent) {
                _inherits(FineArrowYW, _ArrowParent);

                function FineArrowYW(opt) {
                    _classCallCheck(this, FineArrowYW);

                    var _this = _possibleConstructorReturn(this, (FineArrowYW.__proto__ || Object.getPrototypeOf(FineArrowYW)).call(this, opt));

                    if (!opt) opt = {};
                    //影响因素
                    _this.headHeightFactor = opt.headHeightFactor || 0.18;
                    _this.headWidthFactor = opt.headWidthFactor || 0.3;
                    _this.neckHeightFactor = opt.neckHeightFactor || 0.85;
                    _this.neckWidthFactor = opt.neckWidthFactor || 0.15;
                    _this.tailWidthFactor = opt.tailWidthFactor || 0.1;
                    _this.swallowTailFactor = opt.swallowTailFactor || 1;
                    _this.positions = null;
                    _this.plotUtil = _PlotUtil.plotUtil;
                    return _this;
                }

                _createClass(FineArrowYW, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        if (!positions) return;
                        this.positions = positions;

                        var pnts = pointconvert.cartesians2mercators(positions);

                        var tailPnts = this.getTailPoints(pnts);
                        var headPnts = this.getArrowHeadPoints(pnts, tailPnts[0], tailPnts[2]);
                        var neckLeft = headPnts[0];
                        var neckRight = headPnts[4];
                        var bodyPnts = this.getArrowBodyPoints(pnts, neckLeft, neckRight, this.tailWidthFactor);
                        var _count = bodyPnts.length;
                        var leftPnts = [tailPnts[0]].concat(bodyPnts.slice(0, _count / 2));
                        leftPnts.push(neckLeft);
                        var rightPnts = [tailPnts[2]].concat(bodyPnts.slice(_count / 2, _count));
                        rightPnts.push(neckRight);
                        leftPnts = this.plotUtil.getQBSplinePoints(leftPnts);
                        rightPnts = this.plotUtil.getQBSplinePoints(rightPnts);
                        var pList = leftPnts.concat(headPnts, rightPnts.reverse(), [tailPnts[1], leftPnts[0]]);

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }, {
                    key: 'getTailPoints',
                    value: function getTailPoints(points) {
                        var allLen = this.plotUtil.getBaseLength(points);
                        var tailWidth = allLen * this.tailWidthFactor;
                        var tailLeft = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, false);
                        var tailRight = this.plotUtil.getThirdPoint(points[1], points[0], Math.PI / 2, tailWidth, true);
                        var len = tailWidth * this.swallowTailFactor;
                        var swallowTailPnt = this.plotUtil.getThirdPoint(points[1], points[0], 0, len, true);
                        return [tailLeft, swallowTailPnt, tailRight];
                    }
                }]);

                return FineArrowYW;
            }(_ArrowParent2.ArrowParent);

            /***/
}),
/* 153 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _GatheringPlace = __webpack_require__(154);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //集结地(3个点)
            var drawtype = 'gatheringPlace';
            var gatheringPlace = new _GatheringPlace.GatheringPlace();
            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return gatheringPlace.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 3, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return gatheringPlace.startCompute(positions);
                }

            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 154 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GatheringPlace = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //集结地
            var GatheringPlace = exports.GatheringPlace = function () {
                function GatheringPlace(opt) {
                    _classCallCheck(this, GatheringPlace);

                    if (!opt) opt = {};
                    //影响因素
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(GatheringPlace, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {
                        var pnts = pointconvert.cartesians2mercators(positions);

                        var mid = this.plotUtil.Mid(pnts[0], pnts[2]);
                        pnts.push(mid, pnts[0], pnts[1]);
                        var normals = [],
                            pnt1 = undefined,
                            pnt2 = undefined,
                            pnt3 = undefined,
                            pList = [];
                        for (var i = 0; i < pnts.length - 2; i++) {
                            pnt1 = pnts[i];
                            pnt2 = pnts[i + 1];
                            pnt3 = pnts[i + 2];
                            var normalPoints = this.plotUtil.getBisectorNormals(0.4, pnt1, pnt2, pnt3);
                            normals = normals.concat(normalPoints);
                        }
                        var count = normals.length;
                        normals = [normals[count - 1]].concat(normals.slice(0, count - 1));
                        for (var _i = 0; _i < pnts.length - 2; _i++) {
                            pnt1 = pnts[_i];
                            pnt2 = pnts[_i + 1];
                            pList.push(pnt1);
                            for (var t = 0; t <= 100; t++) {
                                var _pnt = this.plotUtil.getCubicValue(t / 100, pnt1, normals[_i * 2], normals[_i * 2 + 1], pnt2);
                                pList.push(_pnt);
                            }
                            pList.push(pnt2);
                        }

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return GatheringPlace;
            }();

            /***/
}),
/* 155 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _StraightArrow = __webpack_require__(156);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //直箭头(3个点)
            var drawtype = 'straightArrow';
            var straightArrow = new _StraightArrow.StraightArrow();

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return straightArrow.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return straightArrow.startCompute(positions);
                }

            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 156 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.StraightArrow = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //计算粗直箭头坐标
            var StraightArrow = exports.StraightArrow = function () {
                function StraightArrow(opt) {
                    _classCallCheck(this, StraightArrow);

                    if (!opt) opt = {};
                    //影响因素
                    this.tailWidthFactor = opt.tailWidthFactor || 0.05;
                    this.neckWidthFactor = opt.neckWidthFactor || 0.1;
                    this.headWidthFactor = opt.headWidthFactor || 0.15;
                    this.headAngle = Math.PI / 4;
                    this.neckAngle = Math.PI * 0.17741;
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(StraightArrow, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {

                        var pnts = pointconvert.cartesians2mercators(positions);
                        var _ref = [pnts[0], pnts[1]],
                            pnt1 = _ref[0],
                            pnt2 = _ref[1];
                        var len = this.plotUtil.getBaseLength(pnts);
                        var tailWidth = len * this.tailWidthFactor;
                        var neckWidth = len * this.neckWidthFactor;
                        var headWidth = len * this.headWidthFactor;
                        var tailLeft = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, true);
                        var tailRight = this.plotUtil.getThirdPoint(pnt2, pnt1, Math.PI / 2, tailWidth, false);
                        var headLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, false);
                        var headRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.headAngle, headWidth, true);
                        var neckLeft = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, false);
                        var neckRight = this.plotUtil.getThirdPoint(pnt1, pnt2, this.neckAngle, neckWidth, true);
                        var pList = [tailLeft, neckLeft, headLeft, pnt2, headRight, neckRight, tailRight];

                        var returnArr = pointconvert.mercators2cartesians(pList);
                        return returnArr;
                    }
                }]);

                return StraightArrow;
            }();

            /***/
}),
/* 157 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _Lune = __webpack_require__(158);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //弓形面(3个点)
            var drawtype = 'lune';
            var lune = new _Lune.Lune();

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return lune.startCompute(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 3, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return lune.startCompute(positions);
                }

            });
            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 158 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Lune = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _PlotUtil = __webpack_require__(11);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //弓形面
            var Lune = exports.Lune = function () {
                function Lune(opt) {
                    _classCallCheck(this, Lune);

                    if (!opt) opt = {};
                    //影响因素
                    this.positions = null;
                    this.plotUtil = _PlotUtil.plotUtil;
                }

                _createClass(Lune, [{
                    key: 'startCompute',
                    value: function startCompute(positions) {

                        var pnts = pointconvert.cartesians2mercators(positions);
                        var _ref = [pnts[0], pnts[1], pnts[2], undefined, undefined],
                            pnt1 = _ref[0],
                            pnt2 = _ref[1],
                            pnt3 = _ref[2],
                            startAngle = _ref[3],
                            endAngle = _ref[4];

                        var center = this.plotUtil.getCircleCenterOfThreePoints(pnt1, pnt2, pnt3);
                        var radius = this.plotUtil.MathDistance(pnt1, center);
                        var angle1 = this.plotUtil.getAzimuth(pnt1, center);
                        var angle2 = this.plotUtil.getAzimuth(pnt2, center);
                        if (this.plotUtil.isClockWise(pnt1, pnt2, pnt3)) {
                            startAngle = angle2;
                            endAngle = angle1;
                        } else {
                            startAngle = angle1;
                            endAngle = angle2;
                        }
                        pnts = this.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
                        pnts.push(pnts[0]);

                        var returnArr = pointconvert.mercators2cartesians(pnts);
                        return returnArr;
                    }
                }]);

                return Lune;
            }();

            /***/
}),
/* 159 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _pointconvert = __webpack_require__(3);

            var pointconvert = _interopRequireWildcard(_pointconvert);

            var _PlotUtil = __webpack_require__(11);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //扇形(3个点)
            var drawtype = 'sector';

            function getPositions(positions, attribute) {

                var pnts = pointconvert.cartesians2mercators(positions);
                var center = pnts[0],
                    pnt2 = pnts[1],
                    pnt3 = pnts[2];
                var radius = _PlotUtil.plotUtil.MathDistance(pnt2, center);
                var startAngle = _PlotUtil.plotUtil.getAzimuth(pnt2, center);
                var endAngle = _PlotUtil.plotUtil.getAzimuth(pnt3, center);
                var pList = _PlotUtil.plotUtil.getArcPoints(center, radius, startAngle, endAngle);
                pList.push(center, pList[0]);

                var returnArr = pointconvert.mercators2cartesians(pList);
                return returnArr;
            }

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return getPositions(positions, attribute);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 3, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return getPositions(positions, attribute);
                }

            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 160 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _matrix = __webpack_require__(17);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //正多边形  边数取决于config.border
            var drawtype = 'regular';

            function getPositions(positions, attribute) {
                var center = positions[0];
                var point = positions[1];
                var num = attribute.config.border || 3; //边数量

                var addAngle = 360 / num;

                var pointArr = [];
                for (var i = 0; i < num; i++) {
                    var thisAngle = addAngle * i;
                    var newPoint = (0, _matrix.getRotateCenterPoint)(center, point, thisAngle);
                    pointArr.push(newPoint);
                }
                return pointArr;
            }

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return getPositions(positions, attribute);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 2, //至少需要点的个数 
                _maxPointNum: 2, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions, attribute) {
                    return getPositions(positions, attribute);
                }
            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 161 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(9);

            var _Edit = __webpack_require__(10);

            var _Draw2 = __webpack_require__(4);

            var _util = __webpack_require__(1);

            var _matrix = __webpack_require__(17);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //等腰三角形(3个点) 
            var drawtype = 'triangleDY';

            var midPoint = new Cesium.Cartesian3();

            function getPositions(positions) {
                //p1 p2 用于控制腰的高度 p3用于控制夹角
                var p1 = positions[0];
                var p2 = positions[1];
                var p3 = positions[2];

                var midpoint = Cesium.Cartesian3.midpoint(p1, p2, midPoint);

                var angle1 = (0, _util.getAngle)(midpoint, p2);
                var angle2 = (0, _util.getAngle)(midpoint, p3);
                var angle = angle1 - angle2 - 90;
                // console.log("angle1:" + angle1 + ",angle2:" + angle2);
                var newPoint2 = (0, _matrix.getRotateCenterPoint)(midpoint, p3, angle);

                // positions[2] = newPoint2;

                return [p1, p2, newPoint2];
            }

            //编辑
            var EditEx = _Edit.EditPolygonEx.extend({
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return getPositions(positions);
                }
            });

            //绘制
            var DrawEx = _Draw.DrawPolygonEx.extend({
                type: drawtype,
                _minPointNum: 3, //至少需要点的个数 
                _maxPointNum: 3, //最多允许点的个数
                editClass: EditEx, //编辑控制类
                //根据标绘绘制的点，生成显示的边界点
                getShowPositions: function getShowPositions(positions) {
                    return getPositions(positions);
                }
            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 162 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _Draw = __webpack_require__(41);

            var _Draw2 = __webpack_require__(4);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //div点（转图片）
            var drawtype = 'div-point';

            //绘制
            var DrawEx = _Draw.DrawBillboard.extend({
                //更新图标，子类用
                updateImg: function updateImg(style, entity) {
                    // if (this._islosdImg) return;
                    // this._islosdImg = true;

                    var that = this;

                    var div = (0, _zepto.zepto)(style.html);
                    div.appendTo(style.parent || 'body');

                    div = div.get(0);

                    if (window.domtoimage) {
                        //lib/dom2img/dom-to-image.js
                        domtoimage.toPng(div).then(function (dataUrl) {
                            entity.billboard.image = dataUrl;

                            div.remove();
                            that._islosdImg = false;
                        }).catch(function (error) {
                            console.error('未知原因，导出失败!', error);

                            div.remove();
                            that._islosdImg = false;
                        });
                    } else if (window.html2canvas) {
                        //lib/dom2img/html2canvas.js
                        html2canvas(div, {
                            backgroundColor: null,
                            allowTaint: true
                        }).then(function (canvas) {
                            entity.billboard.image = canvas.toDataURL("image/png");

                            div.remove();
                            that._islosdImg = false;
                        }).catch(function (error) {
                            console.error('未知原因，导出失败!', error);

                            div.remove();
                            that._islosdImg = false;
                        });;
                    }
                }
            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 163 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Draw = __webpack_require__(41);

            var _Draw2 = __webpack_require__(4);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //字体点（转图片）
            var drawtype = 'font-point';

            //绘制
            var DrawEx = _Draw.DrawBillboard.extend({
                //更新图标，子类用
                updateImg: function updateImg(style, entity) {
                    // if (this._islosdImg) return;
                    // this._islosdImg = true;

                    var that = this;

                    var div = document.createElement("div"); //创建一个div
                    div.setAttribute('style', 'padding: 10px;text-align:center;');
                    var jd = document.createElement("i");
                    jd.setAttribute("class", Cesium.defaultValue(style.iconClass, "fa fa-automobile"));
                    jd.setAttribute('style', 'font-size:' + Cesium.defaultValue(style.iconSize, 50) + 'px;color:' + style.color + ';');
                    div.appendChild(jd);
                    document.body.appendChild(div);

                    if (window.domtoimage) {
                        //lib/dom2img/dom-to-image.js
                        domtoimage.toPng(div).then(function (dataUrl) {
                            entity.billboard.image = dataUrl;

                            document.body.removeChild(div);
                            that._islosdImg = false;
                        }).catch(function (error) {
                            console.error('未知原因，导出失败!', error);

                            document.body.removeChild(div);
                            that._islosdImg = false;
                        });
                    } else if (window.html2canvas) {
                        //lib/dom2img/html2canvas.js
                        html2canvas(div, {
                            backgroundColor: null,
                            allowTaint: true
                        }).then(function (canvas) {
                            entity.billboard.image = canvas.toDataURL("image/png");

                            document.body.removeChild(div);
                            that._islosdImg = false;
                        }).catch(function (error) {
                            console.error('未知原因，导出失败!', error);

                            document.body.removeChild(div);
                            that._islosdImg = false;
                        });
                    }
                }

            });

            //注册到Draw中
            (0, _Draw2.register)(drawtype, DrawEx);

            /***/
}),
/* 164 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CircleFadeMaterial = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CircleFade = __webpack_require__(165);

            var _CircleFade2 = _interopRequireDefault(_CircleFade);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var defaultColor = new Cesium.Color(0, 0, 0, 0);

            //圆形 单个扩散效果 材质 

            var CircleFadeMaterial = exports.CircleFadeMaterial = function () {
                //========== 构造方法 ========== 
                function CircleFadeMaterial(options) {
                    _classCallCheck(this, CircleFadeMaterial);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    this._definitionChanged = new Cesium.Event();
                    this._color = undefined;
                    this._colorSubscription = undefined;

                    this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
                    this._duration = options.duration || 1000; //时长

                    this._time = undefined;
                }

                //========== 对外属性 ==========  


                _createClass(CircleFadeMaterial, [{
                    key: "getType",


                    //========== 方法 ========== 
                    /**
                     * Gets the {@link Cesium.Material} type at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the type.
                     * @returns {String} The type of material.
                     */
                    value: function getType(time) {
                        return Cesium.Material.CircleFadeMaterialType;
                    }

                    /**
                     * Gets the value of the property at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the value.
                     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
                     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
                     */

                }, {
                    key: "getValue",
                    value: function getValue(time, result) {
                        if (!Cesium.defined(result)) {
                            result = {};
                        }
                        result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);

                        if (this._time === undefined) {
                            this._time = new Date().getTime();
                        }
                        result.time = (new Date().getTime() - this._time) / this._duration;
                        return result;
                    }

                    /**
                     * Compares this property to the provided property and returns
                     * <code>true</code> if they are equal, <code>false</code> otherwise.
                     *
                     * @param { Cesium.Property} [other] The other property.
                     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
                     */

                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this === other || //
                            other instanceof CircleFadeMaterial && Cesium.Property.equals(this._color, other._color);
                    }
                }, {
                    key: "isConstant",
                    get: function get() {
                        return false;
                    }
                }, {
                    key: "definitionChanged",
                    get: function get() {
                        return this._definitionChanged;
                    }
                }]);

                return CircleFadeMaterial;
            }();

            Object.defineProperties(CircleFadeMaterial.prototype, {
                /**
                 * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
                 * @memberof PolylineGlowMaterialProperty.prototype
                 * @type { Cesium.Property}
                 */
                color: Cesium.createPropertyDescriptor('color')
            });

            //静态方法，处理材质
            Cesium.Material.CircleFadeMaterialType = 'CircleFadeMaterial';
            Cesium.Material._materialCache.addMaterial(Cesium.Material.CircleFadeMaterialType, {
                fabric: {
                    type: Cesium.Material.CircleFadeMaterialType,
                    uniforms: {
                        color: new Cesium.Color(1, 0, 0, 1.0),
                        time: 1
                    },
                    source: _CircleFade2.default
                },
                translucent: function translucent() {
                    return true;
                }
            });

            /***/
}),
/* 165 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    material.diffuse = 1.5 * color.rgb;\r\n    vec2 st = materialInput.st;\r\n    float dis = distance(st, vec2(0.5, 0.5));\r\n    float per = fract(time);\r\n    if(dis > per * 0.5){\r\n        //material.alpha = 0.0;\r\n        discard;\r\n    }else {\r\n            material.alpha = color.a  * dis / per / 2.0;\r\n    }\r\n    return material;\r\n}"

            /***/
}),
/* 166 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.CircleScanMaterial = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _CircleScan = __webpack_require__(167);

            var _CircleScan2 = _interopRequireDefault(_CircleScan);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //圆形 扫描效果 材质 
            var CircleScanMaterial = exports.CircleScanMaterial = function () {
                //========== 构造方法 ========== 
                function CircleScanMaterial(options) {
                    _classCallCheck(this, CircleScanMaterial);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                    this._definitionChanged = new Cesium.Event();
                    this._colorSubscription = undefined;

                    this._color = Cesium.defaultValue(options.color, new Cesium.Color(1, 0, 0, 1.0)); //颜色
                    this._scanImg = Cesium.defaultValue(options.url);
                }

                //========== 对外属性 ==========  


                _createClass(CircleScanMaterial, [{
                    key: "getType",


                    //========== 方法 ========== 
                    /**
                     * Gets the {@link Cesium.Material} type at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the type.
                     * @returns {String} The type of material.
                     */
                    value: function getType(time) {
                        return Cesium.Material.EntityScanMaterialType;
                    }

                    /**
                     * Gets the value of the property at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the value.
                     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
                     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
                     */

                }, {
                    key: "getValue",
                    value: function getValue(time, result) {
                        if (!Cesium.defined(result)) {
                            result = {};
                        }
                        result.color = this._color;
                        result.scanImg = this._scanImg;
                        return result;
                    }

                    /**
                     * Compares this property to the provided property and returns
                     * <code>true</code> if they are equal, <code>false</code> otherwise.
                     *
                     * @param { Cesium.Property} [other] The other property.
                     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
                     */

                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this === other || //
                            other instanceof CircleScanMaterial && Cesium.Property.equals(this._color, other._color);
                    }
                }, {
                    key: "isConstant",
                    get: function get() {
                        return false;
                    }
                }, {
                    key: "definitionChanged",
                    get: function get() {
                        return this._definitionChanged;
                    }
                }]);

                return CircleScanMaterial;
            }();

            Object.defineProperties(CircleScanMaterial.prototype, {
                /**
                 * Gets or sets the  Cesium.Property specifying the {@link Cesium.Color} of the line.
                 * @memberof PolylineGlowMaterialProperty.prototype
                 * @type { Cesium.Property}
                 */
                color: Cesium.createPropertyDescriptor('color'),

                scanImg: Cesium.createPropertyDescriptor('scanImg')
            });

            //静态方法，处理材质
            Cesium.Material.EntityScanMaterialType = 'CircleScanMaterial'; /**  渐变的气泡 */
            Cesium.Material._materialCache.addMaterial(Cesium.Material.EntityScanMaterialType, {
                fabric: {
                    type: Cesium.Material.EntityScanMaterialType,
                    uniforms: {
                        color: new Cesium.Color(1, 0, 0, 1.0),
                        scanImg: ""
                    },
                    source: _CircleScan2.default
                },
                translucent: function translucent() {
                    return true;
                }
            });

            /***/
}),
/* 167 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 st = materialInput.st;\r\n    vec4 imgC = texture2D(scanImg,st);\r\n    if(imgC.a>.0){\r\n        material.diffuse = color.rgb;\r\n    }\r\n    material.alpha = imgC.a;\r\n    return material;\r\n}"

            /***/
}),
/* 168 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.GroundLineFlowMaterial = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _GroundLine = __webpack_require__(169);

            var _GroundLine2 = _interopRequireDefault(_GroundLine);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //贴地线线 流动效果 材质
            var GroundLineFlowMaterial = exports.GroundLineFlowMaterial = function GroundLineFlowMaterial(options) {
                _classCallCheck(this, GroundLineFlowMaterial);

                options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);

                var color = Cesium.defaultValue(options.color, new Cesium.Color(1, 0, 0, 1.0));
                var image = options.url || options.image; //必须是png
                var repeat = Cesium.defaultValue(options.repeat, {
                    x: 10,
                    y: 1
                });
                var axisY = Cesium.defaultValue(options.axisY, false);
                var speed = Cesium.defaultValue(options.speed, 1); //速度建议1-10
                return new Cesium.Material({
                    fabric: {
                        uniforms: {
                            color: color,
                            image: image,
                            repeat: repeat,
                            axisY: axisY,
                            speed: speed
                        },
                        source: _GroundLine2.default
                    }
                });
            };

            /***/
}),
/* 169 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput) \r\n{ \r\n    czm_material material = czm_getDefaultMaterial(materialInput); \r\n    vec2 st = repeat * materialInput.st;\r\n    // vec4 color = texture2D(image, materialInput.st/repeat); \r\n    vec4 colorImage = texture2D(image, vec2(fract((axisY?st.t:st.s) - czm_frameNumber*speed/100.0), st.t));\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material; \r\n}"

            /***/
}),
/* 170 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.TextMaterial = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Text = __webpack_require__(171);

            var _Text2 = _interopRequireDefault(_Text);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var defaultColor = new Cesium.Color(0, 0, 0, 0);

            //文字贴图 材质

            var TextMaterial = exports.TextMaterial = function () {
                //========== 构造方法 ========== 
                function TextMaterial(options) {
                    _classCallCheck(this, TextMaterial);

                    options = Cesium.defaultValue(options, Cesium.defaultValue.EMPTY_OBJECT);
                    if (!options.text) return;
                    this._text = options.text;
                    this._textStyles = Cesium.defaultValue(options.textStyles, {
                        font: '50px 楷体',
                        fill: true,
                        fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
                        stroke: true,
                        strokeWidth: 2,
                        strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
                        backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
                        textBaseline: 'top',
                        padding: 40
                    });
                    this._definitionChanged = new Cesium.Event();
                    this._color = undefined;
                    this._colorSubscription = undefined;
                    this.color = Cesium.defaultValue(options.color, defaultColor); //颜色
                    this.repeat = Cesium.defaultValue(options.repeat, new Cesium.Cartesian2(1.0, 1.0));
                    this._img = this._text2Img(this._text, this._textStyles);
                    var _material = getImageMaterial(this._img.src, this.repeat);
                    this._materialType = Cesium.clone(_material.type); //材质类型
                    this._materialImage = Cesium.clone(_material.image); //材质图片
                }

                //========== 对外属性 ==========   


                _createClass(TextMaterial, [{
                    key: "getType",


                    //========== 方法 ========== 

                    /**
                     * Gets the {@link Cesium.Material} type at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the type.
                     * @returns {String} The type of material.
                     */
                    value: function getType(time) {
                        return this._materialType;
                    }

                    /**
                     * Gets the value of the property at the provided time.
                     *
                     * @param {JulianDate} time The time for which to retrieve the value.
                     * @param {Object} [result] The object to store the value into, if omitted, a new instance is created and returned.
                     * @returns {Object} The modified result parameter or a new instance if the result parameter was not supplied.
                     */

                }, {
                    key: "getValue",
                    value: function getValue(time, result) {
                        if (!Cesium.defined(result)) {
                            result = {};
                        }
                        result.color = Cesium.Property.getValueOrClonedDefault(this._color, time, defaultColor, result.color);
                        result.image = this._materialImage;
                        result.repeat = this.repeat;
                        return result;
                    }

                    /**
                     * Compares this property to the provided property and returns
                     * <code>true</code> if they are equal, <code>false</code> otherwise.
                     *
                     * @param {Cesium.Property} [other] The other property.
                     * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.
                     */

                }, {
                    key: "equals",
                    value: function equals(other) {
                        return this === other || //
                            other instanceof TextMaterial && Cesium.Property.equals(this._color, other._color);
                    }
                }, {
                    key: "_text2Img",
                    value: function _text2Img(text, styles) {
                        //opts.type   img/png
                        var canvas = Cesium.writeTextToCanvas(text, styles);
                        if (!canvas) return;
                        this.canvas = canvas;
                        var img = new Image();
                        img.src = canvas.toDataURL("image/png");
                        return img;
                    }
                }, {
                    key: "isConstant",
                    get: function get() {
                        return false;
                    }
                }, {
                    key: "definitionChanged",
                    get: function get() {
                        return this._definitionChanged;
                    }
                }, {
                    key: "text",
                    get: function get() {
                        return this._text;
                    },
                    set: function set(val) {
                        if (!val) return;
                        this._text = val;
                        delete this._img;
                        this._img = this._text2Img(this._text, this._textStyles);
                        var _material = getImageMaterial(this._img.src, this.repeat);
                        this._materialType = Cesium.clone(_material.type); //材质类型
                        this._materialImage = Cesium.clone(_material.image); //材质图片
                    }
                }, {
                    key: "textStyles",
                    get: function get() {
                        return this._textStyles;
                    },
                    set: function set(val) {
                        if (!val) return;
                        delete this._img;
                        this._textStyles = val;
                        this._img = this._text2Img(this._text, this._textStyles);
                        var _material = getImageMaterial(this._img.src, this.repeat);
                        this._materialType = Cesium.clone(_material.type); //材质类型
                        this._materialImage = Cesium.clone(_material.image); //材质图片
                    }
                }]);

                return TextMaterial;
            }();

            Object.defineProperties(TextMaterial.prototype, {
                /**
                 * Gets or sets the Cesium.Property specifying the {@link Cesium.Color} of the line.
                 * @memberof PolylineGlowMaterialProperty.prototype
                 * @type {Cesium.Property}
                 */
                color: Cesium.createPropertyDescriptor('color')
            });

            //静态方法，处理材质
            var cacheIdx = 0;
            var nameEx = "Text";
            function getImageMaterial(imgurl, repeat) {
                cacheIdx++;
                var typeName = nameEx + cacheIdx + "Type";
                var imageName = nameEx + cacheIdx + "Image";

                Cesium.Material[typeName] = typeName;
                Cesium.Material[imageName] = imgurl;

                Cesium.Material._materialCache.addMaterial(Cesium.Material[typeName], {
                    fabric: {
                        type: typeName,
                        uniforms: {
                            color: new Cesium.Color(1, 0, 0, 1.0),
                            image: Cesium.Material[imageName],
                            time: 0,
                            repeat: repeat || new Cesium.Cartesian2(1.0, 1.0)
                        },
                        source: _Text2.default
                    },
                    translucent: function translucent() {
                        return true;
                    }
                });

                return {
                    type: Cesium.Material[typeName],
                    image: Cesium.Material[imageName]
                };
            }

            /***/
}),
/* 171 */
/***/ (function (module, exports) {

            module.exports = "czm_material czm_getMaterial(czm_materialInput materialInput)\r\n{\r\n    czm_material material = czm_getDefaultMaterial(materialInput);\r\n    vec2 mst = fract(materialInput.st + vec2(.0,.0));\r\n    mst = vec2(mst.x,mst.y);\r\n    vec2 st = fract(repeat * mst);\r\n    vec4 colorImage = texture2D(image, st);\r\n    if(color.a == 0.0)\r\n    {\r\n        material.alpha = colorImage.a;\r\n        material.diffuse = colorImage.rgb; \r\n    }\r\n    else\r\n    {\r\n        material.alpha = colorImage.a * color.a;\r\n        material.diffuse = max(color.rgb * material.alpha * 3.0, color.rgb); \r\n    }\r\n    return material;\r\n}"

            /***/
}),
/* 172 */
/***/ (function (module, exports) {

            module.exports = "attribute vec4 position;\r\nattribute vec3 normal;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvoid main()\r\n{\r\n    gl_Position = czm_modelViewProjection * position;\r\n    v_position = vec3(position);\r\n    v_positionWC = (czm_model * position).xyz;\r\n    v_positionEC = (czm_modelView * position).xyz;\r\n    v_normalEC = czm_normal * normal;\r\n}"

            /***/
}),
/* 173 */
/***/ (function (module, exports) {

            module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform float u_type;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    if(u_type == 1.0){\r\n        return getLineColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(czm_ellipsoid ellipsoid, vec3 point)\r\n{\r\n    vec3 scaled = ellipsoid.inverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)-0.00001){\r\n        discard;\r\n    }\r\n\r\n\r\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(ellipsoid, v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, ellipsoid, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    //isOnEllipsoid = false;\r\n    //if((resX >= 0.8 && resX <= 0.81)||(resY >= 0.8 && resY <= 0.81)){\r\n    /*if(false){\r\n        gl_FragColor = vec4(1.0,0.0,0.0,1.0);\r\n    }else{\r\n        gl_FragColor = shade(isOnEllipsoid);\r\n    }\r\n*/\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

            /***/
}),
/* 174 */
/***/ (function (module, exports) {

            module.exports = "uniform vec4 u_intersectionColor;\nuniform float u_intersectionWidth;\nuniform vec4 u_lineColor;\n\nbool inSensorShadow(vec3 coneVertexWC, czm_ellipsoid ellipsoidEC, vec3 pointWC)\n{\n    // Diagonal matrix from the unscaled ellipsoid space to the scaled space.    \n    vec3 D = ellipsoidEC.inverseRadii;\n\n    // Sensor vertex in the scaled ellipsoid space\n    vec3 q = D * coneVertexWC;\n    float qMagnitudeSquared = dot(q, q);\n    float test = qMagnitudeSquared - 1.0;\n    \n    // Sensor vertex to fragment vector in the ellipsoid's scaled space\n    vec3 temp = D * pointWC - q;\n    float d = dot(temp, q);\n    \n    // Behind silhouette plane and inside silhouette cone\n    return (d < -test) && (d / length(temp) < -sqrt(test));\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvec4 getLineColor()\n{\n    return u_lineColor;\n}\n\nvec4 getIntersectionColor()\n{\n    return u_intersectionColor;\n}\n\nfloat getIntersectionWidth()\n{\n    return u_intersectionWidth;\n}\n\nvec2 sensor2dTextureCoordinates(float sensorRadius, vec3 pointMC)\n{\n    // (s, t) both in the range [0, 1]\n    float t = pointMC.z / sensorRadius;\n    float s = 1.0 + (atan(pointMC.y, pointMC.x) / czm_twoPi);\n    s = s - floor(s);\n    \n    return vec2(s, t);\n}\n"

            /***/
}),
/* 175 */
/***/ (function (module, exports) {

            module.exports = "#ifdef GL_OES_standard_derivatives\r\n    #extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nuniform bool u_showIntersection;\r\nuniform bool u_showThroughEllipsoid;\r\n\r\nuniform float u_radius;\r\nuniform float u_xHalfAngle;\r\nuniform float u_yHalfAngle;\r\nuniform float u_normalDirection;\r\nuniform vec4 u_color;\r\n\r\nvarying vec3 v_position;\r\nvarying vec3 v_positionWC;\r\nvarying vec3 v_positionEC;\r\nvarying vec3 v_normalEC;\r\n\r\nvec4 getColor(float sensorRadius, vec3 pointEC)\r\n{\r\n    czm_materialInput materialInput;\r\n\r\n    vec3 pointMC = (czm_inverseModelView * vec4(pointEC, 1.0)).xyz;\r\n    materialInput.st = sensor2dTextureCoordinates(sensorRadius, pointMC);\r\n    materialInput.str = pointMC / sensorRadius;\r\n\r\n    vec3 positionToEyeEC = -v_positionEC;\r\n    materialInput.positionToEyeEC = positionToEyeEC;\r\n\r\n    vec3 normalEC = normalize(v_normalEC);\r\n    materialInput.normalEC = u_normalDirection * normalEC;\r\n\r\n    czm_material material = czm_getMaterial(materialInput);\r\n\r\n    material.diffuse = u_color.rgb;\r\n    material.alpha = u_color.a;\r\n    // czm_lightDirectionEC在cesium1.66开始加入的\r\n    return mix(czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC), vec4(material.diffuse, material.alpha), 0.4);\r\n\r\n}\r\n\r\nbool isOnBoundary(float value, float epsilon)\r\n{\r\n    float width = getIntersectionWidth();\r\n    float tolerance = width * epsilon;\r\n\r\n#ifdef GL_OES_standard_derivatives\r\n    float delta = max(abs(dFdx(value)), abs(dFdy(value)));\r\n    float pixels = width * delta;\r\n    float temp = abs(value);\r\n    // There are a couple things going on here.\r\n    // First we test the value at the current fragment to see if it is within the tolerance.\r\n    // We also want to check if the value of an adjacent pixel is within the tolerance,\r\n    // but we don't want to admit points that are obviously not on the surface.\r\n    // For example, if we are looking for \"value\" to be close to 0, but value is 1 and the adjacent value is 2,\r\n    // then the delta would be 1 and \"temp - delta\" would be \"1 - 1\" which is zero even though neither of\r\n    // the points is close to zero.\r\n    return temp < tolerance && temp < pixels || (delta < 10.0 * tolerance && temp - delta < tolerance && temp < pixels);\r\n#else\r\n    return abs(value) < tolerance;\r\n#endif\r\n}\r\n\r\nvec4 shade(bool isOnBoundary)\r\n{\r\n    if (u_showIntersection && isOnBoundary)\r\n    {\r\n        return getIntersectionColor();\r\n    }\r\n    return getColor(u_radius, v_positionEC);\r\n}\r\n\r\nfloat ellipsoidSurfaceFunction(czm_ellipsoid ellipsoid, vec3 point)\r\n{\r\n    vec3 scaled = ellipsoid.inverseRadii * point;\r\n    return dot(scaled, scaled) - 1.0;\r\n}\r\n\r\nvoid main()\r\n{\r\n    vec3 sensorVertexWC = czm_model[3].xyz;      // (0.0, 0.0, 0.0) in model coordinates\r\n    vec3 sensorVertexEC = czm_modelView[3].xyz;  // (0.0, 0.0, 0.0) in model coordinates\r\n\r\n    //vec3 pixDir = normalize(v_position);\r\n    float positionX = v_position.x;\r\n    float positionY = v_position.y;\r\n    float positionZ = v_position.z;\r\n\r\n    vec3 zDir = vec3(0.0, 0.0, 1.0);\r\n    vec3 lineX = vec3(positionX, 0 ,positionZ);\r\n    vec3 lineY = vec3(0, positionY, positionZ);\r\n    float resX = dot(normalize(lineX), zDir);\r\n    if(resX < cos(u_xHalfAngle) - 0.0001){\r\n        discard;\r\n    }\r\n    float resY = dot(normalize(lineY), zDir);\r\n    if(resY < cos(u_yHalfAngle)- 0.0001){\r\n        discard;\r\n    }\r\n\r\n\r\n    czm_ellipsoid ellipsoid = czm_getWgs84EllipsoidEC();\r\n    float ellipsoidValue = ellipsoidSurfaceFunction(ellipsoid, v_positionWC);\r\n\r\n    // Occluded by the ellipsoid?\r\n\tif (!u_showThroughEllipsoid)\r\n\t{\r\n\t    // Discard if in the ellipsoid\r\n\t    // PERFORMANCE_IDEA: A coarse check for ellipsoid intersection could be done on the CPU first.\r\n\t    if (ellipsoidValue < 0.0)\r\n\t    {\r\n            discard;\r\n\t    }\r\n\r\n\t    // Discard if in the sensor's shadow\r\n\t    if (inSensorShadow(sensorVertexWC, ellipsoid, v_positionWC))\r\n\t    {\r\n\t        discard;\r\n\t    }\r\n    }\r\n\r\n    // Notes: Each surface functions should have an associated tolerance based on the floating point error.\r\n    bool isOnEllipsoid = isOnBoundary(ellipsoidValue, czm_epsilon3);\r\n    gl_FragColor = shade(isOnEllipsoid);\r\n\r\n}"

            /***/
}),
/* 176 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.RectangularSensorVisualizer = undefined;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _RectangularSensorPrimitive = __webpack_require__(73);

            var _removePrimitive = __webpack_require__(177);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            var AssociativeArray = Cesium.AssociativeArray;
            var Cartesian3 = Cesium.Cartesian3;
            var Color = Cesium.Color;
            var defined = Cesium.defined;
            var destroyObject = Cesium.destroyObject;
            var DeveloperError = Cesium.DeveloperError;
            var Matrix3 = Cesium.Matrix3;
            var Matrix4 = Cesium.Matrix4;
            var Quaternion = Cesium.Quaternion;
            var MaterialProperty = Cesium.MaterialProperty;
            var Property = Cesium.Property;

            var matrix3Scratch = new Matrix3();
            // var matrix4Scratch = new Matrix4();
            var cachedPosition = new Cartesian3();
            var cachedGazePosition = new Cartesian3();
            var cachedOrientation = new Quaternion();
            var diffVectorScratch = new Cartesian3();
            var orientationScratch = new Quaternion();

            var RectangularSensorVisualizer = function RectangularSensorVisualizer(scene, entityCollection) {
                // >>includeStart('debug', pragmas.debug);
                if (!defined(scene)) {
                    throw new DeveloperError('scene is required.');
                }
                if (!defined(entityCollection)) {
                    throw new DeveloperError('entityCollection is required.');
                }
                // >>includeEnd('debug');

                entityCollection.collectionChanged.addEventListener(RectangularSensorVisualizer.prototype._onCollectionChanged, this);

                this._scene = scene;
                this._primitives = scene.primitives;
                this._entityCollection = entityCollection;
                this._hash = {};
                this._entitiesToVisualize = new AssociativeArray();

                this._onCollectionChanged(entityCollection, entityCollection.values, [], []);
            };

            /**
             * Updates the primitives created by this visualizer to match their
             * Entity counterpart at the given time.
             *
             * @param {JulianDate} time The time to update to.
             * @returns {Boolean} This function always returns true.
             */
            RectangularSensorVisualizer.prototype.update = function (time) {
                // >>includeStart('debug', pragmas.debug);
                if (!defined(time)) {
                    throw new DeveloperError('time is required.');
                }
                // >>includeEnd('debug');

                var entities = this._entitiesToVisualize.values;
                var hash = this._hash;
                var primitives = this._primitives;

                for (var i = 0, len = entities.length; i < len; i++) {
                    var entity = entities[i];
                    var rectangularSensorGraphics = entity._rectangularSensor;

                    var position;
                    var orientation;
                    var radius;
                    var xHalfAngle;
                    var yHalfAngle;
                    var data = hash[entity.id];
                    var show = entity.isShowing && entity.isAvailable(time) && Property.getValueOrDefault(rectangularSensorGraphics._show, time, true);

                    if (show) {
                        position = Property.getValueOrUndefined(entity._position, time, cachedPosition);
                        orientation = Property.getValueOrUndefined(entity._orientation, time, cachedOrientation);
                        radius = Property.getValueOrUndefined(rectangularSensorGraphics._radius, time);
                        xHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._xHalfAngle, time);
                        yHalfAngle = Property.getValueOrUndefined(rectangularSensorGraphics._yHalfAngle, time);
                        show = defined(position) && defined(xHalfAngle) && defined(yHalfAngle);
                    }

                    if (!show) {
                        // don't bother creating or updating anything else
                        if (defined(data)) {
                            data.primitive.show = false;
                        }
                        continue;
                    }

                    var primitive = defined(data) ? data.primitive : undefined;
                    if (!defined(primitive)) {
                        primitive = new _RectangularSensorPrimitive.RectangularSensorPrimitive();
                        primitive.id = entity;
                        primitives.add(primitive);

                        data = {
                            primitive: primitive,
                            position: undefined,
                            orientation: undefined
                        };
                        hash[entity.id] = data;
                    }

                    var gaze = Property.getValueOrUndefined(rectangularSensorGraphics._gaze, time);
                    if (defined(gaze)) {

                        var targetPosition = Property.getValueOrUndefined(gaze._position, time, cachedGazePosition);

                        if (!defined(position) || !defined(targetPosition)) {
                            continue;
                        }

                        var diffVector = Cartesian3.subtract(position, targetPosition, diffVectorScratch);
                        var rotate = Cartesian3.angleBetween(Cesium.Cartesian3.UNIT_Z, diffVector);
                        var cross = Cartesian3.cross(Cesium.Cartesian3.UNIT_Z, diffVector, diffVectorScratch);
                        var orientation = Quaternion.fromAxisAngle(cross, rotate - Math.PI, orientationScratch);

                        //replace original radius
                        radius = Cartesian3.distance(position, targetPosition);
                        primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
                    } else {
                        if (!Cartesian3.equals(position, data.position) || !Quaternion.equals(orientation, data.orientation)) {
                            if (defined(orientation)) {
                                primitive.modelMatrix = Matrix4.fromRotationTranslation(Matrix3.fromQuaternion(orientation, matrix3Scratch), position, primitive.modelMatrix);
                                data.position = Cartesian3.clone(position, data.position);
                                data.orientation = Quaternion.clone(orientation, data.orientation);
                            } else {
                                primitive.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(position);
                                data.position = Cartesian3.clone(position, data.position);
                            }
                        }
                    }

                    primitive.show = true;
                    primitive.gaze = gaze;
                    primitive.radius = radius;
                    primitive.xHalfAngle = xHalfAngle;
                    primitive.yHalfAngle = yHalfAngle;
                    primitive.lineColor = Property.getValueOrDefault(rectangularSensorGraphics._lineColor, time, Color.WHITE);
                    primitive.showSectorLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorLines, time, true);
                    primitive.showSectorSegmentLines = Property.getValueOrDefault(rectangularSensorGraphics._showSectorSegmentLines, time, true);
                    primitive.showLateralSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showLateralSurfaces, time, true);
                    primitive.material = MaterialProperty.getValue(time, rectangularSensorGraphics._material, primitive.material);
                    primitive.showDomeSurfaces = Property.getValueOrDefault(rectangularSensorGraphics._showDomeSurfaces, time, true);
                    primitive.showDomeLines = Property.getValueOrDefault(rectangularSensorGraphics._showDomeLines, time, true);
                    primitive.showIntersection = Property.getValueOrDefault(rectangularSensorGraphics._showIntersection, time, true);
                    primitive.intersectionColor = Property.getValueOrDefault(rectangularSensorGraphics._intersectionColor, time, Color.WHITE);
                    primitive.intersectionWidth = Property.getValueOrDefault(rectangularSensorGraphics._intersectionWidth, time, 1);
                    primitive.showThroughEllipsoid = Property.getValueOrDefault(rectangularSensorGraphics._showThroughEllipsoid, time, true);
                    primitive.scanPlaneMode = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneMode, time);
                    primitive.scanPlaneColor = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneColor, time, Color.WHITE);
                    primitive.showScanPlane = Property.getValueOrDefault(rectangularSensorGraphics._showScanPlane, time, true);
                    primitive.scanPlaneRate = Property.getValueOrDefault(rectangularSensorGraphics._scanPlaneRate, time, 1);
                }
                return true;
            };

            /**
             * Returns true if this object was destroyed; otherwise, false.
             *
             * @returns {Boolean} True if this object was destroyed; otherwise, false.
             */
            RectangularSensorVisualizer.prototype.isDestroyed = function () {
                return false;
            };

            /**
             * Removes and destroys all primitives created by this instance.
             */
            RectangularSensorVisualizer.prototype.destroy = function () {
                var entities = this._entitiesToVisualize.values;
                var hash = this._hash;
                var primitives = this._primitives;
                for (var i = entities.length - 1; i > -1; i--) {
                    (0, _removePrimitive.removePrimitive)(entities[i], hash, primitives);
                }
                return destroyObject(this);
            };

            /**
             * @private
             */
            RectangularSensorVisualizer.prototype._onCollectionChanged = function (entityCollection, added, removed, changed) {
                var i;
                var entity;
                var entities = this._entitiesToVisualize;
                var hash = this._hash;
                var primitives = this._primitives;

                for (i = added.length - 1; i > -1; i--) {
                    entity = added[i];
                    if (defined(entity._rectangularSensor) && defined(entity._position)) {
                        entities.set(entity.id, entity);
                    }
                }

                for (i = changed.length - 1; i > -1; i--) {
                    entity = changed[i];
                    if (defined(entity._rectangularSensor) && defined(entity._position)) {
                        entities.set(entity.id, entity);
                    } else {
                        (0, _removePrimitive.removePrimitive)(entity, hash, primitives);
                        entities.remove(entity.id);
                    }
                }

                for (i = removed.length - 1; i > -1; i--) {
                    entity = removed[i];
                    (0, _removePrimitive.removePrimitive)(entity, hash, primitives);
                    entities.remove(entity.id);
                }
            };

            exports.RectangularSensorVisualizer = RectangularSensorVisualizer;

            /***/
}),
/* 177 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.removePrimitive = removePrimitive;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function removePrimitive(entity, hash, primitives) {
                var data = hash[entity.id];
                if (Cesium.defined(data)) {
                    var primitive = data.primitive;
                    try {
                        primitives.remove(primitive);
                    } catch (e) { }
                    if (primitive.isDestroyed && !primitive.isDestroyed()) {
                        primitive.destroy();
                    }
                    delete hash[entity.id];
                }
            };

            /***/
}),
/* 178 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DivPoint = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _zepto = __webpack_require__(6);

            var _point = __webpack_require__(2);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //div点 类
            var DivPoint = exports.DivPoint = function () {
                //========== 构造方法 ========== 
                function DivPoint(viewer, opts) {
                    _classCallCheck(this, DivPoint);

                    this.viewer = viewer;

                    this.position = opts.position;
                    this.anchor = opts.anchor;

                    //兼容历史写法
                    if (opts.visibleDistanceMin || opts.visibleDistanceMax) {
                        opts.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(opts.visibleDistanceMin || 0, opts.visibleDistanceMax || 100000);
                    }

                    //按视距距离显示
                    this._distanceDisplayCondition = opts.distanceDisplayCondition;
                    this._heightReference = Cesium.defaultValue(opts.heightReference, Cesium.HeightReference.NONE);

                    this.opts = opts;
                    this.opts.css_transform_origin = Cesium.defaultValue(this.opts.css_transform_origin, 'left bottom 0');

                    this._depthTest = true;

                    //添加html
                    this._dom = (0, _zepto.zepto)('<div>' + opts.html + '</div>');
                    this._dom.css({
                        position: 'absolute',
                        left: '0',
                        top: '0'
                    });
                    this._dom.appendTo("#" + viewer._container.id);

                    this.visible = Cesium.defaultValue(opts.visible, true);

                    var that = this;
                    if (opts.click || opts.popup) {
                        this._dom.click(function (e) {
                            if (opts.popup) viewer.mapv.popup.show(opts, that.position);
                            if (opts.click) opts.click(opts, that, e);
                        });
                    } else if (opts.tooltip) {
                        this._dom.mousemove(function (e) {
                            //移入
                            viewer.mapv.tooltip.show(opts, that.position);
                        });
                        this._dom.mouseout(function (e) {
                            //移出
                            viewer.mapv.tooltip.close();
                        });
                    } else {
                        /*加上这个css后鼠标可以穿透，但是无法触发单击等鼠标事件*/
                        this._dom.css({
                            'pointer-events': 'none'
                        });
                    }

                    //移动事件
                    viewer.scene.postRender.addEventListener(this.updateViewPoint, this);
                }

                //========== 对外属性 ==========  


                _createClass(DivPoint, [{
                    key: 'updateViewPoint',


                    //========== 方法 ========== 
                    value: function updateViewPoint() {
                        if (!this._visible) return false;

                        var scene = this.viewer.scene;
                        var camera = this.viewer.camera;

                        var _position;
                        if (this._heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                            _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position));
                        } else if (this._heightReference == Cesium.HeightReference.RELATIVE_TO_GROUND) {
                            _position = (0, _point.setPositionSurfaceHeight)(this.viewer, (0, _point.getPositionValue)(this.position), { relativeHeight: true });
                        } else {
                            _position = (0, _point.getPositionValue)(this.position);
                        }

                        if (!Cesium.defined(_position)) {
                            this._dom.hide();
                            return false;
                        }

                        //如果视角和位置都没有变化，直接返回
                        var _thiscache = _position.x + '=' + _position.y + '-' + _position.z + '-' + camera.position.x + '=' + camera.position.y + '-' + camera.position.z + '-' + camera.heading + '-' + camera.pitch + '-' + camera.roll;
                        if (_thiscache == this._camera_cache) {
                            return true;
                        }
                        this._camera_cache = _thiscache;
                        //如果视角和位置都没有变化，直接返回


                        var point = Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, _position);

                        var camera_distance;
                        if (scene.mode === Cesium.SceneMode.SCENE3D) camera_distance = Cesium.Cartesian3.distance(_position, camera.position); else camera_distance = camera.positionCartographic.height;

                        if (point == null || this._distanceDisplayCondition && (this._distanceDisplayCondition.near > camera_distance || this._distanceDisplayCondition.far < camera_distance)) {
                            if (this._dom.css("display") == "block") {
                                //如果node是显示则隐藏 
                                this._dom.hide();
                            }
                            return false;
                        }

                        //判断是否在球的背面
                        if (this._depthTest && scene.mode === Cesium.SceneMode.SCENE3D) {
                            //三维模式下
                            var pickRay = scene.camera.getPickRay(point);
                            var cartesianNew = scene.globe.pick(pickRay, scene);
                            if (cartesianNew) {
                                var len = Cesium.Cartesian3.distance(_position, cartesianNew);
                                if (len > 1000000) {
                                    if (this._dom.css("display") == "block") {
                                        //如果node是显示则隐藏 
                                        this._dom.hide();
                                    }
                                    return false;
                                }
                            }
                        }
                        //判断是否在球的背面

                        if (this._dom.css("display") != "block") {
                            //如果node是隐藏的则显示node元素 
                            this._dom.show();
                        }

                        //求xy位置
                        var height = this._dom.height(); //需要是显示状态，才有值
                        var width = this._dom.width();
                        var x = point.x;
                        var y = point.y - height;

                        if (this.anchor) {
                            if (this.anchor[0] == "center") x -= width / 2; else x += this.anchor[0];

                            if (this.anchor[1] == "center") y += height / 2; else y += this.anchor[1];
                        } else {
                            //默认定位为div中心位置
                            x -= width / 2;
                            y += height / 2;
                        }

                        //求缩放比例
                        var scale = 1;
                        if (this.opts.scaleByDistance) {
                            var sc = this.opts.scaleByDistance; //Cesium.NearFarScalar
                            if (camera_distance <= sc.near) {
                                scale = sc.nearValue;
                            } else if (camera_distance > sc.near && camera_distance < sc.far) {
                                // near 10000, nearValue  1.0,, far 100000, farValue  0.1 
                                scale = sc.nearValue + (sc.farValue - sc.nearValue) * (camera_distance - sc.near) / (sc.far - sc.near);
                            } else {
                                scale = sc.farValue;
                            }
                        }

                        var css_transform = 'matrix(' + scale + ',0,0,' + scale + ',' + x + ',' + y + ')';
                        var css_transform_origin = this.opts.css_transform_origin;

                        this._dom.css({
                            'transform': css_transform,
                            'transform-origin': css_transform_origin,
                            '-ms-transform': css_transform, /* IE 9 */
                            '-ms-transform-origin': css_transform_origin,
                            '-webkit-transform': css_transform, /* Safari 和 Chrome */
                            '-webkit-transform-origin': css_transform_origin,
                            '-moz-transform': css_transform, /* Firefox */
                            '-moz-transform-origin': css_transform_origin,
                            '-o-transform': css_transform, /* Opera */
                            '-o-transform-origin': css_transform_origin
                        });

                        if (this.opts.postRender) {
                            //回调方法
                            this.opts.postRender({
                                x: x,
                                y: y,
                                height: height,
                                width: width,
                                distance: camera_distance
                            });
                        }
                    }
                }, {
                    key: 'setVisible',
                    value: function setVisible(val) {
                        this._visible = val;
                        if (val) this._dom.show(); else this._dom.hide();
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.viewer.scene.postRender.removeEventListener(this.updateViewPoint, this);
                        this._dom.remove();

                        this._dom = null;
                        this.position = null;
                        this.anchor = null;
                        this.viewer = null;
                    }
                }, {
                    key: 'dom',
                    get: function get() {
                        return this._dom;
                    }

                    //是否显示

                }, {
                    key: 'visible',
                    get: function get() {
                        return this._visible;
                    },
                    set: function set(val) {
                        this._visible = val;
                        this.setVisible(val);
                    }

                    //是否打开深度判断（true时判断是否在球背面）

                }, {
                    key: 'depthTest',
                    get: function get() {
                        return this._depthTest;
                    },
                    set: function set(value) {
                        this._depthTest = value;
                    }
                }, {
                    key: 'html',
                    get: function get() {
                        return this._dom.html();
                    },
                    set: function set(value) {
                        this._dom.html(value);
                    }
                }]);

                return DivPoint;
            }();

            /***/
}),
/* 179 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.DynamicRiver = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _util = __webpack_require__(1);

            var _util2 = __webpack_require__(180);

            var _Draw = __webpack_require__(4);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //动态河流、公路
            var DynamicRiver = exports.DynamicRiver = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function DynamicRiver(viewer, options) {
                    _classCallCheck(this, DynamicRiver);

                    if (!viewer) return;
                    this.viewer = viewer;
                    options = options || {};
                    this.positions = Cesium.defaultValue(options.positions, null);

                    this._image = Cesium.defaultValue(options.image, null); //贴图路径
                    this._flipY = Cesium.defaultValue(options.flipY, false); //uv交换（图片横竖切换）
                    this._width = Cesium.defaultValue(options.width, 10); //宽度
                    this._height = Cesium.defaultValue(options.height, 0); //拔高数值
                    this._alpha = Cesium.defaultValue(options.alpha, 0.5); //透明度
                    this._speed = Cesium.defaultValue(options.speed, 1.0); //流动速度

                    this._move = Cesium.defaultValue(options.move, true); //是否开启流动效果
                    this._moveDir = Cesium.defaultValue(options.moveDir, true); //设置流动方向
                    this._moveVar = Cesium.defaultValue(options.moveVar, new Cesium.Cartesian3(50, 1, 100)); //流动动画参数，不建议调整该参数

                    this.callBack = options.callBack;

                    this.init();
                }

                //========== 对外属性 ==========  


                _createClass(DynamicRiver, [{
                    key: "init",


                    //========== 方法 ========== 

                    value: function init() {
                        this.prepareVertex();
                        if (!this.sideRes) return;

                        this.material = this.prepareMaterial();
                        this.riverPrimitive && this.viewer.scene.primitives.remove(this.riverPrimitive);
                        this.riverPrimitive = this.createPrimitive();
                        this.viewer.scene.primitives.add(this.riverPrimitive);
                        this.callBack && this.callBack();
                    }
                }, {
                    key: "prepareVertex",
                    value: function prepareVertex() {
                        if (!(0, _util.isArray)(this.positions) || !this.positions.length) return;
                        this.sideRes = (0, _util2.Lines2Plane)(this.positions, this.width, this.height);
                    }
                }, {
                    key: "setPositions",
                    value: function setPositions(positions) {
                        this.positions = positions;
                        this.init();
                    }
                }, {
                    key: "resetPos",
                    value: function resetPos() {
                        //更换线路数据
                        this.sideRes = (0, _util2.Lines2Plane)(this.positions, this.width, this.height);
                        if (!this.sideRes) return;
                        this.material = this.prepareMaterial();
                        this.riverPrimitive && this.viewer.scene.primitives.remove(this.riverPrimitive);
                        this.riverPrimitive = this.createPrimitive();
                        this.viewer.scene.primitives.add(this.riverPrimitive);
                    }
                }, {
                    key: "drawLines",
                    value: function drawLines(style) {
                        if (!this.drawControl) {
                            this.drawControl = new _Draw.Draw(viewer, {
                                hasEdit: false,
                                removeScreenSpaceEvent: true
                            });
                        }
                        var control = this.drawControl;

                        var that = this;
                        control.startDraw({
                            type: "polyline",
                            style: style || {
                                color: "#55ff33",
                                width: 3,
                                clampToGround: true
                            },
                            success: function success(entity) {
                                var positions = that.drawControl.getPositions(entity);
                                that.positions = positions;
                                that.setPositions(positions);
                                that.drawControl.deleteAll();
                            }
                        });
                    }
                }, {
                    key: "prepareMaterial",
                    value: function prepareMaterial() {
                        if (this.image) {
                            var material = new Cesium.Material({
                                fabric: {
                                    uniforms: {
                                        image: this.image,
                                        alpha: this.alpha,
                                        moveVar: this.moveVar,
                                        reflux: this.moveDir ? -1 : 1,
                                        speed: this.speed,
                                        move: this.move,
                                        flipY: this.flipY
                                    },
                                    source: "czm_material czm_getMaterial(czm_materialInput materialInput) { \n                        czm_material material = czm_getDefaultMaterial(materialInput); \n                        vec2 st = materialInput.st;\n                        if(move){\n                            float r = sqrt((st.x-0.8)*(st.x-0.8) + (st.y-0.8)*(st.y-0.8));\n                            float r2 = sqrt((st.x-0.2)*(st.x-0.2) + (st.y-0.2)*(st.y-0.2));\n                            float z = cos(moveVar.x*r + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n                            float z2 = cos(moveVar.x*r2 + czm_frameNumber/100.0*moveVar.y)/moveVar.z;\n                            st += sqrt(z*z+z2*z2);\n                            st.s += reflux * czm_frameNumber/1000.0 * speed;\n                            st.s = mod(st.s,1.0);\n                        }\n                        if(flipY){\n                            st = vec2(st.t,st.s);\n                        }\n                        vec4 colorImage = texture2D(image, st);\n                        material.alpha = alpha;\n                        material.diffuse = colorImage.rgb; \n                        return material; \n                    }"
                                }
                            });
                            return material;
                        } else {
                            var material = Cesium.Material.fromType('Color');
                            material.uniforms.color = new Cesium.Color(0.0, 1.0, 0.0, this.alpha);
                            return material;
                        }
                    }
                }, {
                    key: "createPrimitive",
                    value: function createPrimitive() {
                        //创建图元
                        var sides = this.sideRes;
                        var positions = new Float64Array(sides.vertexs);
                        var attributes = new Cesium.GeometryAttributes();
                        attributes.position = new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                            componentsPerAttribute: 3,
                            values: positions
                        });
                        attributes.st = new Cesium.GeometryAttribute({
                            componentDatatype: Cesium.ComponentDatatype.FLOAT,
                            componentsPerAttribute: 2,
                            values: sides.uvs
                        });
                        var geometry = new Cesium.Geometry({
                            attributes: attributes,
                            indices: sides.indexs,
                            primitiveType: Cesium.PrimitiveType.TRIANGLES,
                            boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
                        });

                        var instance = new Cesium.GeometryInstance({
                            geometry: geometry
                        });
                        var renderState = new Cesium.RenderState();
                        renderState.depthTest.enabled = true;
                        var ppp = new Cesium.Primitive({
                            geometryInstances: instance,
                            appearance: new Cesium.Appearance({
                                material: this.material,
                                renderState: renderState,
                                vertexShaderSource: "attribute vec3 position3DHigh;\n\
                attribute vec3 position3DLow;\n\
                attribute vec2 st;\n\
                attribute float batchId;\n\
                \n\
                varying vec3 v_positionMC;\n\
                varying vec3 v_positionEC;\n\
                varying vec2 v_st;\n\
                \n\
                void main()\n\
                {\n\
                    vec4 p = czm_computePosition();\n\
                \n\
                    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\n\
                    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\n\
                    v_st = st;\n\
                \n\
                    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n\
                }\n\
                ",
                                fragmentShaderSource: "varying vec3 v_positionMC;\n\
                varying vec3 v_positionEC;\n\
                varying vec2 v_st;\n\
                \n\
                void main()\n\
                {\n\
                    czm_materialInput materialInput;\n\
                \n\
                    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n\
                #ifdef FACE_FORWARD\n\
                    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
                #endif\n\
                \n\
                    materialInput.s = v_st.s;\n\
                    materialInput.st = v_st;\n\
                    materialInput.str = vec3(v_st, 0.0);\n\
                \n\
                    // Convert tangent space material normal to eye space\n\
                    materialInput.normalEC = normalEC;\n\
                    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\
                \n\
                    // Convert view vector to world space\n\
                    vec3 positionToEyeEC = -v_positionEC;\n\
                    materialInput.positionToEyeEC = positionToEyeEC;\n\
                \n\
                    czm_material material = czm_getMaterial(materialInput);\n\
                \n\
                #ifdef FLAT\n\
                    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
                #else\n\
                    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n\
                #endif\n\
                }\n\
                " //czm_lightDirectionEC在cesium1.66开始加入的
                            })
                        });
                        return ppp;
                    }
                }, {
                    key: "offsetHeight",
                    value: function offsetHeight(height, time) {
                        this.startDH(height, time);
                    }
                }, {
                    key: "startDH",
                    value: function startDH(height, time) {
                        if (!height || !time || !this.riverPrimitive) return;
                        var that = this;
                        var currH = 0;
                        var avgF = 20; //平均每帧20毫秒，即每秒50帧；
                        var avgH = height / (time * avgF);

                        var selfV = this.sideRes.self;
                        var totalN = new Cesium.Cartesian3();
                        for (var i = 0, len = selfV.length; i < len; i++) {
                            //求平均的法线
                            var currN = Cesium.Cartesian3.normalize(selfV[i], new Cesium.Cartesian3());
                            Cesium.Cartesian3.add(totalN, currN, totalN);
                        }
                        Cesium.Cartesian3.normalize(totalN, totalN);

                        var initM = Cesium.clone(this.riverPrimitive.modelMatrix);

                        this.dhEvent = function () {
                            if (Math.abs(currH) <= Math.abs(height)) {
                                //可以升高，可以降低，height可以为负值
                                var currNor = Cesium.Cartesian3.multiplyByScalar(totalN, currH, new Cesium.Cartesian3());
                                that.riverPrimitive.modelMatrix = Cesium.Matrix4.multiplyByTranslation(initM, currNor, new Cesium.Matrix4());
                            } else {
                                that.viewer.clock.onTick.removeEventListener(that.dhEvent);
                            }
                            currH += avgH;
                        };
                        this.viewer.clock.onTick.addEventListener(this.dhEvent);
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.primitives.remove(this.riverPrimitive);
                        if (this.drawControl) {
                            this.drawControl.destroy();
                            delete this.drawControl;
                        }
                        this.material.destroy();
                        delete this.material;
                        delete this.image;
                        delete this.position;
                        delete this.width;
                        delete this.height;
                        delete this.alpha;
                        delete this.speed;

                        delete this._width;
                        delete this._height;
                        delete this._alpha;
                        delete this._moveDir;
                        delete this._speed;
                        delete this.oldDepthTest;
                        delete this.sideRes;
                    }
                }, {
                    key: "width",
                    get: function get() {
                        return this._width;
                    },
                    set: function set(val) {
                        this._width = Number(val) || 1;
                        this.resetPos();
                    }
                }, {
                    key: "height",
                    get: function get() {
                        return this._height;
                    },
                    set: function set(val) {
                        this._height = Number(val);
                        this.resetPos();
                    }
                }, {
                    key: "alpha",
                    get: function get() {
                        return this._alpha;
                    },
                    set: function set(val) {
                        this._alpha = Number(val);
                        this.material.uniforms.alpha = this._alpha;
                    }
                }, {
                    key: "moveDir",
                    get: function get() {
                        return this._moveDir;
                    },
                    set: function set(val) {
                        this._moveDir = Boolean(val);
                        this.material.uniforms.reflux = this._moveDir ? -1 : 1;
                    }
                }, {
                    key: "speed",
                    get: function get() {
                        return this._speed;
                    },
                    set: function set(val) {
                        this._speed = Number(val) || 1;
                        this.material.uniforms.speed = this._speed;
                    }
                }, {
                    key: "image",
                    get: function get() {
                        return this._image;
                    },
                    set: function set(str) {
                        this._image = str;
                        this.material.uniforms.image = this._image;
                    }
                }, {
                    key: "move",
                    get: function get() {
                        return this._move;
                    },
                    set: function set(val) {
                        this._move = Boolean(val);
                        this.material.uniforms.move = this._move;
                    }
                }, {
                    key: "flipY",
                    get: function get() {
                        return this._flipY;
                    },
                    set: function set(val) {
                        this._flipY = Boolean(val);
                        this.material.uniforms.flipY = this._flipY;
                    }
                }, {
                    key: "moveVar",
                    get: function get() {
                        return this._moveVar;
                    },
                    set: function set(val) {
                        this._moveVar = val;
                        this.material.uniforms.moveVar = this._moveVar;
                    }
                }]);

                return DynamicRiver;
            }();

            /***/
}),
/* 180 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Lines2Plane = Lines2Plane;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function Lines2Plane(lineArr, width, height) {
                if (!lineArr || lineArr.length <= 1 || !width || width == 0) {
                    console.log("请确认参数符合规则：数组长度大于1，宽高不能为0！");
                    return;
                }
                var len = lineArr.length;
                var leftPots = [];
                var rightPots = [];
                var halfW = width / 2.0;
                for (var i = 0; i < len; i++) {
                    var prevP = void 0;
                    var currP = void 0;
                    var nextP = void 0;
                    var leftPot = void 0;
                    var rightPot = void 0;
                    if (i == 0) {
                        prevP = lineArr[i];
                        currP = lineArr[i];
                        nextP = lineArr[i + 1];
                    } else if (i == len - 1) {
                        prevP = lineArr[i - 1];
                        currP = lineArr[i];
                        nextP = lineArr[i - 1];
                    } else {
                        prevP = lineArr[i - 1];
                        currP = lineArr[i];
                        nextP = lineArr[i + 1];
                    }

                    if (height != 0) {
                        prevP = RaisePoint(prevP, height);
                        currP = RaisePoint(currP, height);
                        nextP = RaisePoint(nextP, height);
                    }

                    if (prevP && currP && nextP) {
                        var sides = GetSides(currP, nextP, halfW);
                        leftPot = sides.left;
                        rightPot = sides.right;

                        if (i == 0) {
                            leftPots.push(leftPot);
                            rightPots.push(rightPot);
                            leftPots.push(leftPot);
                            rightPots.push(rightPot);
                            continue;
                        } else {
                            if (i < len - 1) {
                                leftPots.push(leftPot);
                                rightPots.push(rightPot);
                            } else {
                                leftPots.push(rightPot);
                                rightPots.push(leftPot);
                                leftPots.push(rightPot);
                                rightPots.push(leftPot);
                                continue;
                            }
                        }

                        sides = GetSides(currP, prevP, halfW);
                        leftPot = sides.left;
                        rightPot = sides.right;
                        leftPots.push(rightPot);
                        rightPots.push(leftPot);
                    }
                }
                // return {
                //     left:leftPots,
                //     right:rightPots,
                //     self:lineArr
                // }

                var leftPotsRes = [];
                var rightPotsRes = [];
                if (leftPots.length == len * 2) {
                    for (var _i = 0; _i < len; _i++) {
                        var CurrP = lineArr[_i];

                        var lf1 = leftPots[_i * 2 + 0];
                        var lf2 = leftPots[_i * 2 + 1];
                        var dir1 = Cesium.Cartesian3.subtract(lf1, CurrP, new Cesium.Cartesian3());
                        var dir2 = Cesium.Cartesian3.subtract(lf2, CurrP, new Cesium.Cartesian3());
                        var avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
                        var avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
                        leftPotsRes.push(Cesium.clone(avgPot));

                        var rg1 = rightPots[_i * 2 + 0];
                        var rg2 = rightPots[_i * 2 + 1];
                        dir1 = Cesium.Cartesian3.subtract(rg1, CurrP, new Cesium.Cartesian3());
                        dir2 = Cesium.Cartesian3.subtract(rg2, CurrP, new Cesium.Cartesian3());
                        avgDir = Cesium.Cartesian3.add(dir1, dir2, new Cesium.Cartesian3());
                        avgPot = Cesium.Cartesian3.add(CurrP, avgDir, new Cesium.Cartesian3());
                        rightPotsRes.push(Cesium.clone(avgPot));
                    }
                } else {
                    console.log("计算左右侧点出问题！");
                    return;
                }

                var uvs = [];
                var vertexs = [];
                var vertexsH = [];
                var vertexsL = [];
                var indexs = [];

                //先记录右边点，后记录左边点、记录2遍为了分离UV
                for (var _i2 = 0; _i2 < len; _i2++) {
                    var encodeRes = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i2]);
                    vertexs.push(rightPotsRes[_i2].x);
                    vertexs.push(rightPotsRes[_i2].y);
                    vertexs.push(rightPotsRes[_i2].z);

                    vertexsH.push(encodeRes.high.x);
                    vertexsH.push(encodeRes.high.y);
                    vertexsH.push(encodeRes.high.z);

                    vertexsL.push(encodeRes.low.x);
                    vertexsL.push(encodeRes.low.y);
                    vertexsL.push(encodeRes.low.z);

                    uvs.push(1, 1);

                    //记录索引以及UV
                    if (_i2 < len - 1) {
                        indexs.push(_i2 + len * 2);
                        indexs.push(_i2 + 1);
                        indexs.push(_i2 + 1 + len);

                        indexs.push(_i2 + len * 2);
                        indexs.push(_i2 + 1 + len);
                        indexs.push(len + _i2 + len * 2);
                    }
                }
                for (var _i3 = 0; _i3 < len; _i3++) {
                    var _encodeRes = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i3]);
                    vertexs.push(leftPotsRes[_i3].x);
                    vertexs.push(leftPotsRes[_i3].y);
                    vertexs.push(leftPotsRes[_i3].z);

                    vertexsH.push(_encodeRes.high.x);
                    vertexsH.push(_encodeRes.high.y);
                    vertexsH.push(_encodeRes.high.z);

                    vertexsL.push(_encodeRes.low.x);
                    vertexsL.push(_encodeRes.low.y);
                    vertexsL.push(_encodeRes.low.z);

                    uvs.push(1, 0);
                }

                for (var _i4 = 0; _i4 < len; _i4++) {
                    var _encodeRes2 = Cesium.EncodedCartesian3.fromCartesian(rightPotsRes[_i4]);
                    vertexs.push(rightPotsRes[_i4].x);
                    vertexs.push(rightPotsRes[_i4].y);
                    vertexs.push(rightPotsRes[_i4].z);

                    vertexsH.push(_encodeRes2.high.x);
                    vertexsH.push(_encodeRes2.high.y);
                    vertexsH.push(_encodeRes2.high.z);

                    vertexsL.push(_encodeRes2.low.x);
                    vertexsL.push(_encodeRes2.low.y);
                    vertexsL.push(_encodeRes2.low.z);

                    uvs.push(0, 1);

                    // if(i<len-1){
                    //     // indexs.push(i + len*2);
                    //     // indexs.push(i+1 + len*2);
                    //     // indexs.push(i+1+len + len*2);

                    //     // indexs.push(i + len*2);
                    //     // indexs.push(i+1+len + len*2);
                    //     // indexs.push(len+i + len*2);
                    // }
                }
                for (var _i5 = 0; _i5 < len; _i5++) {
                    var _encodeRes3 = Cesium.EncodedCartesian3.fromCartesian(leftPotsRes[_i5]);
                    vertexs.push(leftPotsRes[_i5].x);
                    vertexs.push(leftPotsRes[_i5].y);
                    vertexs.push(leftPotsRes[_i5].z);

                    vertexsH.push(_encodeRes3.high.x);
                    vertexsH.push(_encodeRes3.high.y);
                    vertexsH.push(_encodeRes3.high.z);

                    vertexsL.push(_encodeRes3.low.x);
                    vertexsL.push(_encodeRes3.low.y);
                    vertexsL.push(_encodeRes3.low.z);

                    uvs.push(0, 0);
                }

                return {
                    left: leftPotsRes,
                    right: rightPotsRes,
                    self: lineArr,
                    vertexs: new Float32Array(vertexs),
                    vertexsH: new Float32Array(vertexsH),
                    vertexsL: new Float32Array(vertexsL),
                    indexs: new Uint16Array(indexs),
                    uvs: new Float32Array(uvs)
                };
            }

            function RaisePoint(pot, height) {
                if (!(pot instanceof Cesium.Cartesian3)) {
                    console.log("请确认点是Cartesian3类型！");
                    return;
                }
                if (!height || height == 0) {
                    console.log("请确认高度是非零数值！");
                    return;
                }
                var dir = Cesium.Cartesian3.normalize(pot, new Cesium.Cartesian3());
                var ray = new Cesium.Ray(pot, dir);
                return Cesium.Ray.getPoint(ray, height);
            }

            function GetSides(firstP, sceondP, halfW) {
                var dir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(sceondP, firstP, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                var nor = Cesium.Cartesian3.normalize(firstP, new Cesium.Cartesian3());
                var leftDir = Cesium.Cartesian3.cross(nor, dir, new Cesium.Cartesian3());
                var rightDir = Cesium.Cartesian3.cross(dir, nor, new Cesium.Cartesian3());
                var leftray = new Cesium.Ray(firstP, leftDir);
                var rightray = new Cesium.Ray(firstP, rightDir);
                var leftPot = Cesium.Ray.getPoint(leftray, halfW);
                var rightPot = Cesium.Ray.getPoint(rightray, halfW);
                return {
                    left: leftPot,
                    right: rightPot
                };
            }

            /***/
}),
/* 181 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.createWaterPrimitive = createWaterPrimitive;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            // 水面shader
            function getWaterShader() {
                return 'varying vec3 v_positionMC;\n\
            varying vec3 v_positionEC;\n\
            varying vec2 v_st;\n\
            \n\
            void main()\n\
            {\n\
                czm_materialInput materialInput;\n\
                vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\n\
            #ifdef FACE_FORWARD\n\
                normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n\
            #endif\n\
                materialInput.s = v_st.s;\n\
                materialInput.st = v_st;\n\
                materialInput.str = vec3(v_st, 0.0);\n\
                materialInput.normalEC = normalEC;\n\
                materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\n\
                vec3 positionToEyeEC = -v_positionEC;\n\
                materialInput.positionToEyeEC = positionToEyeEC;\n\
                czm_material material = czm_getMaterial(materialInput);\n\
            #ifdef FLAT\n\
                gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n\
            #else\n\
                gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n\
                gl_FragColor.a = 0.5;\n\
            #endif\n\
            }'; //czm_lightDirectionEC在cesium1.66开始加入的
            }

            //创建水面Primitive
            //水域相关场景效果
            function createWaterPrimitive(polygon, opts) {
                var primitive = new Cesium.Primitive({
                    geometryInstances: new Cesium.GeometryInstance({
                        geometry: polygon,
                        id: opts.id || 'water'
                    }),
                    appearance: new Cesium.EllipsoidSurfaceAppearance({
                        aboveGround: false,
                        material: new Cesium.Material({
                            fabric: {
                                type: 'Water',
                                uniforms: {
                                    normalMap: opts.normalMap, //水正常扰动的法线图。
                                    frequency: opts.frequency || 8000.0, //控制波数的数字。
                                    animationSpeed: opts.animationSpeed || 0.03, //控制水的动画速度的数字。
                                    amplitude: opts.amplitude || 5.0, //控制水波振幅的数字。
                                    specularIntensity: opts.specularIntensity || 0.8, //控制镜面反射强度的数字。  
                                    baseWaterColor: new Cesium.Color.fromCssColorString(opts.baseWaterColor || "#123e59"), //rgba颜色对象基础颜色的水。#00ffff,#00baff,#006ab4
                                    blendColor: new Cesium.Color.fromCssColorString(opts.blendColor || "#123e59") //从水中混合到非水域时使用的rgba颜色对象。  
                                }
                            }
                        }),
                        fragmentShaderSource: getWaterShader()
                    }),
                    show: true
                });
                return primitive;
            }

            /***/
}),
/* 182 */
/***/ (function (module, exports) {

            module.exports = "uniform sampler2D colorTexture;\r\nvarying vec2 v_textureCoordinates;\r\n\r\nfloat hash(float x){\r\n    return fract(sin(x*133.3)*13.13);\r\n}\r\n\r\nvoid main(void){ \r\n    float time = czm_frameNumber / 240.0;\r\n    vec2 resolution = czm_viewport.zw;\r\n\r\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\r\n    vec3 c=vec3(.6,.7,.8);\r\n\r\n    float a=-.4;\r\n    float si=sin(a),co=cos(a);\r\n    uv*=mat2(co,-si,si,co);\r\n    uv*=length(uv+vec2(0,4.9))*.3+1.;\r\n\r\n    float v=1.-sin(hash(floor(uv.x*100.))*2.);\r\n    float b=clamp(abs(sin(20.*time*v+uv.y*(5./(2.+v))))-.95,0.,1.)*20.;\r\n    c*=v*b; \r\n\r\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(c,1), 0.5);  \r\n}\r\n                        "

            /***/
}),
/* 183 */
/***/ (function (module, exports) {

            module.exports = "uniform sampler2D colorTexture;\r\nvarying vec2 v_textureCoordinates;\r\n\r\nfloat snow(vec2 uv,float scale){\r\n    float time = czm_frameNumber / 60.0;\r\n    float w=smoothstep(1.,0.,-uv.y*(scale/10.));if(w<.1)return 0.;\r\n    uv+=time/scale;uv.y+=time*2./scale;uv.x+=sin(uv.y+time*.5)/scale;\r\n    uv*=scale;vec2 s=floor(uv),f=fract(uv),p;float k=3.,d;\r\n    p=.5+.35*sin(11.*fract(sin((s+p+scale)*mat2(7,3,6,5))*5.))-f;d=length(p);k=min(d,k);\r\n    k=smoothstep(0.,k,sin(f.x+f.y)*0.01);\r\n    return k*w;\r\n}\r\n\r\nvoid main(void){\r\n    vec2 resolution = czm_viewport.zw;\r\n    vec2 uv=(gl_FragCoord.xy*2.-resolution.xy)/min(resolution.x,resolution.y);\r\n    vec3 finalColor=vec3(0);\r\n    float c = 0.0;\r\n    // c+=snow(uv,30.)*.0;\r\n    // c+=snow(uv,20.)*.0;\r\n    // c+=snow(uv,15.)*.0;\r\n    c+=snow(uv,10.);\r\n    c+=snow(uv,8.);\r\n    c+=snow(uv,6.);\r\n    c+=snow(uv,5.);\r\n    finalColor=(vec3(c)); \r\n    gl_FragColor = mix(texture2D(colorTexture, v_textureCoordinates), vec4(finalColor,1), 0.5); \r\n\r\n}"

            /***/
}),
/* 184 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.FogEffect = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //原理：根据深度图的深度值，对片元进行不同程度的模糊

            // 场景雾效果
            var FogEffect = exports.FogEffect = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function FogEffect(viewer, options) {
                    _classCallCheck(this, FogEffect);

                    this.viewer = viewer;

                    options = options || {};
                    this.trength = Cesium.defaultValue(options.trength, 0.1); //雾强度  0-1
                    this.color = Cesium.defaultValue(options.color, new Cesium.Color(0.8, 0.8, 0.8, 0.5)); //雾颜色
                    this._show = Cesium.defaultValue(options.show, true);
                    this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);

                    this.init();
                }

                //========== 对外属性 ==========  
                //是否开启效果


                _createClass(FogEffect, [{
                    key: "init",


                    //========== 方法 ========== 

                    value: function init() {
                        var that = this;
                        this.FogStage = new Cesium.PostProcessStage({
                            "name": "MapVFog",
                            fragmentShader: "  uniform sampler2D colorTexture;\n" + "  uniform sampler2D depthTexture;\n" + "  uniform float trength;\n" + "  uniform vec4 fogcolor;\n" + "  varying vec2 v_textureCoordinates;\n" + "  void main(void)\n" + "  {\n" + "      vec4 origcolor=texture2D(colorTexture, v_textureCoordinates);\n" + "\n" + "      float depth = czm_readDepth(depthTexture, v_textureCoordinates);\n" + "      vec4 depthcolor=texture2D(depthTexture, v_textureCoordinates);\n" + "\n" + "      float f=trength*(depthcolor.r-0.3)/0.2;\n" + "      if(f<0.0) f=0.0;\n" + "      else if(f>1.0) f=1.0;\n" + "      gl_FragColor = mix(origcolor,fogcolor,f);\n" + "   }",
                            uniforms: {
                                trength: function trength() {
                                    return that.trength;
                                },
                                fogcolor: function fogcolor() {
                                    return that.color;
                                }
                            }
                        });
                        this.FogStage.enabled = this._show;
                        this.viewer.scene.postProcessStages.add(this.FogStage);

                        //加控制，只在相机高度低于一定高度时才开启本效果
                        this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
                    }
                }, {
                    key: "camera_changedHandler",
                    value: function camera_changedHandler(event) {
                        if (viewer.camera.positionCartographic.height < this._maxHeight) {
                            this.FogStage.enabled = this._show;
                        } else {
                            this.FogStage.enabled = false;
                        }
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
                        this.viewer.scene.postProcessStages.remove(this.FogStage);
                        delete this.FogStage;
                        delete this.trength;
                        delete this.color;
                        delete this.viewer;
                    }
                }, {
                    key: "show",
                    get: function get() {
                        return this._show;
                    },
                    set: function set(val) {
                        this._show = Boolean(val);
                        this.FogStage.enabled = this._show;
                    }
                }]);

                return FogEffect;
            }();

            /***/
}),
/* 185 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.InvertedScene = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _InvertedSceneFS = __webpack_require__(186);

            var _InvertedSceneFS2 = _interopRequireDefault(_InvertedSceneFS);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            //后处理实现倒影
            //原理：利用空间镜面反射技术，计算倒影射线的UV进行采样
            var InvertedScene = exports.InvertedScene = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function InvertedScene(viewer, options) {
                    _classCallCheck(this, InvertedScene);

                    this.viewer = viewer;

                    options = options || {};
                    this._show = Cesium.defaultValue(options.show, true);

                    this.init();
                }

                //========== 对外属性 ========== 

                //是否开启效果


                _createClass(InvertedScene, [{
                    key: "init",


                    //========== 方法 ========== 

                    value: function init() {
                        this.postStage = new Cesium.PostProcessStage({
                            "name": "InvertedScene",
                            fragmentShader: _InvertedSceneFS2.default
                        });
                        this.postStage.enabled = this._show;
                        this.viewer.scene.postProcessStages.add(this.postStage);
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.postProcessStages.remove(this.postStage);
                    }
                }, {
                    key: "show",
                    get: function get() {
                        return this._show;
                    },
                    set: function set(val) {
                        this._show = Boolean(val);
                        this.postStage.enabled = this._show;
                    }
                }]);

                return InvertedScene;
            }();

            /***/
}),
/* 186 */
/***/ (function (module, exports) {

            module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvec3 guussColor(vec2 uv){\r\n    vec2 pixelSize = 1.0 / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n    vec4 gc = (\r\n        texture2D(colorTexture, uv)+\r\n        texture2D(colorTexture, uv + vec2(dx0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy1))\r\n    ) * (1.0 / 9.0);\r\n    return gc.rgb;\r\n}\r\nvoid main(){\r\n    // mat4 dither = mat4(\r\n    //     0,       0.5,    0.125,  0.625,\r\n    //     0.75,    0.25,   0.875,  0.375,\r\n    //     0.1875,  0.6875, 0.0625, 0.5625,\r\n    //     0.9375,  0.4375, 0.8125, 0.3125\r\n    // );\r\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\r\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\r\n    float offset = 0.0;\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n\r\n    \r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * normal);\r\n    float fotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(fotNumWC<=0.5){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\r\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\r\n    // return;\r\n\r\n    vec3 viewDir = normalize(positionEC.xyz);\r\n    vec3 reflectDir = reflect(viewDir, normal);\r\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\r\n    vec3 viewReflectDir = reflectDir;\r\n\r\n    \r\n    float step = 0.05;\r\n    int stepNum = int(20.0 / step);\r\n    vec3 pos;\r\n    vec3 albedo;\r\n    bool jd = false;\r\n    for(int i = 1;i <= 400;i++)\r\n    {\r\n        float delta = step * float(i) + offset;\r\n        pos = positionEC.xyz + viewReflectDir * delta;\r\n        float d = -pos.z;\r\n\r\n        vec4 tmp = czm_projection * vec4(pos,1.0);\r\n        vec3 screenPos = tmp.xyz / tmp.w;\r\n        vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\r\n        \r\n        if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\r\n            float dd = getDepth(texture2D(depthTexture, uv));\r\n            vec4 jzc = toEye(uv, dd);\r\n            dd = -jzc.z;\r\n            if(d>dd){\r\n                if(abs(abs(d) - abs(dd)) <=step){\r\n                    jd = true;\r\n                    // albedo = texture2D(colorTexture, uv).rgb;\r\n                    albedo = guussColor(uv);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if(jd){\r\n        gl_FragColor = vec4(mix(color.xyz,albedo,0.5),1.0);\r\n    }else{\r\n        gl_FragColor = color;\r\n    }\r\n}"

            /***/
}),
/* 187 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.SnowCover = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _SnowCoverFS = __webpack_require__(188);

            var _SnowCoverFS2 = _interopRequireDefault(_SnowCoverFS);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            // 雪覆盖 效果 
            //原理：法线越垂直与地面越白 
            var SnowCover = exports.SnowCover = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function SnowCover(viewer, options) {
                    _classCallCheck(this, SnowCover);

                    this.viewer = viewer;

                    options = options || {};
                    this.alpha = Cesium.defaultValue(options.alpha, 1.0); //覆盖强度  0-1
                    this._show = Cesium.defaultValue(options.show, true);
                    this._maxHeight = Cesium.defaultValue(options.maxHeight, 9000);
                    this.init();
                }

                //========== 对外属性 ==========  
                //是否开启效果


                _createClass(SnowCover, [{
                    key: "init",


                    //========== 方法 ========== 

                    value: function init() {
                        var that = this;
                        this.postStage = new Cesium.PostProcessStage({
                            "name": "SnowCover",
                            fragmentShader: _SnowCoverFS2.default,
                            uniforms: {
                                alpha: function alpha() {
                                    return that.alpha;
                                }
                            }
                        });
                        this.postStage.enabled = this._show;
                        this.viewer.scene.postProcessStages.add(this.postStage);

                        //加控制，只在相机高度低于一定高度时才开启本效果
                        this.viewer.scene.camera.changed.addEventListener(this.camera_changedHandler, this);
                    }
                }, {
                    key: "camera_changedHandler",
                    value: function camera_changedHandler(event) {
                        if (viewer.camera.positionCartographic.height < this._maxHeight) {
                            this.postStage.enabled = this._show;
                        } else {
                            this.postStage.enabled = false;
                        }
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.camera.changed.removeEventListener(this.camera_changedHandler, this);
                        this.viewer.scene.postProcessStages.remove(this.postStage);
                        delete this.postStage;
                        delete this.viewer;
                    }
                }, {
                    key: "show",
                    get: function get() {
                        return this._show;
                    },
                    set: function set(val) {
                        this._show = Boolean(val);
                        this.postStage.enabled = this._show;
                    }
                }]);

                return SnowCover;
            }();

            /***/
}),
/* 188 */
/***/ (function (module, exports) {

            module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float alpha;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvoid main(){\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 nor = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\r\n    float dotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(dotNumWC<=0.3){\r\n        gl_FragColor = mix(color,vec4(1.0),alpha*0.3);\r\n        return;\r\n    }\r\n    gl_FragColor = mix(color,vec4(1.0),dotNumWC*alpha);\r\n}"

            /***/
}),
/* 189 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.WaterSpout = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var emitterModelMatrix = new Cesium.Matrix4();
            var translation = new Cesium.Cartesian3();
            var rotation = new Cesium.Quaternion();
            var hpr = new Cesium.HeadingPitchRoll();
            var trs = new Cesium.TranslationRotationScale();
            var gravityScratch = new Cesium.Cartesian3();

            // 水柱粒子效果

            var WaterSpout = exports.WaterSpout = function () {
                //========== 构造方法 ========== 
                //创建一个模型编辑对象
                function WaterSpout(viewer, options) {
                    _classCallCheck(this, WaterSpout);

                    if (!viewer) return;
                    this.viewer = viewer;

                    options = options || {};

                    this.image = options.image;
                    this.startColor = Cesium.defaultValue(options.startColor, Cesium.Color.LIGHTCYAN.withAlpha(0.3));
                    this.endColor = Cesium.defaultValue(options.endColor, Cesium.Color.WHITE.withAlpha(0.0));
                    this.startScale = Cesium.defaultValue(options.startScale, 2.0);
                    this.endScale = Cesium.defaultValue(options.endScale, 4.0);
                    this.minimumParticleLife = Cesium.defaultValue(options.minimumParticleLife, 4.1);
                    this.maximumParticleLife = Cesium.defaultValue(options.maximumParticleLife, 1.1);
                    this.minimumSpeed = Cesium.defaultValue(options.minimumSpeed, 0);
                    this.maximumSpeed = Cesium.defaultValue(options.maximumSpeed, 0);
                    this.particleSize = Cesium.defaultValue(options.particleSize, 28);
                    this.emissionRate = Cesium.defaultValue(options.emissionRate, 100);
                    this.lifetime = Cesium.defaultValue(options.lifetime, 8);
                    this.bursts = Cesium.defaultValue(options.bursts, [
                        // these burst will occasionally sync to create a multicolored effect
                        new Cesium.ParticleBurst({ time: 5.0, minimum: 60, maximum: 100 })]
                        // new Cesium.ParticleBurst({time : 10.0, minimum : 50, maximum : 100}),
                        // new Cesium.ParticleBurst({time : 15.0, minimum : 200, maximum : 300})
                    );

                    this.gravity = Cesium.defaultValue(options.gravity, -11);
                    this._show = Cesium.defaultValue(options.show, false);

                    this.arrPS = [];
                    this.viewer.scene.preUpdate.addEventListener(this._scene_preUpdateHandler, this);
                }

                //========== 对外属性 ==========  
                //压平深度


                _createClass(WaterSpout, [{
                    key: "add",


                    //========== 方法 ========== 
                    value: function add(posArr) {

                        var that = this;
                        function applyGravity(p, dt) {
                            var translatCar3 = new Cesium.Cartesian3(-0.8, -0.5, 2);
                            Cesium.Cartesian3.multiplyByScalar(translatCar3, 0.1, translatCar3);

                            var position = p.position;
                            Cesium.Cartesian3.add(p.position, translatCar3, p.position);

                            Cesium.Cartesian3.normalize(position, gravityScratch);
                            Cesium.Cartesian3.multiplyByScalar(gravityScratch, that.gravity * dt, gravityScratch);
                            p.velocity = Cesium.Cartesian3.add(p.velocity, gravityScratch, p.velocity);
                        }

                        for (var i = 0, len = posArr.length; i < len; i++) {
                            var pos = posArr[i];
                            var center = Cesium.Cartesian3.fromDegrees(pos[0], pos[1], pos[2]);

                            var particleSystem = this.viewer.scene.primitives.add(new Cesium.ParticleSystem({
                                image: this.image,
                                startColor: this.startColor,
                                endColor: this.endColor,
                                startScale: this.startScale,
                                endScale: this.endScale,
                                minimumParticleLife: this.minimumParticleLife,
                                maximumParticleLife: this.maximumParticleLife,
                                minimumSpeed: this.minimumSpeed,
                                maximumSpeed: this.maximumSpeed,
                                imageSize: new Cesium.Cartesian2(this.particleSize, this.particleSize),
                                emissionRate: this.emissionRate,
                                bursts: this.bursts,
                                lifetime: this.lifetime,
                                emitter: new Cesium.CircleEmitter(2.0),
                                emitterModelMatrix: this._computeEmitterModelMatrix(),
                                updateCallback: applyGravity,
                                show: this.show
                            }));

                            this.arrPS.push({
                                center: center,
                                particleSystem: particleSystem
                            });
                        }
                    }
                }, {
                    key: "_scene_preUpdateHandler",
                    value: function _scene_preUpdateHandler() {
                        if (!this.arrPS || this.arrPS.length == 0) return;

                        for (var i = 0, len = this.arrPS.length; i < len; i++) {
                            var item = this.arrPS[i];

                            var particleSystem = item.particleSystem;
                            particleSystem.modelMatrix = this._computeModelMatrix(item.center);
                            particleSystem.emitterModelMatrix = this._computeEmitterModelMatrix();
                        }
                    }
                }, {
                    key: "_computeModelMatrix",
                    value: function _computeModelMatrix(center) {
                        var modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
                        var hprRotation = Cesium.Matrix3.fromHeadingPitchRoll(new Cesium.HeadingPitchRoll(2.619728786416368, 0.0, 0.0));
                        var hpr = Cesium.Matrix4.fromRotationTranslation(hprRotation, new Cesium.Cartesian3(0.0, 0.0, -2.0));
                        Cesium.Matrix4.multiply(modelMatrix, hpr, modelMatrix);
                        return modelMatrix;
                    }
                }, {
                    key: "_computeEmitterModelMatrix",
                    value: function _computeEmitterModelMatrix() {
                        hpr = Cesium.HeadingPitchRoll.fromDegrees(0, 0, 0, hpr);
                        trs.translation = Cesium.Cartesian3.fromElements(0, 0.0, 0, translation);
                        trs.rotation = Cesium.Quaternion.fromHeadingPitchRoll(hpr, rotation);

                        Cesium.Matrix4.fromTranslationRotationScale(trs, emitterModelMatrix);

                        var translatCar3 = new Cesium.Cartesian3(-2, -2, 2);
                        Cesium.Matrix4.multiplyByTranslation(emitterModelMatrix, translatCar3, emitterModelMatrix);
                        return emitterModelMatrix;
                    }
                }, {
                    key: "updateVisible",
                    value: function updateVisible(show, index) {
                        this.arrPS[index].particleSystem.show = show;
                    }
                }, {
                    key: "updateAllVisible",
                    value: function updateAllVisible(show) {
                        for (var i = 0, len = this.arrPS.length; i < len; i++) {
                            this.arrPS[i].particleSystem.show = show;
                        }
                    }
                }, {
                    key: "clear",
                    value: function clear() {
                        for (var i = 0, len = this.arrPS.length; i < len; i++) {
                            this.viewer.scene.primitives.remove(this.arrPS[i].particleSystem);
                        }
                        this.arrPS = [];
                    }

                    //销毁

                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.preUpdate.removeEventListener(this._scene_preUpdateHandler, this);
                        this.clear();
                    }
                }, {
                    key: "show",
                    get: function get() {
                        return this._show;
                    },
                    set: function set(val) {
                        this._show = val;
                        this.updateAllVisible(this._show);
                    }
                }]);

                return WaterSpout;
            }();

            /***/
}),
/* 190 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.ZoomNavigation = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var unprojectedScratch = new Cesium.Cartographic();
            var rayScratch = new Cesium.Ray();
            var cartesian3Scratch = new Cesium.Cartesian3();

            /**
             * gets the focus point of the camera
             * @param {Viewer|Widget} viewer The viewer
             * @param {boolean} inWorldCoordinates true to get the focus in world coordinates, otherwise get it in projection-specific map coordinates, in meters.
             * @param {Cesium.Cartesian3} [result] The object in which the result will be stored.
             * @return {Cesium.Cartesian3} The modified result parameter, a new instance if none was provided or undefined if there is no focus point.
             */
            function getCameraFocus(viewer, inWorldCoordinates, result) {
                var scene = viewer.scene;
                var camera = scene.camera;

                if (scene.mode == Cesium.SceneMode.MORPHING) {
                    return undefined;
                }

                if (!Cesium.defined(result)) {
                    result = new Cesium.Cartesian3();
                }

                // TODO bug when tracking: if entity moves the current position should be used and not only the one when starting orbiting/rotating
                // TODO bug when tracking: reset should reset to default view of tracked entity

                if (Cesium.defined(viewer.trackedEntity)) {
                    result = viewer.trackedEntity.position.getValue(viewer.clock.currentTime, result);
                } else {
                    rayScratch.origin = camera.positionWC;
                    rayScratch.direction = camera.directionWC;
                    result = scene.globe.pick(rayScratch, scene, result);
                }

                if (!Cesium.defined(result)) {
                    return undefined;
                }

                if (scene.mode == Cesium.SceneMode.SCENE2D || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
                    result = camera.worldToCameraCoordinatesPoint(result, result);

                    if (inWorldCoordinates) {
                        result = scene.globe.ellipsoid.cartographicToCartesian(scene.mapProjection.unproject(result, unprojectedScratch), result);
                    }
                } else {
                    if (!inWorldCoordinates) {
                        result = camera.worldToCameraCoordinatesPoint(result, result);
                    }
                }

                return result;
            };

            var ZoomNavigation = exports.ZoomNavigation = function () {
                //========== 构造方法 ========== 
                // is used for zooming in (true) or out (false)
                function ZoomNavigation(viewer, zoomIn) {
                    _classCallCheck(this, ZoomNavigation);

                    this.viewer = viewer;

                    this.relativeAmount = 2;
                    if (zoomIn) {
                        // this ensures that zooming in is the inverse of zooming out and vice versa
                        // e.g. the camera position remains when zooming in and out
                        this.relativeAmount = 1 / this.relativeAmount;
                    }
                }

                /**
                 * When implemented in a derived class, performs an action when the user clicks
                 * on this control
                 * @abstract
                 * @protected
                 */


                _createClass(ZoomNavigation, [{
                    key: "activate",
                    value: function activate() {
                        this.zoom(this.relativeAmount);
                    }
                }, {
                    key: "zoom",
                    value: function zoom(relativeAmount) {
                        this.isActive = true;

                        if (Cesium.defined(this.viewer)) {
                            var scene = this.viewer.scene;

                            var sscc = scene.screenSpaceCameraController;
                            // do not zoom if it is disabled
                            if (!sscc.enableInputs || !sscc.enableZoom) {
                                return;
                            }
                            // TODO
                            //            if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW && !sscc.enableTranslate) {
                            //                return;
                            //            }

                            var camera = scene.camera;
                            var orientation;

                            switch (scene.mode) {
                                case Cesium.SceneMode.MORPHING:
                                    break;
                                case Cesium.SceneMode.SCENE2D:
                                    camera.zoomIn(camera.positionCartographic.height * (1 - this.relativeAmount));
                                    break;
                                default:
                                    var focus;

                                    if (Cesium.defined(this.viewer.trackedEntity)) {
                                        focus = new Cesium.Cartesian3();
                                    } else {
                                        focus = getCameraFocus(this.viewer, false);
                                    }

                                    if (!Cesium.defined(focus)) {
                                        // Camera direction is not pointing at the globe, so use the ellipsoid horizon point as
                                        // the focal point.
                                        var ray = new Cesium.Ray(camera.worldToCameraCoordinatesPoint(scene.globe.ellipsoid.cartographicToCartesian(camera.positionCartographic)), camera.directionWC);
                                        focus = Cesium.IntersectionTests.grazingAltitudeLocation(ray, scene.globe.ellipsoid);

                                        orientation = {
                                            heading: camera.heading,
                                            pitch: camera.pitch,
                                            roll: camera.roll
                                        };
                                    } else {
                                        orientation = {
                                            direction: camera.direction,
                                            up: camera.up
                                        };
                                    }

                                    var direction = Cesium.Cartesian3.subtract(camera.position, focus, cartesian3Scratch);
                                    var movementVector = Cesium.Cartesian3.multiplyByScalar(direction, relativeAmount, direction);
                                    var endPosition = Cesium.Cartesian3.add(focus, movementVector, focus);

                                    if (Cesium.defined(this.viewer.trackedEntity) || scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
                                        // sometimes flyTo does not work (jumps to wrong position) so just set the position without any animation
                                        // do not use flyTo when tracking an entity because during animatiuon the position of the entity may change
                                        camera.position = endPosition;
                                    } else {
                                        camera.flyTo({
                                            destination: endPosition,
                                            orientation: orientation,
                                            duration: 0.5,
                                            convert: false
                                        });
                                    }
                            }
                        }

                        // this.viewer.notifyRepaintRequired();
                        this.isActive = false;
                    }
                }]);

                return ZoomNavigation;
            }();

            /***/
}),
/* 191 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.rotate = undefined;
            exports.createModel = createModel;
            exports.move = move;
            exports.getHeadingPitchRoll = getHeadingPitchRoll;

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _matrix = __webpack_require__(17);

            var _util = __webpack_require__(1);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            //创建模型
            function createModel(cfg, viewer) {
                cfg = viewer.mapv.point2map(cfg); //转换坐标系

                var position = Cesium.Cartesian3.fromDegrees(cfg.x, cfg.y, cfg.z || 0);

                var heading = Cesium.Math.toRadians(cfg.heading || 0);
                var pitch = Cesium.Math.toRadians(cfg.pitch || 0);
                var roll = Cesium.Math.toRadians(cfg.roll || 0);
                var hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);

                var converter = cfg.converter || Cesium.Transforms.eastNorthUpToFixedFrame;
                var orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr, viewer.scene.globe.ellipsoid, converter);

                var model = viewer.entities.add({
                    name: cfg.name || "",
                    position: position,
                    orientation: orientation,
                    model: cfg,
                    tooltip: cfg.tooltip,
                    popup: cfg.popup
                });
                return model;
            }

            //自旋转效果
            //gltf模型
            var rotate = exports.rotate = {
                isStart: false,
                viewer: null,
                start: function start(entity, opts) {
                    this.entity = entity;
                    this.viewer = opts.viewer || window.viewer;

                    this.time = this.viewer.clock.currentTime.clone();

                    this.hpr = (0, _matrix.getHeadingPitchRollByOrientation)(this.entity.position._value, this.entity.orientation && this.entity.orientation._value);
                    this.angle = opts.step || 10; //步长

                    this.viewer.clock.shouldAnimate = true;
                    this.viewer.clock.onTick.addEventListener(this.clock_onTickHandler, this);
                    this.isStart = true;
                },
                clock_onTickHandler: function clock_onTickHandler(e) {
                    var delTime = Cesium.JulianDate.secondsDifference(this.viewer.clock.currentTime, this.time); // 当前已经过去的时间，单位 秒
                    var heading = Cesium.Math.toRadians(delTime * this.angle) + this.hpr.heading;

                    //角度控制  
                    var hpr = new Cesium.HeadingPitchRoll(heading, this.hpr.pitch, this.hpr.roll);
                    this.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(this.entity.position._value, hpr);
                },
                stop: function stop() {
                    if (!this.isStart) return;

                    if (this.viewer) this.viewer.clock.onTick.removeEventListener(this.clock_onTickHandler, this);
                    this.isStart = false;
                }
            };

            //移动模型
            function move(entity, options) {
                var viewer = options.viewer || window.viewer;

                var property = new Cesium.SampledPositionProperty();
                var startTime = viewer.clock.currentTime; //飞行开始时间
                var stopTime; //飞行结束时间 

                var pointStart = entity.position.getValue(startTime);
                property.addSample(startTime, pointStart);

                var pointEnd = options.position;
                var time = options.time || 3; //速度 秒
                stopTime = Cesium.JulianDate.addSeconds(startTime, time, new Cesium.JulianDate());
                property.addSample(stopTime, pointEnd);

                entity.position = property;

                // var _bak_startTime = viewer.clock.startTime;
                // var _bak_stopTime = viewer.clock.stopTime;
                // var _bak_clockRange = viewer.clock.clockRange;

                viewer.clock.shouldAnimate = true;
                var _bak_multiplier = viewer.clock.multiplier;
                viewer.clock.multiplier = options.speed || 1; //飞行速度  
                viewer.clock.currentTime = startTime.clone();
                // viewer.clock.startTime = startTime.clone();
                // viewer.clock.stopTime = stopTime.clone();
                // viewer.clock.clockRange = Cesium.ClockRange.CLAMPED; //到达终止时间后停止

                setTimeout(function () {
                    entity.position = pointEnd;

                    // viewer.clock.startTime = _bak_startTime;
                    // viewer.clock.stopTime = _bak_stopTime;
                    // viewer.clock.clockRange = _bak_clockRange; 
                    viewer.clock.multiplier = _bak_multiplier;

                    if (options.onEnd) options.onEnd();
                }, time * 1000);
            }

            //获取动态模型的当前hpr角度
            function getHeadingPitchRoll(entity, time) {
                time = time || (0, _util.currentTime)();
                var position = Cesium.Property.getValueOrUndefined(entity.position, time, new Cesium.Cartesian3());
                var orientation = Cesium.Property.getValueOrUndefined(entity.orientation, time, new Cesium.Quaternion());
                var hpr = (0, _matrix.getHeadingPitchRollByOrientation)(position, orientation);
                return hpr;
            }

            /***/
}),
/* 192 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Video3D = undefined;

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            var _Video3DFS = __webpack_require__(193);

            var _Video3DFS2 = _interopRequireDefault(_Video3DFS);

            function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var ratateDirection = {
                'LEFT': 'Z',
                'RIGHT': '-Z',
                'TOP': 'Y',
                'BOTTOM': '-Y',
                'ALONG': 'X',
                'INVERSE': '-X'
            };

            var textStyles = {
                font: '50px 楷体',
                fill: true,
                fillColor: new Cesium.Color(1.0, 1.0, 0.0, 1.0),
                stroke: true,
                strokeWidth: 2,
                strokeColor: new Cesium.Color(1.0, 1.0, 1.0, 0.8),
                backgroundColor: new Cesium.Color(1.0, 1.0, 1.0, 0.1),
                textBaseline: 'top',
                padding: 40
            };

            var Video3DType = {
                Color: 1,
                Image: 2,
                Video: 3,
                Text: 4

                //视频融合（投射3D，贴物体表面）
                //原理：在可视域的基础上，着色器里传入纹理，再计算UV进行贴图
            };
            var Video3D = exports.Video3D = function () {
                //========== 构造方法 ========== 
                function Video3D(viewer, options) {
                    _classCallCheck(this, Video3D);

                    if (!viewer) return;

                    if (!options) options = {};
                    this.viewer = viewer;
                    this._cameraPosition = options.cameraPosition; //相机位置
                    this._position = options.position; //视点位置
                    this.type = options.type; //投影类型
                    this.alpha = options.alpha || 1.0; //透明度
                    this.color = options.color; //投影的颜色
                    this._debugFrustum = Cesium.defaultValue(options.debugFrustum, true); //显示视椎体
                    this._aspectRatio = options.aspectRatio || this._getWinWidHei(); //宽高比
                    var fov = options.fov && Cesium.Math.toRadians(options.fov);
                    this._camerafov = fov || this.viewer.scene.camera.frustum.fov; //相机水平张角
                    this.videoTexture = this.texture = options.texture || new Cesium.Texture({ //默认材质
                        context: this.viewer.scene.context,
                        source: {
                            width: 1,
                            height: 1,
                            arrayBufferView: new Uint8Array([255, 255, 255, 255])
                        },
                        flipY: false
                    });
                    this._videoPlay = Cesium.defaultValue(options.videoPlay, true); //暂停播放
                    this.defaultShow = Cesium.defaultValue(options.show, true); //显示和隐藏
                    this.clearBlack = Cesium.defaultValue(options.clearBlack, false); //消除鱼眼视频的黑色
                    this._rotateDeg = 1;
                    this._dirObj = Cesium.defaultValue(options.dirObj, undefined);
                    this.text = Cesium.defaultValue(options.text, undefined);
                    this.textStyles = Cesium.defaultValue(options.textStyles, textStyles);
                    this._disViewColor = Cesium.defaultValue(options.disViewColor, new Cesium.Color(0, 0, 0, 0.5));

                    if (!this.cameraPosition || !this.cameraPosition) {
                        console.log("初始化失败：请确认相机位置与视点位置正确！");
                        return;
                    }

                    //传入了DOM
                    if (options.dom) {
                        this.dom = options.dom;
                        if (this.dom instanceof HTMLElement) {
                            this.dom = options.dom;
                        }
                        if (options.dom instanceof Object && options.dom.length) {
                            this.dom = options.dom[0];
                        }
                    }
                    //传入了URL
                    this.url = options.url; //url


                    switch (this.type) {
                        default:
                        case Video3DType.Video:
                            this.activeVideo(this.url);
                            break;
                        case Video3DType.Image:
                            this.activePicture(this.url);
                            this.deActiveVideo();
                            break;
                        case Video3DType.Color:
                            this.activeColor(this.color);
                            this.deActiveVideo();
                            break;
                        case Video3DType.Text:
                            this.activeText(this.text, this.textStyles);
                            this.deActiveVideo();
                            break;
                    }

                    this._createShadowMap();
                    this._getOrientation();
                    this._addCameraFrustum();
                    this._addPostProcess();
                    this.viewer.scene.primitives.add(this);
                }

                //========== 对外属性 ========== 
                //混合系数0-1


                _createClass(Video3D, [{
                    key: "rotateCamera",


                    //旋转相机
                    value: function rotateCamera(axis, deg) {
                        var rotateDegree = Cesium.defaultValue(deg, this._rotateDeg);
                        switch (axis) {
                            case ratateDirection.LEFT:
                                break;
                            case ratateDirection.RIGHT:
                                rotateDegree *= -1;
                                break;
                            case ratateDirection.TOP:
                                break;
                            case ratateDirection.BOTTOM:
                                rotateDegree *= -1;
                                break;
                            case ratateDirection.ALONG:
                                break;
                            case ratateDirection.INVERSE:
                                rotateDegree *= -1;
                                break;
                        }
                        var newDir = this._computedNewViewDir(axis, rotateDegree);

                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.scene.primitives.remove(this.cameraFrustum);
                        this.viewShadowMap.destroy();
                        this.cameraFrustum.destroy();
                        this._resetCameraDir(newDir);
                        this._getOrientation();
                        this._addCameraFrustum();
                        this._addPostProcess();
                    }
                }, {
                    key: "_resetCameraDir",
                    value: function _resetCameraDir(dirObj) {
                        if (!dirObj || !dirObj.up || !dirObj.right || !dirObj.direction) return;
                        this._dirObj = dirObj;
                        this._createShadowMap();
                    }
                    //计算新视点

                }, {
                    key: "_computedNewViewDir",
                    value: function _computedNewViewDir(axis, deg) {
                        deg = Cesium.Math.toRadians(deg);
                        var camera = this.viewShadowMap._lightCamera;
                        var oldDir = Cesium.clone(camera.direction);
                        var oldRight = Cesium.clone(camera.right);
                        var oldTop = Cesium.clone(camera.up);
                        var mat3 = new Cesium.Matrix3();

                        switch (axis) {
                            case ratateDirection.LEFT:
                                Cesium.Matrix3.fromRotationZ(deg, mat3);
                                break;
                            case ratateDirection.RIGHT:
                                Cesium.Matrix3.fromRotationZ(deg, mat3);
                                break;
                            case ratateDirection.TOP:
                                Cesium.Matrix3.fromRotationY(deg, mat3);
                                break;
                            case ratateDirection.BOTTOM:
                                Cesium.Matrix3.fromRotationY(deg, mat3);
                                break;
                            case ratateDirection.ALONG:
                                Cesium.Matrix3.fromRotationX(deg, mat3);
                                break;
                            case ratateDirection.INVERSE:
                                Cesium.Matrix3.fromRotationX(deg, mat3);
                                break;
                        }
                        var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
                        // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
                        // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
                        var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

                        var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
                        var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
                        var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

                        var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
                        var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
                        var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

                        var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
                        var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
                        var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
                        return {
                            direction: newDir,
                            right: newRight,
                            up: newTop
                        };
                    }
                }, {
                    key: "getPercentagePoint",
                    value: function getPercentagePoint(cartesian) {
                        if (!cartesian) return;
                        var vm = this.viewShadowMap._lightCamera._viewMatrix;
                        var pm = this.viewShadowMap._lightCamera.frustum.projectionMatrix;
                        var c4 = new Cesium.Cartesian4(cartesian.x, cartesian.y, cartesian.z, 1.0);
                        var pvm = Cesium.Matrix4.multiply(pm, vm, new Cesium.Matrix4());
                        var epos1 = Cesium.Matrix4.multiplyByVector(pvm, c4, new Cesium.Cartesian4());
                        var epos2 = new Cesium.Cartesian2(epos1.x / epos1.w, epos1.y / epos1.w);
                        var epos3 = new Cesium.Cartesian2(epos2.x / 2 + 0.5, epos2.y / 2 + 0.5);
                        return epos3;
                    }

                    /**
                     * 改变相机的水平张角
                     */

                }, {
                    key: "_changeCameraFov",
                    value: function _changeCameraFov() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.scene.primitives.remove(this.cameraFrustum);
                        this._createShadowMap();
                        this._getOrientation();
                        this._addCameraFrustum();
                        this._addPostProcess();
                    }

                    /**
                     * 改变相机视野的宽高比例（垂直张角）
                     */

                }, {
                    key: "_changeVideoWidHei",
                    value: function _changeVideoWidHei() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.scene.primitives.remove(this.cameraFrustum);
                        this._createShadowMap();
                        this._getOrientation();
                        this._addCameraFrustum();
                        this._addPostProcess();
                    }

                    /**
                     * 改变相机的位置
                     */

                }, {
                    key: "_changeCameraPos",
                    value: function _changeCameraPos() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.scene.primitives.remove(this.cameraFrustum);
                        this.viewShadowMap.destroy();
                        this.cameraFrustum.destroy();
                        this._createShadowMap(true);
                        this._getOrientation();
                        this._addCameraFrustum();
                        this._addPostProcess();
                    }

                    /**
                     * 改变相机视点的位置
                     */

                }, {
                    key: "_changeViewPos",
                    value: function _changeViewPos() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        this.viewer.scene.primitives.remove(this.cameraFrustum);
                        this.viewShadowMap.destroy();
                        this.cameraFrustum.destroy();
                        this._createShadowMap(true);
                        this._getOrientation();
                        this._addCameraFrustum();
                        this._addPostProcess();
                    }
                }, {
                    key: "_switchShow",
                    value: function _switchShow() {
                        if (this.show) {
                            !this.postProcess && this._addPostProcess();
                        } else {
                            this.viewer.scene.postProcessStages.remove(this.postProcess);
                            delete this.postProcess;
                            this.postProcess = null;
                        }
                        // this.cameraFrustum.show = this.show;
                    }

                    /**
                     * 激活或重置视频URL
                     * @param videoSrc
                     * @returns 
                     */

                }, {
                    key: "activeVideo",
                    value: function activeVideo(videoSrc) {
                        //在可视域添加视频
                        var videoElement;
                        if (this.dom) {
                            videoElement = this.dom;
                        } else {
                            videoElement = this._createVideoEle(videoSrc);
                        }

                        var that = this;
                        if (videoElement) {
                            this.type = Video3DType.Video;
                            this.videoElement = videoElement;
                            videoElement.addEventListener("canplaythrough", function () {
                                that.viewer.clock.onTick.addEventListener(that.activeVideoListener, that);
                            });
                        }
                    }
                }, {
                    key: "activeVideoListener",
                    value: function activeVideoListener() {
                        try {
                            if (this._videoPlay && this.videoElement.paused) this.videoElement.play();
                        } catch (e) { }

                        this.videoTexture && this.videoTexture.destroy();
                        this.videoTexture = new Cesium.Texture({
                            context: this.viewer.scene.context,
                            source: this.videoElement,
                            pixelFormat: Cesium.PixelFormat.RGBA,
                            pixelDatatype: Cesium.PixelDatatype.UNSIGNED_BYTE
                        });
                    }

                    //删除视频播放监听

                }, {
                    key: "deActiveVideo",
                    value: function deActiveVideo() {
                        this.viewer.clock.onTick.removeEventListener(this.activeVideoListener, this);
                        delete this.activeVideoListener;
                    }

                    /**
                     * 激活或重置图片URL
                     * @param videoSrc
                     * @returns 
                     */

                }, {
                    key: "activePicture",
                    value: function activePicture(picSrc) {

                        //在可视域添加图片    
                        this.videoTexture = this.texture;

                        var that = this;
                        var image = new Image();
                        image.onload = function () {
                            that.type = Video3DType.Image;
                            that.videoTexture = new Cesium.Texture({
                                context: that.viewer.scene.context,
                                source: image
                            });
                        };
                        image.onerror = function () {
                            console.log('图片加载失败：' + picSrc);
                        };
                        image.src = picSrc;
                    }
                }, {
                    key: "activeColor",


                    /**
                     * 激活或重置颜色
                     * @param color
                     * @returns 
                     */
                    value: function activeColor(color) {
                        //在可视域添加纯色
                        var that = this;
                        this.type = Video3DType.Color;
                        var r, g, b, a;
                        if (color) {
                            r = color.red * 255;
                            g = color.green * 255;
                            b = color.blue * 255;
                            a = color.alpha * 255;
                        } else {
                            r = Math.random() * 255;
                            g = Math.random() * 255;
                            b = Math.random() * 255;
                            a = Math.random() * 255;
                        }
                        that.videoTexture = new Cesium.Texture({
                            context: that.viewer.scene.context,
                            source: {
                                width: 1,
                                height: 1,
                                arrayBufferView: new Uint8Array([r, g, b, a])
                            },
                            flipY: false
                        });
                    }

                    /**
                     * 激活或重置文本
                     * @param text
                     * @param styles
                     * @returns 
                     */
                    // Name	               Type	          Default	                     Description
                    // font	               String	      '10px sans-serif'	             optional The CSS font to use.
                    // textBaseline	       String	      'bottom'	                     optional The baseline of the text.
                    // fill	               Boolean	      true	                         optional Whether to fill the text.
                    // stroke	           Boolean	      false	                         optional Whether to stroke the text.
                    // fillColor	       Color	      Color.WHITE	                 optional The fill color.
                    // strokeColor	       Color	      Color.BLACK	                 optional The stroke color.
                    // strokeWidth	       Number	      1	                             optional The stroke width.
                    // backgroundColor	   Color	      Color.TRANSPARENT	             optional The background color of the canvas.
                    // padding	           Number	      0	                             optional The pixel size of the padding to add around the text.

                }, {
                    key: "activeText",
                    value: function activeText(text, styles) {
                        //在可视域添加纯色
                        var that = this;
                        this.type = Video3DType.Text;
                        if (!text) return;
                        styles = styles || {};
                        styles.textBaseline = 'top';
                        this.textCanvas = Cesium.writeTextToCanvas(text, styles);
                        that.videoTexture = new Cesium.Texture({
                            context: that.viewer.scene.context,
                            source: this.textCanvas,
                            flipY: true
                        });
                    }

                    /**
                     * 呈现投影相机的第一视角
                     */

                }, {
                    key: "locate",
                    value: function locate() {
                        var camera_pos = Cesium.clone(this.cameraPosition);
                        var lookat_pos = Cesium.clone(this.position);
                        this.viewer.camera.position = camera_pos;
                        if (this._dirObj) {
                            this.viewer.camera.direction = Cesium.clone(this._dirObj.direction);
                            this.viewer.camera.right = Cesium.clone(this._dirObj.right);
                            this.viewer.camera.up = Cesium.clone(this._dirObj.up);
                            return;
                        }
                        this.viewer.camera.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
                        this.viewer.camera.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
                    }

                    //获取四元数

                }, {
                    key: "_getOrientation",
                    value: function _getOrientation() {
                        var cpos = this.cameraPosition;
                        var position = this.position;
                        var direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(position, cpos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                        var up = Cesium.Cartesian3.normalize(cpos, new Cesium.Cartesian3());
                        var camera = new Cesium.Camera(this.viewer.scene);
                        camera.position = cpos;
                        camera.direction = direction;
                        camera.up = up;
                        direction = camera.directionWC;
                        up = camera.upWC;
                        var right = camera.rightWC;
                        var scratchRight = new Cesium.Cartesian3();
                        var scratchRotation = new Cesium.Matrix3();
                        var scratchOrientation = new Cesium.Quaternion();

                        // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
                        right = Cesium.Cartesian3.negate(right, scratchRight);
                        var rotation = scratchRotation;
                        Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
                        Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
                        Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
                        //计算视锥姿态
                        var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
                        this.orientation = orientation;
                        return orientation;
                    }
                    //创建video元素

                }, {
                    key: "_createVideoEle",
                    value: function _createVideoEle(src) {
                        //创建可视域video DOM  元素
                        if (!src) return;
                        // this.videoId = 'visualDomId';
                        var source_map4 = document.createElement("SOURCE");
                        source_map4.type = 'video/mp4';
                        source_map4.src = src;
                        var source_mov = document.createElement("SOURCE");
                        source_mov.type = 'video/quicktime';
                        source_mov.src = src;
                        var videoEle = document.createElement("video");

                        videoEle.setAttribute('autoplay', true);
                        videoEle.setAttribute('loop', true);
                        videoEle.setAttribute('crossorigin', true);
                        videoEle.appendChild(source_map4);
                        videoEle.appendChild(source_mov);
                        videoEle.style.display = 'none';
                        document.body.appendChild(videoEle);
                        return videoEle;
                    }

                    //获取canvas宽高

                }, {
                    key: "_getWinWidHei",
                    value: function _getWinWidHei() {
                        var scene = this.viewer.scene;
                        return scene.canvas.clientWidth / scene.canvas.clientHeight;
                    }

                    //创建ShadowMap

                }, {
                    key: "_createShadowMap",
                    value: function _createShadowMap(reset) {
                        var camera_pos = this.cameraPosition;
                        var lookat_pos = this.position;
                        var scene = this.viewer.scene;
                        var camera1 = new Cesium.Camera(scene);
                        camera1.position = camera_pos;
                        if (this._dirObj && !reset) {
                            camera1.direction = this._dirObj.direction;
                            camera1.right = this._dirObj.right;
                            camera1.up = this._dirObj.up;
                        } else {
                            camera1.direction = Cesium.Cartesian3.subtract(lookat_pos, camera_pos, new Cesium.Cartesian3(0, 0, 0));
                            camera1.up = Cesium.Cartesian3.normalize(camera_pos, new Cesium.Cartesian3(0, 0, 0));
                            // this._dirObj = {
                            //     direction:camera1.direction,
                            //     right:camera1.right,
                            //     up:camera1.up
                            // }
                        }

                        var far = Cesium.Cartesian3.distance(lookat_pos, camera_pos);
                        this.viewDis = far;
                        camera1.frustum = new Cesium.PerspectiveFrustum({
                            fov: this.fov,
                            aspectRatio: this.aspectRatio,
                            near: 0.1,
                            far: far * 2
                        });

                        var isSpotLight = true;
                        this.viewShadowMap = new Cesium.ShadowMap({
                            lightCamera: camera1,
                            enable: false,
                            isPointLight: !isSpotLight,
                            isSpotLight: isSpotLight,
                            cascadesEnabled: false,
                            context: scene.context,
                            pointLightRadius: far
                        });
                    }

                    //添加视椎体

                }, {
                    key: "_addCameraFrustum",
                    value: function _addCameraFrustum() {
                        var that = this;
                        this.cameraFrustum = new Cesium.Primitive({
                            geometryInstances: new Cesium.GeometryInstance({
                                geometry: new Cesium.FrustumOutlineGeometry({
                                    origin: that.cameraPosition,
                                    orientation: that.orientation,
                                    frustum: this.viewShadowMap._lightCamera.frustum,
                                    _drawNearPlane: true
                                }),
                                attributes: {
                                    color: Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(0.0, 0.5, 0.5))
                                }
                            }),
                            appearance: new Cesium.PerInstanceColorAppearance({
                                translucent: false,
                                flat: true
                            }),
                            asynchronous: false,
                            show: this.debugFrustum && this.show
                        });
                        this.viewer.scene.primitives.add(this.cameraFrustum);
                    }
                    //添加后处理

                }, {
                    key: "_addPostProcess",
                    value: function _addPostProcess() {
                        var that = this;
                        var bias = that.viewShadowMap._isPointLight ? that.viewShadowMap._pointBias : that.viewShadowMap._primitiveBias;
                        if (!this.show) return;
                        this.postProcess = new Cesium.PostProcessStage({
                            fragmentShader: _Video3DFS2.default,
                            uniforms: {
                                mixNum: function mixNum() {
                                    return that.alpha;
                                },
                                mapvShadow: function mapvShadow() {
                                    return that.viewShadowMap._shadowMapTexture;
                                },
                                videoTexture: function videoTexture() {
                                    return that.videoTexture;
                                },
                                _shadowMap_matrix: function _shadowMap_matrix() {
                                    return that.viewShadowMap._shadowMapMatrix;
                                },
                                shadowMap_lightPositionEC: function shadowMap_lightPositionEC() {
                                    return that.viewShadowMap._lightPositionEC;
                                },
                                shadowMap_texelSizeDepthBiasAndNormalShadingSmooth: function shadowMap_texelSizeDepthBiasAndNormalShadingSmooth() {
                                    var texelStepSize = new Cesium.Cartesian2();
                                    texelStepSize.x = 1.0 / that.viewShadowMap._textureSize.x;
                                    texelStepSize.y = 1.0 / that.viewShadowMap._textureSize.y;
                                    return Cesium.Cartesian4.fromElements(texelStepSize.x, texelStepSize.y, bias.depthBias, bias.normalShadingSmooth, this.combinedUniforms1);
                                },
                                shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness: function shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness() {
                                    return Cesium.Cartesian4.fromElements(bias.normalOffsetScale, that.viewShadowMap._distance, that.viewShadowMap.maximumDistance, that.viewShadowMap._darkness, this.combinedUniforms2);
                                },
                                disViewColor: function disViewColor() {
                                    return that._disViewColor;
                                },
                                clearBlack: function clearBlack() {
                                    return that.clearBlack;
                                }
                            }
                        });
                        this.viewer.scene.postProcessStages.add(this.postProcess);
                    }
                }, {
                    key: "update",
                    value: function update(frameState) {
                        this.viewShadowMap && frameState.shadowMaps.push(this.viewShadowMap);
                    }
                }, {
                    key: "destroy",
                    value: function destroy() {
                        this.viewer.scene.postProcessStages.remove(this.postProcess);
                        // this.videoTexture.destroy();
                        this.viewer.scene.primitives.remove(this.cameraFrustum);

                        this.videoElement && this.videoElement.parentNode.removeChild(this.videoElement);
                        delete this.videoElement;

                        this.viewer.clock.onTick.removeEventListener(this.activeVideoListener, this);

                        delete this.activeVideoListener;
                        delete this.postProcess;
                        delete this.viewShadowMap;
                        delete this.color;
                        delete this.viewDis;
                        delete this.cameraPosition;
                        delete this.position;
                        delete this.alpha;
                        delete this._camerafov;
                        delete this._cameraPosition;
                        delete this.videoTexture;
                        delete this.cameraFrustum;
                        delete this.dom;

                        delete this._debugFrustum;
                        delete this._position;
                        delete this._aspectRatio;
                        delete this.orientation;
                        delete this.texture;
                        // delete this.videoId;
                        delete this.type;
                        delete this.videoTexture;
                        delete this.url;
                        this.viewer.scene.primitives.remove(this);
                        delete this.viewer;
                    }
                }, {
                    key: "alpha",
                    get: function get() {
                        return this._alpha;
                    },
                    set: function set(val) {
                        this._alpha = val;
                    }

                    //相机宽高比例

                }, {
                    key: "aspectRatio",
                    get: function get() {
                        return this._aspectRatio;
                    },
                    set: function set(val) {
                        this._aspectRatio = val;
                        this._changeVideoWidHei();
                    }
                    //视椎体显隐

                }, {
                    key: "debugFrustum",
                    get: function get() {
                        return this._debugFrustum;
                    },
                    set: function set(val) {
                        this._debugFrustum = val;
                        this.cameraFrustum.show = val;
                    }
                    //相机水平张角

                }, {
                    key: "fov",
                    get: function get() {
                        return this._camerafov;
                    },
                    set: function set(val) {
                        this._camerafov = Cesium.Math.toRadians(val);
                        this._changeCameraFov();
                    }
                    //相机位置

                }, {
                    key: "cameraPosition",
                    get: function get() {
                        return this._cameraPosition;
                    },
                    set: function set(pos) {
                        if (!pos) return;
                        this._cameraPosition = pos;
                        this._changeCameraPos();
                    }
                    //视点位置

                }, {
                    key: "position",
                    get: function get() {
                        return this._position;
                    },
                    set: function set(pos) {
                        if (!pos) return;
                        this._position = pos;
                        this._changeViewPos();
                    }
                    //切换视频 播放/暂停

                }, {
                    key: "videoPlay",
                    get: function get() {
                        return this._videoPlay;
                    },
                    set: function set(val) {
                        this._videoPlay = Boolean(val);
                        if (this.videoElement) {
                            if (this.videoPlay) this.videoElement.play(); else this.videoElement.pause();
                        }
                    }

                    /** 所有相机的参数  */

                }, {
                    key: "params",
                    get: function get() {
                        var viewJson = {};
                        viewJson.type = this.type;
                        if (this.type == Video3DType.Color) viewJson.color = this.color; else viewJson.url = this.url;

                        viewJson.position = this.position;
                        viewJson.cameraPosition = this.cameraPosition;
                        viewJson.fov = Cesium.Math.toDegrees(this.fov);
                        viewJson.aspectRatio = this.aspectRatio;
                        viewJson.alpha = this.alpha;
                        viewJson.debugFrustum = this.debugFrustum;
                        viewJson.dirObj = this._dirObj;
                        return viewJson;
                    }

                    //显示和隐藏

                }, {
                    key: "show",
                    get: function get() {
                        return this.defaultShow;
                    },
                    set: function set(val) {
                        this.defaultShow = Boolean(val);
                        this._switchShow();
                    }
                }, {
                    key: "camera",
                    get: function get() {
                        return this.viewShadowMap._lightCamera;
                    }
                    //========== 方法 ========== 

                }, {
                    key: "disViewColor",
                    get: function get() {
                        return this._disViewColor;
                    },
                    set: function set(color) {
                        if (!color) return;
                        this._disViewColor = color;
                        if (!color.a && color.a != 0) {
                            this._disViewColor.a = 1.0;
                        }
                    }
                }]);

                return Video3D;
            }();

            Video3D.Type = Video3DType;

            /***/
}),
/* 193 */
/***/ (function (module, exports) {

            module.exports = "\r\n\r\n\r\n\r\nuniform float mixNum;\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D mapvShadow; \r\nuniform sampler2D videoTexture;\r\nuniform sampler2D depthTexture;\r\nuniform mat4 _shadowMap_matrix; \r\nuniform vec4 shadowMap_lightPositionEC; \r\nuniform vec4 shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness; \r\nuniform vec4 shadowMap_texelSizeDepthBiasAndNormalShadingSmooth; \r\nuniform vec4 disViewColor;\r\nuniform bool clearBlack;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nfloat _czm_sampleShadowMap(sampler2D shadowMap, vec2 uv){\r\n    return texture2D(shadowMap, uv).r;\r\n}\r\nfloat _czm_shadowDepthCompare(sampler2D shadowMap, vec2 uv, float depth){\r\n    return step(depth, _czm_sampleShadowMap(shadowMap, uv));\r\n}\r\nfloat _czm_shadowVisibility(sampler2D shadowMap, czm_shadowParameters shadowParameters){\r\n    float depthBias = shadowParameters.depthBias;\r\n    float depth = shadowParameters.depth;\r\n    float nDotL = shadowParameters.nDotL;\r\n    float normalShadingSmooth = shadowParameters.normalShadingSmooth;\r\n    float darkness = shadowParameters.darkness;\r\n    vec2 uv = shadowParameters.texCoords;\r\n    depth -= depthBias;\r\n    vec2 texelStepSize = shadowParameters.texelStepSize;\r\n    float radius = 1.0;\r\n    float dx0 = -texelStepSize.x * radius;\r\n    float dy0 = -texelStepSize.y * radius;\r\n    float dx1 = texelStepSize.x * radius;\r\n    float dy1 = texelStepSize.y * radius;\r\n    float visibility = \r\n    (\r\n    _czm_shadowDepthCompare(shadowMap, uv, depth)\r\n    +_czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\r\n    _czm_shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\r\n    ) * (1.0 / 9.0)\r\n    ;\r\n    return visibility;\r\n}\r\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point){\r\n    vec3 v01 = point -planeOrigin;\r\n    float d = dot(planeNormal, v01) ;\r\n    return (point - planeNormal * d);\r\n}\r\nfloat ptm(vec3 pt){\r\n    return sqrt(pt.x*pt.x + pt.y*pt.y + pt.z*pt.z);\r\n}\r\nvoid main() \r\n{ \r\n    const float PI = 3.141592653589793;\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 normalEC = vec3(1.0);\r\n    czm_shadowParameters shadowParameters; \r\n    shadowParameters.texelStepSize = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.xy; \r\n    shadowParameters.depthBias = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.z; \r\n    shadowParameters.normalShadingSmooth = shadowMap_texelSizeDepthBiasAndNormalShadingSmooth.w; \r\n    shadowParameters.darkness = shadowMap_normalOffsetScaleDistanceMaxDistanceAndDarkness.w; \r\n    shadowParameters.depthBias *= max(depth * 0.01, 1.0); \r\n    vec3 directionEC = normalize(positionEC.xyz - shadowMap_lightPositionEC.xyz); \r\n    float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0); \r\n    vec4 shadowPosition = _shadowMap_matrix * positionEC; \r\n    shadowPosition /= shadowPosition.w; \r\n    if (any(lessThan(shadowPosition.xyz, vec3(0.0))) || any(greaterThan(shadowPosition.xyz, vec3(1.0)))) \r\n    { \r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n\r\n    shadowParameters.texCoords = shadowPosition.xy; \r\n    shadowParameters.depth = shadowPosition.z; \r\n    shadowParameters.nDotL = nDotL; \r\n    float visibility = _czm_shadowVisibility(mapvShadow, shadowParameters); \r\n\r\n    vec4 videoColor = texture2D(videoTexture,shadowPosition.xy);\r\n    if(clearBlack){\r\n        if(videoColor.r + videoColor.g + videoColor.b <0.01){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n    }\r\n    if(visibility==1.0){\r\n        gl_FragColor = mix(color,vec4(videoColor.xyz,1.0),mixNum*videoColor.a);\r\n    }else{\r\n        if(abs(shadowPosition.z-0.0)<0.01){\r\n            return;\r\n        }\r\n        if(clearBlack){\r\n            gl_FragColor = color;\r\n            return;\r\n        }\r\n        gl_FragColor = vec4(mix(color.rgb,disViewColor.rgb,disViewColor.a),disViewColor.a);\r\n    }\r\n} "

            /***/
}),
/* 194 */
/***/ (function (module, exports, __webpack_require__) {

            "use strict";


            Object.defineProperty(exports, "__esModule", {
                value: true
            });
            exports.Video2D = undefined;

            var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

            var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

            var _cesium = __webpack_require__(0);

            var Cesium = _interopRequireWildcard(_cesium);

            function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

            function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

            var ratateDirection = {
                'LEFT': 'Z',
                'RIGHT': '-Z',
                'TOP': 'Y',
                'BOTTOM': '-Y',
                'ALONG': 'X',
                'INVERSE': '-X'

                //视频融合（投射2D平面）


                //原理：根据相机位置，方向等参数，在相机前面生成一个平面，然后贴视频纹理


            };
            var Video2D = exports.Video2D = function () {
                //========== 构造方法 ========== 
                function Video2D(viewer, dom, options) {
                    _classCallCheck(this, Video2D);

                    if (!viewer) return;
                    this.viewer = viewer;
                    options = Cesium.defaultValue(options, {});
                    this.dom = Cesium.defaultValue(dom, null);
                    this._play = true;
                    this._aspectRatio = Cesium.defaultValue(options.aspectRatio, null);
                    if (!this._aspectRatio) {
                        this._aspectRatio = this.viewer.scene.context.drawingBufferWidth / this.viewer.scene.context.drawingBufferHeight;
                    }
                    this._fov = Cesium.defaultValue(options.fov, this.viewer.scene.camera.frustum.fov);
                    this._dis = Cesium.defaultValue(options.dis, 10);
                    this._stRotation = Cesium.defaultValue(options.stRotation, 0);
                    this._rotateCam = Cesium.defaultValue(options.rotateCam, 0.05);
                    this._frustumShow = Cesium.defaultValue(options.frustumShow, true);
                    this._camera = Cesium.defaultValue(options.camera, null);
                    // this.reverse = false;
                    var ckr = this.checkDom(this.dom);
                    if (!ckr) {
                        if (typeof this.dom == 'string' && this.dom.constructor == String) {
                            this._url = this.dom;
                            this.dom = this._createVideoEle(this._url);
                        }
                        console.log("传入了非DOM元素");
                        return;
                    }
                    this.init();
                }

                //视频播放暂停


                _createClass(Video2D, [{
                    key: 'init',
                    value: function init() {
                        this.recordObj = this.record();
                        this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
                        var sys = this.getOrientation(this.recordObj);
                        var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
                        var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
                        this.frustumPri = this.createFrustumPri(frustumGeo);
                        this.addToScene();
                    }
                }, {
                    key: 'reset',
                    value: function reset() {
                        this.viewer.scene.primitives.remove(this.frustumPri);
                        this.viewer.entities.remove(this.entity);
                        this.rectPos = this.computedPos(this.dis, this.fov, this.aspectRatio, this.recordObj);
                        var sys = this.getOrientation(this.recordObj);
                        var frustum = this.createFrustum(this.fov, this.aspectRatio, this.dis);
                        var frustumGeo = this.createFrustumGeo(frustum, sys, this.recordObj.position);
                        this.frustumPri = this.createFrustumPri(frustumGeo);
                        this.addToScene();
                    }
                }, {
                    key: 'record',
                    value: function record() {
                        var obj = {};
                        var camera = this._camera || this.viewer.scene.camera;
                        obj.direction = Cesium.clone(camera.direction);
                        obj.up = Cesium.clone(camera.up);
                        obj.right = Cesium.clone(camera.right);
                        obj.position = Cesium.clone(camera.position);
                        return obj;
                    }
                }, {
                    key: 'addToScene',
                    value: function addToScene() {
                        this.viewer.scene.primitives.add(this.frustumPri);
                        this.entity = viewer.entities.add({
                            polygon: {
                                hierarchy: this.rectPos,
                                perPositionHeight: true,
                                material: this.dom,
                                stRotation: this.stRotation
                            }
                        });
                    }
                }, {
                    key: 'computedPos',
                    value: function computedPos(dis, fov, kgb, camera) {
                        var viewer = this.viewer;
                        var vpos = camera.position;
                        var vdir = camera.direction;
                        var vright = camera.right;
                        var vup = camera.up;
                        var vray = new Cesium.Ray(vpos, vdir);
                        var vmbpos = Cesium.Ray.getPoint(vray, dis, new Cesium.Cartesian3());
                        var halfFov = fov / 2.0;
                        var tanres = Math.tan(halfFov);
                        var horiDis = dis * tanres;
                        var vertDis = horiDis / kgb;
                        var xbDis = Math.sqrt(horiDis * horiDis + vertDis * vertDis);

                        var ysj = new Cesium.Cartesian3();
                        var rightRay = new Cesium.Ray(vmbpos, vright);
                        var rightPos = Cesium.Ray.getPoint(rightRay, horiDis, new Cesium.Cartesian3());
                        var upRay = new Cesium.Ray(rightPos, vup);
                        Cesium.Ray.getPoint(upRay, vertDis, ysj);

                        var yxj = new Cesium.Cartesian3();
                        var fvup = Cesium.Cartesian3.negate(vup, new Cesium.Cartesian3());
                        var fupRay = new Cesium.Ray(rightPos, fvup);
                        Cesium.Ray.getPoint(fupRay, vertDis, yxj);

                        var zxj = new Cesium.Cartesian3();
                        var djdir1 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, ysj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                        var djRay1 = new Cesium.Ray(vmbpos, djdir1);
                        Cesium.Ray.getPoint(djRay1, xbDis, zxj);

                        var zsj = new Cesium.Cartesian3();
                        var djdir2 = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(vmbpos, yxj, new Cesium.Cartesian3()), new Cesium.Cartesian3());
                        var djRay2 = new Cesium.Ray(vmbpos, djdir2);
                        Cesium.Ray.getPoint(djRay2, xbDis, zsj);
                        if (this.reverse) {
                            return [zxj, zsj, ysj, yxj].reverse();
                        }
                        return [zxj, zsj, ysj, yxj];
                    }
                }, {
                    key: 'checkDom',
                    value: function checkDom(dom) {
                        if (!dom) return;
                        if (dom instanceof Object && dom.length) {
                            dom = dom[0];
                            this.dom = dom;
                        }

                        if ((typeof HTMLElement === 'undefined' ? 'undefined' : _typeof(HTMLElement)) === 'object') {
                            return dom instanceof HTMLElement;
                        } else {
                            return dom && (typeof dom === 'undefined' ? 'undefined' : _typeof(dom)) === 'object' && dom.nodeType === 1 && typeof dom.nodeName === 'string';
                        }
                    }
                    //创建video元素

                }, {
                    key: '_createVideoEle',
                    value: function _createVideoEle(src) {
                        //创建可视域video DOM  元素
                        if (!src) return;
                        this.videoId = 'visualDomId';
                        var source_map4 = document.createElement("SOURCE");
                        source_map4.type = 'video/mp4';
                        source_map4.src = src;
                        var source_mov = document.createElement("SOURCE");
                        source_mov.type = 'video/quicktime';
                        source_mov.src = src;
                        var videoEle = document.createElement("VIDEO");
                        // videoEle.id = this.videoId;
                        videoEle.setAttribute('autoplay', true);
                        videoEle.setAttribute('loop', true);
                        videoEle.setAttribute('crossorigin', true);
                        videoEle.appendChild(source_map4);
                        videoEle.appendChild(source_mov);
                        videoEle.style.display = 'none';
                        document.body.appendChild(videoEle);
                        return videoEle;
                    }
                }, {
                    key: 'createFrustum',
                    value: function createFrustum(fov, kgb, dis) {
                        return new Cesium.PerspectiveFrustum({
                            fov: fov,
                            aspectRatio: kgb,
                            near: 0.1,
                            far: dis
                        });
                    }
                }, {
                    key: 'getOrientation',
                    value: function getOrientation(camera) {
                        if (!camera) return;
                        var direction = camera.direction;
                        var up = camera.up;
                        var right = camera.right;
                        var scratchRight = new Cesium.Cartesian3();
                        var scratchRotation = new Cesium.Matrix3();
                        var scratchOrientation = new Cesium.Quaternion();

                        // var right = Cesium.Cartesian3.cross(direction,up,new Cesium.Cartesian3());
                        right = Cesium.Cartesian3.negate(right, scratchRight);
                        var rotation = scratchRotation;
                        Cesium.Matrix3.setColumn(rotation, 0, right, rotation);
                        Cesium.Matrix3.setColumn(rotation, 1, up, rotation);
                        Cesium.Matrix3.setColumn(rotation, 2, direction, rotation);
                        //计算视锥姿态
                        var orientation = Cesium.Quaternion.fromRotationMatrix(rotation, scratchOrientation);
                        return orientation;
                    }
                }, {
                    key: 'createFrustumGeo',
                    value: function createFrustumGeo(frustum, sys, origin) {
                        return new Cesium.FrustumOutlineGeometry({
                            frustum: frustum,
                            orientation: sys,
                            origin: origin
                        });
                    }
                }, {
                    key: 'createFrustumPri',
                    value: function createFrustumPri(geo) {
                        var instance = new Cesium.GeometryInstance({
                            geometry: geo
                        });
                        return new Cesium.Primitive({
                            geometryInstances: instance,
                            appearance: new Cesium.MaterialAppearance({
                                material: Cesium.Material.fromType('Color'),
                                faceForward: true
                            })
                        });
                    }
                    /**
                     * 呈现投影相机的第一视角
                     */

                }, {
                    key: 'locate',
                    value: function locate() {
                        this.viewer.camera.direction = Cesium.clone(this.recordObj.direction);
                        this.viewer.camera.right = Cesium.clone(this.recordObj.right);
                        this.viewer.camera.up = Cesium.clone(this.recordObj.up);
                        this.viewer.camera.position = Cesium.clone(this.recordObj.position);
                    }

                    //旋转相机

                }, {
                    key: 'rotateCamera',
                    value: function rotateCamera(axis, deg) {
                        var rotateDegree = Cesium.defaultValue(deg, this._rotateCam);
                        switch (axis) {
                            case ratateDirection.LEFT:
                                break;
                            case ratateDirection.RIGHT:
                                rotateDegree *= -1;
                                break;
                            case ratateDirection.TOP:
                                break;
                            case ratateDirection.BOTTOM:
                                rotateDegree *= -1;
                                break;
                            case ratateDirection.ALONG:
                                break;
                            case ratateDirection.INVERSE:
                                rotateDegree *= -1;
                                break;
                        }
                        var newObj = this._computedNewViewDir(axis, rotateDegree);
                        this.recordObj.direction = newObj.direction;
                        this.recordObj.up = newObj.up;
                        this.recordObj.right = newObj.right;
                        this.reset();
                    }

                    //计算新视点

                }, {
                    key: '_computedNewViewDir',
                    value: function _computedNewViewDir(axis, deg) {
                        deg = Cesium.Math.toRadians(deg);
                        var camera = this.recordObj;
                        var oldDir = Cesium.clone(camera.direction);
                        var oldRight = Cesium.clone(camera.right);
                        var oldTop = Cesium.clone(camera.up);
                        var mat3 = new Cesium.Matrix3();

                        switch (axis) {
                            case ratateDirection.LEFT:
                                Cesium.Matrix3.fromRotationZ(deg, mat3);
                                break;
                            case ratateDirection.RIGHT:
                                Cesium.Matrix3.fromRotationZ(deg, mat3);
                                break;
                            case ratateDirection.TOP:
                                Cesium.Matrix3.fromRotationY(deg, mat3);
                                break;
                            case ratateDirection.BOTTOM:
                                Cesium.Matrix3.fromRotationY(deg, mat3);
                                break;
                            case ratateDirection.ALONG:
                                Cesium.Matrix3.fromRotationX(deg, mat3);
                                break;
                            case ratateDirection.INVERSE:
                                Cesium.Matrix3.fromRotationX(deg, mat3);
                                break;
                        }
                        var localToWorld_Matrix = Cesium.Transforms.eastNorthUpToFixedFrame(camera.position);
                        // var hpr = new Cesium.HeadingPitchRoll(viewer.camera.heading,viewer.camera.pitch,viewer.camera.roll);
                        // localToWorld_Matrix = Cesium.Transforms.headingPitchRollToFixedFrame(viewer.camera.position,hpr,Cesium.Ellipsoid.WGS84,Cesium.Transforms.eastNorthUpToFixedFrame);
                        var worldToLocal_Matrix = Cesium.Matrix4.inverse(localToWorld_Matrix, new Cesium.Matrix4());

                        var localDir = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldDir, new Cesium.Cartesian3());
                        var localNewDir = Cesium.Matrix3.multiplyByVector(mat3, localDir, new Cesium.Cartesian3());
                        var newDir = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewDir, new Cesium.Cartesian3());

                        var localRight = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldRight, new Cesium.Cartesian3());
                        var localNewRight = Cesium.Matrix3.multiplyByVector(mat3, localRight, new Cesium.Cartesian3());
                        var newRight = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewRight, new Cesium.Cartesian3());

                        var localTop = Cesium.Matrix4.multiplyByPointAsVector(worldToLocal_Matrix, oldTop, new Cesium.Cartesian3());
                        var localNewTop = Cesium.Matrix3.multiplyByVector(mat3, localTop, new Cesium.Cartesian3());
                        var newTop = Cesium.Matrix4.multiplyByPointAsVector(localToWorld_Matrix, localNewTop, new Cesium.Cartesian3());
                        return {
                            direction: newDir,
                            right: newRight,
                            up: newTop
                        };
                    }
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this.viewer.scene.primitives.remove(this.frustumPri);
                        this.viewer.entities.remove(this.entity);
                        delete this.recordObj.direction;
                        delete this.recordObj.right;
                        delete this.recordObj.up;
                        delete this.recordObj.position;
                        delete this.recordObj;
                        delete this.aspectRatio;
                        delete this.fov;
                        delete this.dis;
                        delete this.dom;
                        delete this.rectPos;
                    }
                }, {
                    key: 'play',
                    get: function get() {
                        return this._play;
                    },
                    set: function set(val) {
                        this._play = Boolean(val);
                        if (this._play) {
                            this.dom.play();
                        } else {
                            this.dom.pause();
                        }
                    }
                    //宽高比

                }, {
                    key: 'aspectRatio',
                    get: function get() {
                        return this._aspectRatio;
                    },
                    set: function set(val) {
                        val = Number(val);
                        if (!val || val < 0) return;
                        if (val < 1.0) val = 1.0;
                        this._aspectRatio = val;
                        this.reset();
                    }
                    //张角

                }, {
                    key: 'fov',
                    get: function get() {
                        return this._fov;
                    },
                    set: function set(val) {
                        val = Number(val);
                        if (!val || val < 0) return;
                        this._fov = val;
                        this.reset();
                    }
                    //投射距离

                }, {
                    key: 'dis',
                    get: function get() {
                        return this._dis;
                    },
                    set: function set(val) {
                        val = Number(val);
                        if (!val || val < 0) return;
                        this._dis = val;
                        this.reset();
                    }

                    //UV旋转

                }, {
                    key: 'stRotation',
                    get: function get() {
                        return this._stRotation;
                    },
                    set: function set(val) {
                        val = Number(val);
                        if (!val || val < 0) return;
                        this._stRotation = val;
                        this.entity.polygon.stRotation = val;
                    }

                    //视椎体显示

                }, {
                    key: 'frustumShow',
                    get: function get() {
                        return this._frustumShow;
                    },
                    set: function set(val) {
                        val = Boolean(val);
                        this._frustumShow = val;
                        this.frustumPri.show = val;
                    }

                    /** 所有相机的参数  */

                }, {
                    key: 'params',
                    get: function get() {
                        var viewJson = {
                            fov: this.fov,
                            dis: this.dis,
                            stRotation: this.stRotation,
                            frustumShow: this.frustumShow,
                            aspectRatio: this.aspectRatio,
                            camera: {
                                position: this.recordObj.position,
                                direction: this.recordObj.direction,
                                up: this.recordObj.up,
                                right: this.recordObj.right
                            }
                        };
                        return viewJson;
                    }
                }]);

                return Video2D;
            }();

            /***/
})
/******/]);
});