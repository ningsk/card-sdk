/* 226 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvec3 guussColor(vec2 uv){\r\n    vec2 pixelSize = 1.0 / czm_viewport.zw;\r\n    float dx0 = -pixelSize.x;\r\n    float dy0 = -pixelSize.y;\r\n    float dx1 = pixelSize.x;\r\n    float dy1 = pixelSize.y;\r\n    vec4 gc = (\r\n        texture2D(colorTexture, uv)+\r\n        texture2D(colorTexture, uv + vec2(dx0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, 0.0)) +\r\n        texture2D(colorTexture, uv + vec2(dx0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(0.0, dy1)) +\r\n        texture2D(colorTexture, uv + vec2(dx1, dy1))\r\n    ) * (1.0 / 9.0);\r\n    return gc.rgb;\r\n}\r\nvoid main(){\r\n    // mat4 dither = mat4(\r\n    //     0,       0.5,    0.125,  0.625,\r\n    //     0.75,    0.25,   0.875,  0.375,\r\n    //     0.1875,  0.6875, 0.0625, 0.5625,\r\n    //     0.9375,  0.4375, 0.8125, 0.3125\r\n    // );\r\n    // int sampleCoordX = int(mod((gl_FragCoord.x * v_textureCoordinates.x),4.0));\r\n    // int sampleCoordY = int(mod((gl_FragCoord.y * v_textureCoordinates.y),4.0));\r\n    float offset = 0.0;\r\n\r\n\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    // gl_FragColor = currD;\r\n    // return;\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    // gl_FragColor = vec4(depth,0.0,0.0,1.0);\r\n    // return;\r\n\r\n    \r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 normal = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * normal);\r\n    float fotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(fotNumWC<=0.5){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    \r\n\r\n\r\n\r\n\r\n    // float dotNum = dot(normal,vec3(0.0,1.0,0.0));\r\n    // gl_FragColor = mix(color,vec4(1.0),dotNum*0.8);\r\n    // return;\r\n\r\n    vec3 viewDir = normalize(positionEC.xyz);\r\n    vec3 reflectDir = reflect(viewDir, normal);\r\n    // vec3 viewReflectDir = czm_viewRotation * reflectDir;\r\n    vec3 viewReflectDir = reflectDir;\r\n\r\n    \r\n    float step = 0.05;\r\n    int stepNum = int(20.0 / step);\r\n    vec3 pos;\r\n    vec3 albedo;\r\n    bool jd = false;\r\n    for(int i = 1;i <= 400;i++)\r\n    {\r\n        float delta = step * float(i) + offset;\r\n        pos = positionEC.xyz + viewReflectDir * delta;\r\n        float d = -pos.z;\r\n\r\n        vec4 tmp = czm_projection * vec4(pos,1.0);\r\n        vec3 screenPos = tmp.xyz / tmp.w;\r\n        vec2 uv = vec2(screenPos.x, screenPos.y) * 0.5 + vec2(0.5, 0.5);\r\n        \r\n        if(uv.x > 0.0 && uv.x < 1.0 && uv.y > 0.0 && uv.y < 1.0){\r\n            float dd = getDepth(texture2D(depthTexture, uv));\r\n            vec4 jzc = toEye(uv, dd);\r\n            dd = -jzc.z;\r\n            if(d>dd){\r\n                if(abs(abs(d) - abs(dd)) <=step){\r\n                    jd = true;\r\n                    // albedo = texture2D(colorTexture, uv).rgb;\r\n                    albedo = guussColor(uv);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if(jd){\r\n        gl_FragColor = vec4(mix(color.xyz,albedo,0.5),1.0);\r\n    }else{\r\n        gl_FragColor = color;\r\n    }\r\n}"

/***/ }),
