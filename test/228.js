
/* 228 */
/***/ (function(module, exports) {

module.exports = "#extension GL_OES_standard_derivatives : enable\r\nuniform sampler2D colorTexture;\r\nuniform sampler2D depthTexture;\r\nuniform float alpha;\r\nvarying vec2 v_textureCoordinates;\r\nvec4 toEye(in vec2 uv, in float depth){\r\n    vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\r\n    vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\r\n    posInCamera =posInCamera / posInCamera.w;\r\n    return posInCamera;\r\n}\r\nfloat getDepth(in vec4 depth){\r\n    float z_window = czm_unpackDepth(depth);\r\n    z_window = czm_reverseLogDepth(z_window);\r\n    float n_range = czm_depthRange.near;\r\n    float f_range = czm_depthRange.far;\r\n    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n}\r\nvoid main(){\r\n    vec4 color = texture2D(colorTexture, v_textureCoordinates);\r\n    vec4 currD = texture2D(depthTexture, v_textureCoordinates);\r\n    if(currD.r>=1.0){\r\n        gl_FragColor = color;\r\n        return;\r\n    }\r\n    float depth = getDepth(currD);\r\n    vec4 positionEC = toEye(v_textureCoordinates, depth);\r\n    vec3 dx = dFdx(positionEC.xyz);\r\n    vec3 dy = dFdy(positionEC.xyz);\r\n    vec3 nor = normalize(cross(dx,dy));\r\n\r\n    vec4 positionWC = normalize(czm_inverseView * positionEC);\r\n    vec3 normalWC = normalize(czm_inverseViewRotation * nor);\r\n    float dotNumWC = dot(positionWC.xyz,normalWC);\r\n    if(dotNumWC<=0.3){\r\n        gl_FragColor = mix(color,vec4(1.0),alpha*0.3);\r\n        return;\r\n    }\r\n    gl_FragColor = mix(color,vec4(1.0),dotNumWC*alpha);\r\n}"

/***/ }),
